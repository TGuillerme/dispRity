?plot.mulTree
plot(results)
file.remove(list.files(pattern="longevity.example"))
All Gists#
#
    TGuillerme#
#
0#
#
    0#
#
nhcooper123 / macroBINGO#
Last active 8 minutes ago#
#
    Code#
    Revisions 2#
#
Embed URL#
#
HTTPS clone URL#
#
You can clone with HTTPS or SSH.#
#
Macroecology bingo!#
#
macroBINGO#
#
require(gridExtra)#
# Add squares you want#
squares <- c("global bird map",  "rainbow scale",#
             "butterflies", "birds", "ants", "fish",#
             "Jetz", "Rahbeck", "Gaston", "Blackburn", "Brown",#
             "Colwell", "mid-domain effect",#
             "Darwin picture", "Darwin quotation",#
             "Wallace picture", "Wallace quotation",#
             "incomprehensible graph", "tiny R^2",#
             "biodiversity collage", "over 10 variables",#
             "species-area curve", "over 1000 species", #
             "species-abundance curve", "paradigm shift",#
             "mass-metabolic rate curve", "Nature paper",#
             "we need more data", "Science paper",#
             "data quality", "massive database",#
             "other peoples data")#
# Sample 24 at random and build a matrix#
sample.squares <- sample(squares, size = 24, replace = FALSE)#
bingo.matrix <- matrix(data = sample.squares, ncol = 4, nrow = 6)#
# Make a pretty bingo card#
plot.new()#
grid.table(bingo.matrix,#
           gpar.coretext=gpar(fontsize = 10),#
           gpar.coltext = gpar(fontsize = 10),#
           gpar.rowtext = gpar(fontsize = 10),#
           #gpar.corefill = gpar(fill = rainbow(8), alpha = 0.1, col = NA), # you can make coloured versions if you want#
           h.even.alpha = 0.5,#
           equal.width = FALSE,#
           show.rownames = FALSE,#
           show.vlines = TRUE,#
           padding.h = unit(8, "mm"),#
           padding.v = unit(8, "mm")#
           )#
#
    Write Preview #
#
Parsed as Markdown Edit in fullscreen#
#
    Status API Blog About #
#
    © 2015 GitHub, Inc. Terms Privacy Security Contact
require(gridExtra)#
#
# Add squares you want#
squares <- c("global bird map",  "rainbow scale",#
             "butterflies", "birds", "ants", "fish",#
             "Jetz", "Rahbeck", "Gaston", "Blackburn", "Brown",#
             "Colwell", "mid-domain effect",#
             "Darwin picture", "Darwin quotation",#
             "Wallace picture", "Wallace quotation",#
             "incomprehensible graph", "tiny R^2",#
             "biodiversity collage", "over 10 variables",#
             "species-area curve", "over 1000 species", #
             "species-abundance curve", "paradigm shift",#
             "mass-metabolic rate curve", "Nature paper",#
             "we need more data", "Science paper",#
             "data quality", "massive database",#
             "other peoples data")#
#
# Sample 24 at random and build a matrix#
sample.squares <- sample(squares, size = 24, replace = FALSE)#
bingo.matrix <- matrix(data = sample.squares, ncol = 4, nrow = 6)#
#
# Make a pretty bingo card#
plot.new()#
grid.table(bingo.matrix,#
           gpar.coretext=gpar(fontsize = 10),#
           gpar.coltext = gpar(fontsize = 10),#
           gpar.rowtext = gpar(fontsize = 10),#
           #gpar.corefill = gpar(fill = rainbow(8), alpha = 0.1, col = NA), # you can make coloured versions if you want#
           h.even.alpha = 0.5,#
           equal.width = FALSE,#
           show.rownames = FALSE,#
           show.vlines = TRUE,#
           padding.h = unit(8, "mm"),#
           padding.v = unit(8, "mm")#
           )
607/439
518/399
2491/5
36*2
36*3/7
357-100
357-200
508/439
45/7
65/7
library(lattice)#
library(MASS)#
library(mvtnorm)#
library(ape)#runs pgls implemeted in nlme#
library(geiger)#to use the function 'datatree'#
library(MCMCglmm)#runs Phylogenetic Mixed Models#
#uMCMCglmm <- updateable(MCMCglmm)#MCMCglmm needs this to implement the fuction dredge (MuMIn)#
library(reshape); library(pscl); library(MuMIn); library(boot); library(ggplot2); library(lme4)#
library(nlme)#runs gls#
library(AICcmodavg)#model selection and multimodel inferece based on (Q)AIC(c)#
library(coda)#determines the number of iterations, thinning and the burn-in period for each model run
setwd("/Users/TGuillerme/R_files")
library(mulTree)#mulTree comibines a table and a multiple phylogenies in MCMCglmm
library(coda)#determines the number of iterations, thinning and the burn-in period for each model run
library(AICcmodavg)#model selection and multimodel inferece based on (Q)AIC(c)
install.packages("AICcmodavg")#model selection and multimodel inferece based on (Q)AIC(c)
library(AICcmodavg)#model selection and multimodel inferece based on (Q)AIC(c)
library(nlme)#runs gls
library(reshape); library(pscl); library(MuMIn); library(boot); library(ggplot2); library(lme4)
install.packages("pscl")
library(reshape); library(pscl); library(MuMIn); library(boot); library(ggplot2); library(lme4)
install.packages("MuMIn")
library(reshape); library(pscl); library(MuMIn); library(boot); library(ggplot2); library(lme4)
install.packages("lme4")
library(reshape); library(pscl); library(MuMIn); library(boot); library(ggplot2); library(lme4)
library(MCMCglmm)#runs Phylogenetic Mixed Models
library(geiger)#to use the function 'datatree'
install.packages("geiger")
library(lattice)#
library(MASS)#
library(mvtnorm)#
library(ape)#runs pgls implemeted in nlme#
library(geiger)#to use the function 'datatree'
trees =  read.nexus("Helminths_100.tre")#100 trees, all 106 spp , see http://birdtree.org/ (Hackett all species)
Ntip(trees)
Ntip(trees[[1]])
Helminths<-NULL
Helminths<-data.frame()
Helminths<-matrix(data=NA, nrow=Ntip(trees[[1]]), ncol=4)
tip.labels()
tip.label()
trees[[1]]$tip.label
Helminths<-matrix(data=rnorm(Ntip(trees[[1]]*4), nrow=Ntip(trees[[1]]), ncol=4, rownames=trees[[1]]$tip.label)
Helminths
(Ntip(trees[[1]]*4)
Helminths<-matrix(data=rnorm(Ntip(trees[[1]])*4), nrow=Ntip(trees[[1]]), ncol=4, rownames=trees[[1]]$tip.label)
Helminths<-matrix(data=rnorm(Ntip(trees[[1]])*4), nrow=Ntip(trees[[1]]), ncol=4)
Helminths
Helminths<-as.data.frame(matrix(data=rnorm(Ntip(trees[[1]])*4), nrow=Ntip(trees[[1]]), ncol=4), rownames=trees[[1]]$tip.label)
Helminths
Helminths$Mass<-scale(Helminths$Mass)
trees[[1]]$tip.label
Helminths<-as.data.frame(matrix(data=rnorm(Ntip(trees[[1]])*4), nrow=Ntip(trees[[1]]), ncol=4), rownames=trees[[1]]$tip.label)
Helminths
Helminths<-as.data.frame(matrix(data=rnorm(Ntip(trees[[1]])*4), nrow=Ntip(trees[[1]]), ncol=4), row.names=trees[[1]]$tip.label)
Helminths
Helminths<-as.data.frame(matrix(data=rnorm(Ntip(trees[[1]])*4), nrow=Ntip(trees[[1]]), ncol=4), row.names=trees[[1]]$tip.label, col.names=c("Mass", "Latitude", "Geographical_range", "Migratory_distance"))
Helminths
names(Helminths)
names(Helminths)<-c("Mass", "Latitude", "Geographical_range", "Migratory_distance")
Helminths
pri2 <- list(R = list(V = 1, nu = 1), G = list(G1 = list(V = 1, nu = 1),G2 = list(V = 1, nu = 1)))#two random effects
mulTree_H<-as.mulTree(Helminths, trees, species="animal", rand.term=~animal+StudyID)
setwd("/Users/TGuillerme/R_files")
library(lattice)#
library(MASS)#
library(mvtnorm)#
library(ape)#runs pgls implemeted in nlme#
library(geiger)#to use the function 'datatree'#
library(MCMCglmm)#runs Phylogenetic Mixed Models#
#uMCMCglmm <- updateable(MCMCglmm)#MCMCglmm needs this to implement the fuction dredge (MuMIn)#
library(reshape); library(pscl); library(MuMIn); library(boot); library(ggplot2); library(lme4)#
library(nlme)#runs gls#
library(AICcmodavg)#model selection and multimodel inferece based on (Q)AIC(c)#
library(coda)#determines the number of iterations, thinning and the burn-in period for each model run#
#install.packages("devtools")#
library(devtools)#
install_github("TGuillerme/mulTree")#
library(mulTree)#mulTree comibines a table and a multiple phylogenies in MCMCglmm
Helminths <- read.table(file = "helminths.txt", header = TRUE, dec = ".", sep="\t")#
Helminths = Helminths[!is.na(Helminths$Helminth_richness),]#to get rid of NAs in our variable response#
#Helminths = subset(Helminths, Helminths$Helminth_richness!="NA")#just another way#
##MCMCglmm handle missing values in the response variable(s), so this is not necessary. I just remove NAs when performing regressions...#
str(Helminths)#
#apply(apply(Helminths,2,is.na),2,sum)#checking NAs in individual variables separately#
Helminths$Latitude<-abs(Helminths$Latitude)#I converted negative latitude values into absolute ones as there is no, a priori, need to account for N or S hemisphere#
#
##Breakdown of numbers of taxa in each category included in the analyses#
#sumtab = aggregate(Helminths$Trematode_richness,list(Helminths$Habitat),length)#
#names(sumtab) = c("Habitat","TrRich")#
#sumtab$NemRich = aggregate(Helminths$Nematode_richness,list(Helminths$Habitat),length)[,2]#
#sumtab$CesRich = aggregate(Helminths$Cestode_richness,list(Helminths$Habitat),length)[,2]#
#sumtab$AcaRich = aggregate(Helminths$Acanthocephalan_richness,list(Helminths$Habitat),length)[,2]#
#sumtab$HelRich = aggregate(Helminths$Helminth_richness,list(Helminths$Habitat),length)[,2]#
#sumtab#but I first need to exlude NAs#
###Checking number of species and making a species list (for the tree)#
#Helminths_list<-levels(Helminths$animal)#checks number of species#
#Helminths_list#
#write.table(Helminths_list, "C:/Users/jsgutierrez/Dropbox/PGLMM/Helminths_list.txt", sep="\t")#exports species' list#
###Testing for correlation between parastite richness and sampling effort and extracting the residuals#
reg_H_rich <-lm(Helminths$Helminth_richness~Helminths$N, na.action=na.exclude)#I need to exclude NAs#
summary(reg_H_rich)#
par(cex=1)#
plot(Helminths$Helminth_richness~Helminths$N)#
abline(reg_H_rich)#
#
cor.test(Helminths$Helminth_richness, Helminths$N , method = "spearman") #
reg_H_rich2 <-lm(Helminth_richness ~ log(N), Helminths, na.action=na.exclude)#I need to exclude NAs#
plot(Helminth_richness~log(N),ylab="Overall helminth richness (# species)", Helminths, xlab="log sampling effort (# individuals examined)", pch=21, cex= 1.3, col="white", bg="black")##try to fit line#
abline(reg_H_rich2,col = "black", lty=2,lwd=1)#
#Fit quadratic term?#
#reg_H_rich2 <-plot(Helminth_richness ~ I(log(N)^2) + log(N), Helminths, na.action=na.exclude)#I need to exclude NAs#
H_rich_corr<-glm(Helminth_richness~log(N) ,family=quasipoisson(link=log), data=Helminths, na.action=na.exclude)#check for overdispersion first (if not overdispersed go for Poisson)#
summary(H_rich_corr)#
#plot(H_rich_corr)#diagnostic plots for model checking#
###Adding redisuals and fitted values to dataframe (subset)#
Helminths$Helminth_resid <- resid(H_rich_corr)#
Helminths$Helminth_fitt <- fitted(H_rich_corr)#
plot(Helminths$Helminth_resid~Helminths$Habitat,ylab="", xlab="", col=(c("azure1","azure2","azure3", "azure4","beige")))#
mtext(2, text = "Overall helminth richness", line = 3)#
mtext(2, text = "(corrected by sampling effort)", line = 2)#
#
#names(Helminths)#
#for(i in 1:16){#
  #plot(Helminths[,i],Helminths[,34],main = names(Helminths)[i])#
#}#juts to check possible relationships between responses and predictors#
#
###Checking the distribution of predictors#
#Mass#
plot(Helminth_resid~Mass, data=Helminths)#Mass is left skewed, so I will log-transform it.#
Helminths$Mass<-log(Helminths$Mass)#
plot(Helminth_resid~Mass, data=Helminths)#it looks better now.#
#
reg_Mass <-lm(Helminth_resid ~ log(Mass), data=Helminths, na.action=na.exclude)#I need to exclude NAs#
summary(reg_Mass)#
par(cex=1)#
plot(Helminth_resid~ log(Mass), ylab="", xlab="log body mass (g)",pch=21, cex= 1.3, col="white", bg="black",data=Helminths)#
mtext(2, text = "Overall helminth richness", line = 3)#
mtext(2, text = "(corrected by sampling effort)", line = 2)#
abline(reg_Mass,col = "black", lty=2,lwd=1)#
#Geographical range#
plot(Helminth_resid~Geographical_range, data=Helminths)#It looks ok so no transformation is needed.#
##Helminths$Geographical_range<-log(Helminths$Geographical_range)#
#plot(Helminth_resid~Geographical_range, data=Helminths)#
#
reg_Geo <-lm(Helminth_resid ~ Geographical_range, data=Helminths, na.action=na.exclude)#I need to exclude NAs#
summary(reg_Geo)#
par(cex=1)#
plot(Helminth_resid~Geographical_range, ylab="", xlab="Geographical range (Km2)",pch=21, cex= 1.3, col="white", bg="black",data=Helminths)#
mtext(2, text = "Overall helminth richness", line = 3)#
mtext(2, text = "(corrected by sampling effort)", line = 2)#
abline(reg_Geo,col = "black", lty=2,lwd=1)#
#plot(Helminth_resid~Global_population_size, data=Helminths)#
#Helminths$Global_population_size<-log(Helminths$Global_population_size)#
#plot(Helminth_resid~Global_population_size, data=Helminths)#
#scaling predictors#
Helminths$Mass<-scale(Helminths$Mass)#
Helminths$Latitude<-scale(Helminths$Latitude)#
Helminths$Geographical_range<-scale(Helminths$Geographical_range)#
Helminths$Migratory_distance<-scale(Helminths$Migratory_distance)#
#Helminths$Global_population_size<-scale(Helminths$Global_population_size)#I will exclude this predictors bacause the NAs (MCMCglmm does not deal with missing values in the predictors)#
#
###reading trees for helminth richness#
#trees =  read.nexus("H_tree.tre")#1000 trees, all 106 spp , see http://birdtree.org/ (Hackett all species)#
trees =  read.nexus("Helminths_100.tre")#100 trees, all 106 spp , see http://birdtree.org/ (Hackett all species) #
#trees =  read.nexus("H_richness100.tre")#100 trees, for 88 spp only (overall richness),  see http://birdtree.org/ (Hackett all species)#
#plot(trees[[1]])#
#plot(trees[[1]],cex = 0.2, no.margin = TRUE, label.offset = 0.5)#
#str(trees[[1]])#
#trees[[1]]$tip.label#to check names in the tree#
#Helminths$animal#to check names in the data set#
#####MCMCglmm:#
###Setting uninformative priors:#
#pri <- list(R = list(V = 1, nu = 1), G = list(G1 = list(V = 1, nu = 1)))#sets prior for 1 random effect#
pri2 <- list(R = list(V = 1, nu = 1), G = list(G1 = list(V = 1, nu = 1),G2 = list(V = 1, nu = 1)))#two random effects #
#priors from García-Peña et al. 2014 J. Evol. Biol.:#
#prior1<-list(R=list(V=diag(1),nu=0.002),G=list(G1=list(V=diag(1), nu=0.002)))#
#prior2<-list(R=list(V=matrix(c(1, 0.5, 0.5, 1), nrow=2, ncol=2), nu=0.002),#
             #G=list(G1=list(V=matrix(c(1, 0.5, 0.5, 1), nrow=2, ncol=2), nu=0.002)))#
###Using mulTree, which performs MCMCglmm on multiple phylogenetic trees (Healy et al. 2014)#
mulTree_H<-as.mulTree(Helminths, trees, species="animal", rand.term=~animal+StudyID)#
mulTree.parameters<-c(210001, 1000, 10000)#
#
#mulTree_H_mSAF <- mulTree (mulTree.data = mulTree_H, formula=Helminth_resid ~ Mass, parameters=mulTree.parameters, priors=pri2, output="simplest_model")#
#mulTree_H_mSAF2<-read.mulTree("simplest_model")#
#summary.mulTree(mulTree_H_mSAF2)#
mulTree_H_m2 <- mulTree (mulTree.data = mulTree_H, formula=Helminth_resid ~ Mass + Habitat + Latitude + Geographical_range + Migratory_distance, parameters=mulTree.parameters, priors=pri2, output="full_model_scaled")
CPU.hours("1-12:46:18")#
CPU.hours("1-12:46:18")#
CPU.hours("1-11:33:02")#
CPU.hours("0-18:14:05")#
CPU.hours("0-16:50:02")#
CPU.hours("0-05:42:04")#
CPU.hours("0-11:46:29")#
CPU.hours("0-20:42:27")#
CPU.hours("0-21:28:05")#
CPU.hours("0-11:26:10")#
CPU.hours("1-06:25:40")#
CPU.hours("0-17:03:04")#
CPU.hours("0-20:12:16")#
CPU.hours("1-09:17:17")#
CPU.hours("1-22:30:20")#
CPU.hours("0-11:36:22")#
CPU.hours("1-12:33:48")#
CPU.hours("1-02:11:41")#
CPU.hours("0-17:53:49")#
CPU.hours("0-14:36:33")#
CPU.hours("1-11:29:49")#
CPU.hours("")#
CPU.hours("0-08:53:52")#
CPU.hours("0-14:50:18")#
CPU.hours("0-07:03:18")#
CPU.hours("0-08:04:13")#
CPU.hours("0-12:21:29")#
CPU.hours("0-14:05:59")#
CPU.hours("0-21:29:58")#
CPU.hours("0-08:02:58")#
CPU.hours("0-09:21:54")#
CPU.hours("1-09:45:22")#
CPU.hours("1-14:37:45")#
CPU.hours("1-03:11:16")#
CPU.hours("0-17:28:10")#
CPU.hours("1-12:23:32")#
CPU.hours("0-21:03:12")#
CPU.hours("1-05:13:05")#
CPU.hours("0-11:05:30")#
CPU.hours("0-16:05:26")#
CPU.hours("0-11:44:43")#
CPU.hours("0-13:30:07")#
CPU.hours("0-15:33:56")#
CPU.hours("0-19:32:58")#
CPU.hours("0-13:26:48")#
CPU.hours("0-06:42:57")#
CPU.hours("1-14:26:10")#
CPU.hours("1-09:05:27")#
CPU.hours("1-11:24:27")#
CPU.hours("1-02:28:48")#
CPU.hours("1-13:16:27")#
CPU.hours("1-12:48:21")#
CPU.hours("1-06:42:15")#
CPU.hours("0-19:46:29")#
CPU.hours("0-10:31:23")#
CPU.hours("0-08:46:52")#
CPU.hours("0-13:51:00")#
CPU.hours("0-13:01:45")#
CPU.hours("1-02:02:55")#
CPU.hours("0-12:47:15")#
CPU.hours("1-00:55:52")#
CPU.hours("1-16:52:49")#
CPU.hours("1-16:59:46")#
CPU.hours("0-20:56:36")#
CPU.hours("0-23:14:03")#
CPU.hours("1-14:28:06")#
CPU.hours("1-03:02:10")#
CPU.hours("1-16:42:19")#
CPU.hours("0-20:11:51")#
CPU.hours("0-15:59:48")#
CPU.hours("0-10:19:19")#
CPU.hours("1-04:41:44")#
CPU.hours("0-23:44:29")#
CPU.hours("0-17:36:55")#
CPU.hours("0-07:16:05")#
CPU.hours("0-16:22:22")#
CPU.hours("1-02:59:53")#
CPU.hours("0-15:12:54")#
CPU.hours("0-15:04:23")#
CPU.hours("1-08:40:26")#
CPU.hours("0-08:40:33")#
CPU.hours("0-08:35:05")#
CPU.hours("0-09:37:24")#
CPU.hours("0-20:45:46")#
CPU.hours("1-03:51:51")#
CPU.hours("0-15:30:57")#
CPU.hours("1-05:37:47")#
CPU.hours("1-14:07:50")#
CPU.hours("1-00:07:49")#
CPU.hours("0-16:15:10")#
CPU.hours("0-05:58:25")#
CPU.hours("0-06:35:22")#
CPU.hours("0-11:00:50")#
CPU.hours("0-11:26:43")#
CPU.hours("0-10:09:28")#
CPU.hours("0-21:40:35")#
CPU.hours("1-14:14:32")#
CPU.hours("1-07:02:12")#
CPU.hours("1-09:17:36")#
CPU.hours("0-08:57:49")
CPU.hours("0-39-8-27")#
CPU.hours("0-37-54-22")#
CPU.hours("0-32-21-0")#
CPU.hours("0-15-27-14")#
CPU.hours("0-9-40-41")#
CPU.hours("0-6-53-44")#
CPU.hours("0-7-47-48")#
CPU.hours("0-13-14-14")#
CPU.hours("0-16-17-38")#
CPU.hours("0-12-30-10")#
CPU.hours("0-42-15-22")#
CPU.hours("0-17-30-14")#
CPU.hours("0-28-27-4")#
CPU.hours("0-47-4-21")#
CPU.hours("0-18-17-16")#
CPU.hours("0-36-53-23")#
CPU.hours("0-37-46-16")#
CPU.hours("0-15-13-12")#
CPU.hours("0-10-54-18")#
CPU.hours("0-36-1-56")#
CPU.hours("0-40-19-10")#
CPU.hours("0-16-10-37")#
CPU.hours("0-15-23-33")#
CPU.hours("0-8-12-57")#
CPU.hours("0-21-31-22")#
CPU.hours("0-24-39-32")#
CPU.hours("0-41-22-27")#
CPU.hours("0-22-23-54")#
CPU.hours("0-14-50-37")#
CPU.hours("0-8-33-24")#
CPU.hours("0-31-15-59")#
CPU.hours("0-37-44-51")#
CPU.hours("0-19-31-43")#
CPU.hours("0-10-26-2")#
CPU.hours("0-9-43-57")#
CPU.hours("0-38-39-31")#
CPU.hours("0-29-52-8")#
CPU.hours("0-20-0-5")#
CPU.hours("0-28-52-0")#
CPU.hours("0-10-26-41")#
CPU.hours("0-18-36-3")#
CPU.hours("0-10-42-39")#
CPU.hours("0-20-23-16")#
CPU.hours("0-13-30-20")#
CPU.hours("0-12-14-52")#
CPU.hours("0-13-49-57")#
CPU.hours("0-44-14-39")#
CPU.hours("0-18-27-1")#
CPU.hours("0-29-35-33")#
CPU.hours("0-21-47-3")#
CPU.hours("0-40-5-39")#
CPU.hours("0-26-7-1")#
CPU.hours("0-15-5-1")#
CPU.hours("0-13-42-8")#
CPU.hours("0-12-43-13")#
CPU.hours("0-34-49-44")#
CPU.hours("0-13-16-48")#
CPU.hours("0-24-36-38")#
CPU.hours("0-18-8-54")#
CPU.hours("0-40-57-0")#
CPU.hours("0-41-57-23")#
CPU.hours("0-34-0-38")#
CPU.hours("0-32-15-40")#
CPU.hours("0-25-51-44")#
CPU.hours("0-24-0-52")#
CPU.hours("0-10-35-9")#
CPU.hours("0-40-56-38")#
CPU.hours("0-7-29-1")#
CPU.hours("0-16-41-58")#
CPU.hours("0-12-45-7")#
CPU.hours("0-12-4-50")#
CPU.hours("0-39-26-26")#
CPU.hours("0-11-7-12")#
CPU.hours("0-11-45-50")#
CPU.hours("0-23-46-7")#
CPU.hours("0-36-40-45")#
CPU.hours("0-44-26-46")#
CPU.hours("0-14-28-51")#
CPU.hours("0-17-36-14")#
CPU.hours("0-10-43-25")#
CPU.hours("0-12-15-15")#
CPU.hours("0-22-39-10")#
CPU.hours("0-36-21-10")#
CPU.hours("0-15-1-0")#
CPU.hours("0-13-1-49")#
CPU.hours("0-24-48-57")#
CPU.hours("0-25-2-6")#
CPU.hours("0-18-26-46")#
CPU.hours("0-25-33-47")#
CPU.hours("0-4-30-50")#
CPU.hours("0-7-27-10")#
CPU.hours("0-11-9-32")#
CPU.hours("0-7-6-44")#
CPU.hours("0-14-42-52")#
CPU.hours("0-38-21-2")#
CPU.hours("0-37-32-11")#
CPU.hours("0-18-55-21")#
CPU.hours("0-26-3-55")#
CPU.hours("0-17-23-39")
``
CPU.hours("0-17-23-39")
CPU.hours("1-17-23-39")
CPU.hours("0-17-23-39")
library(devtools)#
install_github("TGuillerme/mulTree")#
library(mulTree)
?mulTree
?clean.data
##Create a set of different trees#
trees_list<-list(rtree(5, tip.label=LETTERS[1:5]), rtree(4, tip.label=LETTERS[1:4]), rtree(6, tip.label=LETTERS[1:6])) ; class(trees_list)<-"multiPhylo"#
##Creates a data frame#
dummy_data<-data.frame(taxon.list=LETTERS[1:5], var1=rnorm(5), var2=c(rep('a',2), rep('b',3)))#
##Name of column containing the taxon#
taxon_column<-"taxon.list"#
#
##Cleaning the trees and the data#
cleaned<-clean.data(taxon=taxon_column, data=dummy_data, tree=trees_list)#
##The taxa that where dropped:#
cleaned$dropped.taxon#
##The cleaned trees:#
cleaned$tree#
##The cleaned data set:#
cleaned$data
load("/Users/TGuillerme/Downloads/data_for_t.rda")
load("/Users/TGuillerme/Downloads/tree_for_t.rda")
test<-clean.data("animal", C.data_full, combined_trees)
test$table
library(disparity)#
#
##############################
# Data loading#
##############################
# This is just exactly your workshop script up until the distance matrix calculations (without the "install.packages")#
#
# Load the morphological matrix#
nexus.data <- ReadMorphNexus("http://www.graemetlloyd.com/nexus/Cullen_etal_2013a.nex")#
#
# Load the tree#
tree.data <- read.tree("http://www.graemetlloyd.com/firstmpt/Cullen_etal_2013a.tre")#
#
# Fix polytomies.#
tree.data <- multi2di(tree.data)#
#
# Read the age data#
ages.data <- read.table("http://www.graemetlloyd.com/teaching/RE2014/Cullenages.txt", row.names=1, sep="\t", header=T)#
#
# Building the tree#
tree.data <- timePaleoPhy(tree.data, ages.data, type="mbl", vartime=2)#
#
# Safe taxonomic reduction#
safe.data <- SafeTaxonomicReduction(nexus.data)#
#
##############################
# Distance matrix#
##############################
#
# Distance matrix#
dist.data <- MorphDistMatrix(nexus.data)#
#
# For small datasets this is instantly but I'm playing around with reasonably big ones (100 taxa * 400 characters) and some can take a day or so to compute.#
# To make sure the script is not frozen, I've just added a verbose function.#
# I clumsily renamed it MorphDistMatrix.verbose to avoid any confusion.#
#browseURL("https://github.com/TGuillerme/SpatioTemporal_Disparity/blob/master/Functions/disparity/R/MorphDistMatrix.verbose.R")#
#
# The function is exactly the same but can take an optional additional argument: verbose (TRUE (default) or FALSE)#
# With verbose = FALSE, the function is exactly the same#
dist.data.verbose <- MorphDistMatrix.verbose(nexus.data, verbose=FALSE)#
#
#The verbose option just adds some dots and some text (probably worth modifying but that's the general idea)#
dist.data.verbose <- MorphDistMatrix.verbose(nexus.data, verbose=TRUE)#
#
# Just for the sake of testing the differences#
for (different_distances in 1:length(dist.data)) {#
    print( all( (dist.data.verbose[[different_distances]] == dist.data[[different_distances]]), na.rm=TRUE) )#
}#
#
# Let's just continue through your workshop to get to the disparity part#
#
# Trim inapplicable data#
trimmed.max.data <-TrimMorphDistMatrix(dist.data$max.dist.matrix)#
#
# Remove the trimmed taxa from the tree for later#
tree.data<-drop.tip(tree.data, trimmed.max.data$removed.taxa)#
# Do the proper Multidimensional Scaling (corrected for negative eigenvalues)#
pco <- cmdscale(trimmed.max.data$dist.matrix, k=nrow(trimmed.max.data$dist.matrix) - 2, add=T, eig=TRUE)#
pco.data <- pco$points #generates k-2 eigenvectors (=n cladistic space dimensions)#
pco.eigen<- pco$eig #generates k eigenvalues (including two null eigenvalues)#
#
bins<-rev(seq(from=0, to=100, by=20))#
pco_in_bins<-int.pco(pco.data, tree.data, bins, FAD_LAD=ages.data, diversity=TRUE)#
##############################
# Testing significance#
############################# #
#
#Creating three different disparities#
#
disp_med.dist.cent.BS<-time.disparity(pco_in_bins$pco_intervals, method="centroid", relative=FALSE, verbose=TRUE, bootstraps=10, rarefaction=TRUE, centroid.type="median", central_tendency=mean, save.all=TRUE)#
disp_obs.dist.cent<-time.disparity(pco_in_bins$pco_intervals, method="centroid", relative=FALSE, verbose=TRUE, bootstraps=0,  rarefaction=FALSE, centroid.type="full", central_tendency=median, save.all=TRUE)#
disp_obs.dist.cent.BS<-time.disparity(pco_in_bins$pco_intervals, method="centroid", relative=FALSE, verbose=TRUE, bootstraps=10, rarefaction=TRUE, centroid.type="full", central_tendency=median, save.all=TRUE)#
#
#Extract disparity from the rarefaction analysis#
disp_med.dist.cent.BS_max<-extract.disp(disp_med.dist.cent.BS$quantiles, rarefaction="max")#
#
op<-par(mfrow=c(1,3))#
plot.disparity(extract.disp(disp_med.dist.cent.BS$quantiles, rarefaction="max"), ylim=c(0.8, 1.8))#
plot.disparity(disp_obs.dist.cent$quantiles, ylim=c(0.8, 1.8))#
plot.disparity(extract.disp(disp_obs.dist.cent.BS$quantiles, rarefaction="max"), ylim=c(0.8, 1.8))#
par(op)#
#ADONIS testing#
#
#Full cladisto-space#
pco_data<-pco$points #For code later: can be extracted from intervals (unique) #
pco_data<-pco$points[,1:3] #3D version (easier to calculate)#
intervals<-pco_in_bins$pco_intervals#
#
#Calculating the overall centroid distances#
centroid_overall<-apply(pco_data, 2, mean)#
#
#Calculating the centroids per interval#
#
centroids<-list()#
cent.dist<-list()#
#
for (int in 1:length(intervals)) {#
    #Isolating one interval#
    X<-pco_in_bins$pco_intervals[[int]][,1:3] #3D only!#
#
    #Calculating it's centroid#
    centroids[[int]]<-apply(X, 2, mean)#
    #Calculating all the distances from this centroid#
    Y<-NULL#
    for (j in 1:nrow(X)){#
        Y[j] <- dist(rbind(X[j,], centroids[[int]]), method="euclidean")#
    }#
    cent.dist[[int]]<-Y#
#
}#
#
#Calculating distances from time centroids to overall centroid#
cent_to_overall<-NULL#
cent_mat<-matrix(data=unlist(centroids), ncol=3, nrow=length(intervals), byrow=TRUE)#
for (j in 1:nrow(cent_mat)){#
    cent_to_overall[j] <- dist(rbind(cent_mat[j,], centroid_overall), method="euclidean")#
}#
#Visualizing the results in 3D#
library(scatterplot3d)#
#
for (int in 1:length(intervals)) {#
    #Plot each observation#
    s3d<-scatterplot3d(pco_data)#
    #Add the centroid#
    s3d$points3d(centroids[[int]][1],centroids[[int]][2],centroids[[int]][3], col="blue",pch=16)#
    #Add the distances within centroids#
    s3d$points3d(c(rbind(centroids[[int]][1],pco_in_bins$pco_intervals[[int]][,1])), c(rbind(centroids[[int]][2],pco_in_bins$pco_intervals[[int]][,2])), c(rbind(centroids[[int]][3],pco_in_bins$pco_intervals[[int]][,3])), type="l", lty=3, col="grey")#
    #Pause#
    Sys.sleep(1)#
}#
#
#Plot each observation#
s3d<-scatterplot3d(pco_data)#
#
#Add the centroid#
for (int in 1:length(intervals)) {#
    s3d$points3d(centroids[[int]][1],centroids[[int]][2],centroids[[int]][3], col="blue",pch=16)#
}#
#
#Add the overall centroid#
s3d$points3d(centroid_overall[1],centroid_overall[2],centroid_overall[3], col="red",pch=16)#
#Add the distances between centroids#
s3d$points3d(c(rbind(centroid_overall[1],cent_mat[,1])), c(rbind(centroid_overall[2],cent_mat[,2])), c(rbind(centroid_overall[3],cent_mat[,3])), type="l", lty=1, col="red")#
#Adding time category to each taxa#
mat<-matrix(data=0, nrow=nrow(pco_data), ncol=length(intervals))#
rownames(mat)<-rownames(pco_data)#
#colnames(mat)<-names(intervals)#
colnames(mat)<-c("A","B","C","D","E")#
for (int in 1:length(intervals)) {#
    mat[c(rownames(intervals[[int]])),int]<-1#
}#
mat<-as.data.frame(mat)#
#
mat_full<-mat#
for (column in 1:ncol(mat_full)) {#
    mat_full[,column]<-1 ; mat_full[sample(1:nrow(mat_full), sample(1:nrow(mat_full), 1)), column]<-0#
}#
#Permanova#
adonis(pco_data ~ A+B+C+D+E, data=mat, method='euclidean', permutations=1000)#
adonis(pco_data ~ A:B:C:D:E, data=mat, method='euclidean', permutations=1000)#
#
#Calculate the effect of different slices.#
#OK#
#
#Add a column for time#
mat$time<-NA#
for (row in 1:nrow(mat)) {#
    mat$time[row]<-paste(colnames(mat)[which(mat[row,]==1)], collapse="")#
}#
#
boxplot(pco$points ~ mat$time)#
#Permanova #
adonis(pco_data ~ time, data=mat, method='euclidean', permutations=1000)#
#
#Number of overlapping cases = n*(n+1)/2#
#
#Test with the distance matrix PROPER ONE#
dist.matrix<-trimmed.max.data$dist.matrix#
adonis(dist.matrix ~ time, data=mat, method='euclidean', permutations=1000)#
#
#Test with the full pco ON THE PCO DATA#
pco$points #
adonis(pco$points ~ time, data=mat, method='euclidean', permutations=1000)#
#
#Test with time as a strata#
adonis(pco$points ~ time, data=mat, strata=mat$time, method='euclidean', permutations=1000)#
#GLM#
counts <- c(18,17,15,20,10,20,25,13,12)#
outcome <- gl(3,1,9)#
print(d.AD <- data.frame(treatment, outcome))#
glm.D93 <- glm(counts ~ outcome , family = poisson())#
anova(glm.D93)#
summary(glm.D93)#
#
#treatments <- distances from centroids#
#outcome <- time#
#PROPER TESTING#
eucl_list<-disp_obs.dist.cent$values#
eucl_val<-unlist(eucl_list) ; names(eucl_val)<-NULL#
time_counts<-unlist(lapply(eucl_list, lapply, length))#
time<-as.factor(rep(names(eucl_list), time_counts))#
#
#Univariate (on the euclidean distance)#
bla<-aov(eucl_val~time)#
summary(bla)#
plot(TukeyHSD(bla))#
#
#Multivariate (on the pco)#
pco_mat<-rbind(intervals[[1]], intervals[[2]])#
for (int in 3:length(intervals)) {#
    pco_mat<-rbind(pco_mat, intervals[[int]])#
}#
nrow(pco_mat) == length(time)#
#
adonis(pco_mat~time, method='euclidean', permutations=1000)
bartlett.test(rnorm(1000))
bartlett.test(rnorm(1000)
)
bartlett.test
?bartlett.test
plot(count ~ spray, data = InsectSprays)
bartlett.test(InsectSprays$count, InsectSprays$spray)
bartlett.test(count ~ spray, data = InsectSprays)
data<-time_dis
time_dis<-disp_obs.dist.cent
data<-time_dis
if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }
type<-"Time"
check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }
check.class(time, "numeric")#
    check.length(time, 1, " must be a single numerical value.")#
    #check if time is present in the time_pco#
    #Setting the data type#
    if(data_type == "Multivariate") {#
        #Multivariate data#
        intervals<-names(data)#
    } else {#
        #Univariate data#
        intervals<-names(data[[2]])#
    }
time=60
check.class(time, "numeric")#
    check.length(time, 1, " must be a single numerical value.")#
    #check if time is present in the time_pco#
    #Setting the data type#
    if(data_type == "Multivariate") {#
        #Multivariate data#
        intervals<-names(data)#
    } else {#
        #Univariate data#
        intervals<-names(data[[2]])#
    }
if(type != "Time") {#
        #Time#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    }
type == "Time"
norm_test<-shapiro.test(univ_data[,1]~univ_data[,2])
#Testing if data is normal
plot(univ_data[,1]~univ_data[,2])
univ_data<-make.univariate.table(data)
#FUNCTIONS FOR DISPARITY.TEST#
#
#Making the univariate table (e.g. for aov)#
make.univariate.table<-function(time_disparity) {#
    #Extracting the list of values#
    list_val<-time_disparity$values#
#
    #Extracting the values#
    val_uni<-unlist(list_val)#
    #Removing the names#
    names(val_uni)<-NULL#
#
    #Extracting the time#
    time_counts<-unlist(lapply(list_val, lapply, length))#
    #Creating the time vector#
    time<-as.factor(rep(names(list_val), time_counts))#
#
    #Returning the results#
    output<-cbind(val_uni, as.factor(time))#
    output<-as.data.frame(output)#
    output[,2]<-as.factor(time)#
    names(output)<-c('Values', 'Time')#
    return(output)#
}#
#next: summary(aov(bla$Values~bla$Time))#
#Making the multivariate table (e.g. for adonis)#
make.multivariate.table<-function(time_pco) {#
    #Binding the first two elements#
    pco_mat<-rbind(time_pco[[1]], time_pco[[2]])#
#
    #Binding the other elements#
    if(length(time_pco) > 2) {#
        for (interval in 3:length(time_pco)) {#
            pco_mat<-rbind(pco_mat, time_pco[[interval]])#
        }#
    }#
    #Extracting the time#
    time_counts<-unlist(lapply(time_pco, nrow))#
    #Creating the time vector#
    time<-as.factor(rep(names(time_pco), time_counts))#
#
    #Returning the table#
    output<-list(pco_mat, time)#
    names(output)<-c("Data", "Time")#
    return(output)#
}#
#next: adonis(bla~bla, method='euclidean', permutations=1000)
plot(univ_data[,1]~univ_data[,2])
univ_data<-make.univariate.table(data)
plot(univ_data[,1]~univ_data[,2])
shapiro.test(univ_data[,1]~univ_data[,2])
norm_test<-shapiro.test(univ_data[,1])
eruption.lm = lm(eruptions ~ waiting, data=faithful)
eruption.ln
eruption.lm
?rstandard
eruption.stdres = rstandard(eruption.lm)
eruption.stdres
shapiro.test(eruption.stdres)
qqline(eruption.stdres)
eruption.lm = lm(eruptions ~ waiting, data=faithful) #
 eruption.stdres = rstandard(eruption.lm)
qqnorm(eruption.stdres)#
  qqline(eruption.stdres)
anova<-aov(univ_data[,1]~univ_data[,2])
anova
rstandard(        anova)
shapiro.tests(rstandard(anova))
shapiro.test(rstandard(anova))
qqnorm(rstandard(anova))
qqline(rstandard(anova))
bartlett.test(anova)
bartlett.test(univ_data[,1]~univ_data[,2])
? bartlett.test
names(normal_res)
#anova#
            anova<-aov(univ_data[,1]~univ_data[,2])#
#
            #residuals#
            normal_res<-shapiro.test(rstandard(anova))#
#
            #variance#
            var_test<-bartlett.test(univ_data[,1]~univ_data[,2])
data<-univ_data
names(normal_res)
normal_res$p.value < 0.05
normal_res$p.value > 0.05 & var_test$p.value > 0.05
normal_res
var_test
names(normal_res)
var_test$method
var_test$statistic
var_test$data.name
var_test$method
var_test$statistic[[1]]
var_test$statistic[[2]]
var_test$statistic[2]
var_test$statistic[1]
var_test$statistic[4]
var_test$statistic
?bartlett.test
var_test$parameter
normal_res$statistic
data.frame(test=c("Shapiro","Bartlett"), statistic=c(normal_res$statistic[[1]], var_test$statistic[[1]]), df=c(NA, var_test$parameter[[1]]), p.value=c(normal_res$p.value[[1]], var_test$p.value[[1]]))
data.frame(rownames=c("Shapiro","Bartlett"), statistic=c(normal_res$statistic[[1]], var_test$statistic[[1]]), df=c(NA, var_test$parameter[[1]]), p.value=c(normal_res$p.value[[1]], var_test$p.value[[1]]))
data.frame(row.names=c("Shapiro","Bartlett"), statistic=c(normal_res$statistic[[1]], var_test$statistic[[1]]), df=c(NA, var_test$parameter[[1]]), p.value=c(normal_res$p.value[[1]], var_test$p.value[[1]]))
#Testing assumptions of anova#
test.anova<-function(data) {#
    #anova#
    anova<-aov(data[,1]~data[,2])#
#
    #residuals#
    normal_res<-shapiro.test(rstandard(anova))#
#
    #variance#
    var_test<-bartlett.test(data[,1]~data[,2])#
#
    #Test#
    if(normal_res$p.value > 0.05 & var_test$p.value > 0.05) {#
        test_results<-TRUE#
    } else {#
        test_results<-FALSE#
    }#
#
    #Saving the test table#
    test.save<-data.frame(row.names=c("Shapiro","Bartlett"), statistic=c(normal_res$statistic[[1]], var_test$statistic[[1]]), df=c(NA, var_test$parameter[[1]]), p.value=c(normal_res$p.value[[1]], var_test$p.value[[1]]))#
#
    #output#
    output<-list("Pass"=test_results, "Test"=test.save)#
    return(output)#
}
test.anova(univ_data)
test.anova(univ_data)[[1]]
test.anova(univ_data)[[1]][[1]]
test<-test.anova(univ_data)
test[[1]] == TRUE
names(univ_data)
message("Tested input values ~ input time using ANOVA.")#
            message("Residuals are normally distributed and variance within groups is homogeneous.")#
            message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")
?kw.test
apropos(kruskall)
apropos("kruskal")
kruskal.test(univ_data[,1]~univ_data[,2])
summary(aov(univ_data[,1]~univ_data[,2]))
kruskal.test(univ_data[,1]~univ_data[,2])
message("Tested input values ~ input time using ANOVA.")#
                message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")
adonis(univ_data[,1]~univ_data[,2], method="euclidean")
adonis(univ_data[,1]~univ_data[,2], method="euclidean", permutations)
adonis(univ_data[,1]~univ_data[,2], method="euclidean", permutations=1000)
univ_test
data<-time_pco
time_pco<-intervals
data<-time_pco
message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }
data_type
data
library(disparity)#
#
##############################
# Data loading#
##############################
# This is just exactly your workshop script up until the distance matrix calculations (without the "install.packages")#
#
# Load the morphological matrix#
nexus.data <- ReadMorphNexus("http://www.graemetlloyd.com/nexus/Cullen_etal_2013a.nex")#
#
# Load the tree#
tree.data <- read.tree("http://www.graemetlloyd.com/firstmpt/Cullen_etal_2013a.tre")#
#
# Fix polytomies.#
tree.data <- multi2di(tree.data)#
#
# Read the age data#
ages.data <- read.table("http://www.graemetlloyd.com/teaching/RE2014/Cullenages.txt", row.names=1, sep="\t", header=T)#
#
# Building the tree#
tree.data <- timePaleoPhy(tree.data, ages.data, type="mbl", vartime=2)#
#
# Safe taxonomic reduction#
safe.data <- SafeTaxonomicReduction(nexus.data)#
#
##############################
# Distance matrix#
##############################
#
# Distance matrix#
dist.data <- MorphDistMatrix(nexus.data)#
#
# For small datasets this is instantly but I'm playing around with reasonably big ones (100 taxa * 400 characters) and some can take a day or so to compute.#
# To make sure the script is not frozen, I've just added a verbose function.#
# I clumsily renamed it MorphDistMatrix.verbose to avoid any confusion.#
#browseURL("https://github.com/TGuillerme/SpatioTemporal_Disparity/blob/master/Functions/disparity/R/MorphDistMatrix.verbose.R")#
#
# The function is exactly the same but can take an optional additional argument: verbose (TRUE (default) or FALSE)#
# With verbose = FALSE, the function is exactly the same#
dist.data.verbose <- MorphDistMatrix.verbose(nexus.data, verbose=FALSE)#
#
#The verbose option just adds some dots and some text (probably worth modifying but that's the general idea)#
dist.data.verbose <- MorphDistMatrix.verbose(nexus.data, verbose=TRUE)#
#
# Just for the sake of testing the differences#
for (different_distances in 1:length(dist.data)) {#
    print( all( (dist.data.verbose[[different_distances]] == dist.data[[different_distances]]), na.rm=TRUE) )#
}#
#
# Let's just continue through your workshop to get to the disparity part#
#
# Trim inapplicable data#
trimmed.max.data <-TrimMorphDistMatrix(dist.data$max.dist.matrix)#
#
# Remove the trimmed taxa from the tree for later#
tree.data<-drop.tip(tree.data, trimmed.max.data$removed.taxa)#
# Do the proper Multidimensional Scaling (corrected for negative eigenvalues)#
pco <- cmdscale(trimmed.max.data$dist.matrix, k=nrow(trimmed.max.data$dist.matrix) - 2, add=T, eig=TRUE)#
pco.data <- pco$points #generates k-2 eigenvectors (=n cladistic space dimensions)#
pco.eigen<- pco$eig #generates k eigenvalues (including two null eigenvalues)#
#
bins<-rev(seq(from=0, to=100, by=20))#
pco_in_bins<-int.pco(pco.data, tree.data, bins, FAD_LAD=ages.data, diversity=TRUE)#
##############################
# Testing significance#
############################# #
#
#Creating three different disparities#
#
disp_med.dist.cent.BS<-time.disparity(pco_in_bins$pco_intervals, method="centroid", relative=FALSE, verbose=TRUE, bootstraps=10, rarefaction=TRUE, centroid.type="median", central_tendency=mean, save.all=TRUE)#
disp_obs.dist.cent<-time.disparity(pco_in_bins$pco_intervals, method="centroid", relative=FALSE, verbose=TRUE, bootstraps=0,  rarefaction=FALSE, centroid.type="full", central_tendency=median, save.all=TRUE)#
disp_obs.dist.cent.BS<-time.disparity(pco_in_bins$pco_intervals, method="centroid", relative=FALSE, verbose=TRUE, bootstraps=10, rarefaction=TRUE, centroid.type="full", central_tendency=median, save.all=TRUE)#
#
#Extract disparity from the rarefaction analysis#
disp_med.dist.cent.BS_max<-extract.disp(disp_med.dist.cent.BS$quantiles, rarefaction="max")#
#
op<-par(mfrow=c(1,3))#
plot.disparity(extract.disp(disp_med.dist.cent.BS$quantiles, rarefaction="max"), ylim=c(0.8, 1.8))#
plot.disparity(disp_obs.dist.cent$quantiles, ylim=c(0.8, 1.8))#
plot.disparity(extract.disp(disp_obs.dist.cent.BS$quantiles, rarefaction="max"), ylim=c(0.8, 1.8))#
par(op)#
#ADONIS testing#
#
#Full cladisto-space#
pco_data<-pco$points #For code later: can be extracted from intervals (unique) #
pco_data<-pco$points[,1:3] #3D version (easier to calculate)#
intervals<-pco_in_bins$pco_intervals#
#
#Calculating the overall centroid distances#
centroid_overall<-apply(pco_data, 2, mean)#
#
#Calculating the centroids per interval#
#
centroids<-list()#
cent.dist<-list()#
#
for (int in 1:length(intervals)) {#
    #Isolating one interval#
    X<-pco_in_bins$pco_intervals[[int]][,1:3] #3D only!#
#
    #Calculating it's centroid#
    centroids[[int]]<-apply(X, 2, mean)#
    #Calculating all the distances from this centroid#
    Y<-NULL#
    for (j in 1:nrow(X)){#
        Y[j] <- dist(rbind(X[j,], centroids[[int]]), method="euclidean")#
    }#
    cent.dist[[int]]<-Y#
#
}#
#
#Calculating distances from time centroids to overall centroid#
cent_to_overall<-NULL#
cent_mat<-matrix(data=unlist(centroids), ncol=3, nrow=length(intervals), byrow=TRUE)#
for (j in 1:nrow(cent_mat)){#
    cent_to_overall[j] <- dist(rbind(cent_mat[j,], centroid_overall), method="euclidean")#
}#
#Visualizing the results in 3D#
library(scatterplot3d)#
#
for (int in 1:length(intervals)) {#
    #Plot each observation#
    s3d<-scatterplot3d(pco_data)#
    #Add the centroid#
    s3d$points3d(centroids[[int]][1],centroids[[int]][2],centroids[[int]][3], col="blue",pch=16)#
    #Add the distances within centroids#
    s3d$points3d(c(rbind(centroids[[int]][1],pco_in_bins$pco_intervals[[int]][,1])), c(rbind(centroids[[int]][2],pco_in_bins$pco_intervals[[int]][,2])), c(rbind(centroids[[int]][3],pco_in_bins$pco_intervals[[int]][,3])), type="l", lty=3, col="grey")#
    #Pause#
    Sys.sleep(1)#
}#
#
#Plot each observation#
s3d<-scatterplot3d(pco_data)#
#
#Add the centroid#
for (int in 1:length(intervals)) {#
    s3d$points3d(centroids[[int]][1],centroids[[int]][2],centroids[[int]][3], col="blue",pch=16)#
}#
#
#Add the overall centroid#
s3d$points3d(centroid_overall[1],centroid_overall[2],centroid_overall[3], col="red",pch=16)#
#Add the distances between centroids#
s3d$points3d(c(rbind(centroid_overall[1],cent_mat[,1])), c(rbind(centroid_overall[2],cent_mat[,2])), c(rbind(centroid_overall[3],cent_mat[,3])), type="l", lty=1, col="red")#
#Adding time category to each taxa#
mat<-matrix(data=0, nrow=nrow(pco_data), ncol=length(intervals))#
rownames(mat)<-rownames(pco_data)#
#colnames(mat)<-names(intervals)#
colnames(mat)<-c("A","B","C","D","E")#
for (int in 1:length(intervals)) {#
    mat[c(rownames(intervals[[int]])),int]<-1#
}#
mat<-as.data.frame(mat)#
#
mat_full<-mat#
for (column in 1:ncol(mat_full)) {#
    mat_full[,column]<-1 ; mat_full[sample(1:nrow(mat_full), sample(1:nrow(mat_full), 1)), column]<-0#
}#
#Permanova#
adonis(pco_data ~ A+B+C+D+E, data=mat, method='euclidean', permutations=1000)#
adonis(pco_data ~ A:B:C:D:E, data=mat, method='euclidean', permutations=1000)#
#
#Calculate the effect of different slices.#
#OK#
#
#Add a column for time#
mat$time<-NA#
for (row in 1:nrow(mat)) {#
    mat$time[row]<-paste(colnames(mat)[which(mat[row,]==1)], collapse="")#
}#
#
boxplot(pco$points ~ mat$time)#
#Permanova #
adonis(pco_data ~ time, data=mat, method='euclidean', permutations=1000)#
#
#Number of overlapping cases = n*(n+1)/2#
#
#Test with the distance matrix PROPER ONE#
dist.matrix<-trimmed.max.data$dist.matrix#
adonis(dist.matrix ~ time, data=mat, method='euclidean', permutations=1000)#
#
#Test with the full pco ON THE PCO DATA#
pco$points #
adonis(pco$points ~ time, data=mat, method='euclidean', permutations=1000)#
#
#Test with time as a strata#
adonis(pco$points ~ time, data=mat, strata=mat$time, method='euclidean', permutations=1000)#
#GLM#
counts <- c(18,17,15,20,10,20,25,13,12)#
outcome <- gl(3,1,9)#
print(d.AD <- data.frame(treatment, outcome))#
glm.D93 <- glm(counts ~ outcome , family = poisson())#
anova(glm.D93)#
summary(glm.D93)#
#
#treatments <- distances from centroids#
#outcome <- time#
#PROPER TESTING#
eucl_list<-disp_obs.dist.cent$values#
eucl_val<-unlist(eucl_list) ; names(eucl_val)<-NULL#
time_counts<-unlist(lapply(eucl_list, lapply, length))#
time<-as.factor(rep(names(eucl_list), time_counts))#
#
#Univariate (on the euclidean distance)#
bla<-aov(eucl_val~time)#
summary(bla)#
plot(TukeyHSD(bla))#
#
#Multivariate (on the pco)#
pco_mat<-rbind(intervals[[1]], intervals[[2]])#
for (int in 3:length(intervals)) {#
    pco_mat<-rbind(pco_mat, intervals[[int]])#
}#
nrow(pco_mat) == length(time)#
#
adonis(pco_mat~time, method='euclidean', permutations=1000)
intervals
time_pco<-intervals
data<-time_pco
if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }
data_type
multi_data<-make.multivariate.table(data)
multi_data
method="euclidean"
permutations=1000
adonis(multi_data[[1]]~multi_data[[2]], method=method, permutations=permutations)
multi_test<-adonis(multi_data[[1]]~multi_data[[2]], method=method, permutations=permutations)
multi_test
names(            multi_test)
multi_test$aov.tab
multi_test$coefficients
multi_test$coef.sites
multi_test$model.matrix
multi_test$terms
data.values<-multi_data[[1]]#
            time<-multi_data[[2]]
multi_test<-adonis(data.values~time, method=method, permutations=permutations)
multi_test
univ_data
message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations."))
message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations."), sep="")
message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))
disparity.test<-function(data, type, time, force.test=NULL, method=NULL, permutations=NULL, ...) {#
#
    #SANITIZING#
    message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }#
    #type#
    check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }#
    #TIME CAN ALSO BE A STRATA#
    #time (only in type = Age or Lag)#
    check.class(time, "numeric")#
    check.length(time, 1, " must be a single numerical value.")#
    #check if time is present in the time_pco#
    #Setting the data type#
    if(data_type == "Multivariate") {#
        #Multivariate data#
        intervals<-names(data)#
    } else {#
        #Univariate data#
        intervals<-names(data[[2]])#
    }#
#
    if(type != "Time") {#
        #Time#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    } #
#
    #force.test#
    if(!is.null(force.test)) {#
        check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }     #
    }#
#
    #setting the test type to null (default)#
#
    #method#
    if(is.null(method)) {#
        method="euclidean"#
    } else {#
        check.class(method, "character")#
        test_type<-"Multivariate"#
        message("'method' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #method#
    if(is.null(permutations)) {#
        permutations=1000#
    } else {#
        check.class(permutations, "numeric")#
        test_type<-"Multivariate"#
        message("'permutations' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #TEST DIFFERENCES IN DISPARITY#
#
    #TIME: testing the effect of time on data#
    if(type == "Time") {#
#
        if(data_type == "Univariate") {#
            #Univariate analysis (Kruskall Wallis or ANOVA)#
            univ_data<-make.univariate.table(data)#
            data.values<-unvi_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)#
#
            #Running the univariate test#
            if(test[[1]] == TRUE) {#
                if(force.test == "non-parametric") {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                } else {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA.")#
                    message("Residuals are normally distributed and variance within groups is homogeneous.")#
                    message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")#
                }#
            } else {#
                if(force.test == "parametric") {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA (parametric test was enforced using 'force.test=\"parametric\"' options).")#
                    message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")                #
                } else {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                }#
#
            }#
#
            #Do test output#
        }#
#
        if(is.null(test_type) & data_type == "Multivariate") {#
            test_type<-"Multivariate"#
        }#
#
        if(test_type == "Multivariate") {#
            #Is the data univariate?#
            if(data_type == "Univariate") {#
                multi_data<-make.univariate.table(data)#
                data.values<-unvi_data[,1]#
                time<-univ_data[,2]#
                message("Multivariate test is performed on univariate data. Remove the multivariate options to enforce univariate test.")#
            } else {#
                multi_data<-make.multivariate.table(data)#
                data.values<-multi_data[[1]]#
                time<-multi_data[[2]]#
            }#
#
            #Running PERMANOVA#
            multi_test<-adonis(data.values~time, method=method, permutations=permutations)#
            message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))#
#
        }#
#
        #Output#
        if(test_type == "Multivariate") {#
            return(multi_test)#
        } else {#
            return(univ_test)#
        }#
#
    }#
#
}
disparity.test(time_pco, "time")
disparity.test(time_pco, "Time")
disparity.test<-function(data, type, time=NULL, force.test=NULL, method=NULL, permutations=NULL, ...) {#
#
    #SANITIZING#
    message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }#
    #type#
    check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }#
    #TIME CAN ALSO BE A STRATA#
    #time (only in type = Age or Lag)#
    check.class(time, "numeric")#
    check.length(time, 1, " must be a single numerical value.")#
    #check if time is present in the time_pco#
    #Setting the data type#
    if(data_type == "Multivariate") {#
        #Multivariate data#
        intervals<-names(data)#
    } else {#
        #Univariate data#
        intervals<-names(data[[2]])#
    }#
#
    if(type != "Time") {#
        #Time#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    } #
#
    #force.test#
    if(!is.null(force.test)) {#
        check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }     #
    }#
#
    #setting the test type to null (default)#
#
    #method#
    if(is.null(method)) {#
        method="euclidean"#
    } else {#
        check.class(method, "character")#
        test_type<-"Multivariate"#
        message("'method' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #method#
    if(is.null(permutations)) {#
        permutations=1000#
    } else {#
        check.class(permutations, "numeric")#
        test_type<-"Multivariate"#
        message("'permutations' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #TEST DIFFERENCES IN DISPARITY#
#
    #TIME: testing the effect of time on data#
    if(type == "Time") {#
#
        if(data_type == "Univariate") {#
            #Univariate analysis (Kruskall Wallis or ANOVA)#
            univ_data<-make.univariate.table(data)#
            data.values<-unvi_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)#
#
            #Running the univariate test#
            if(test[[1]] == TRUE) {#
                if(force.test == "non-parametric") {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                } else {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA.")#
                    message("Residuals are normally distributed and variance within groups is homogeneous.")#
                    message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")#
                }#
            } else {#
                if(force.test == "parametric") {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA (parametric test was enforced using 'force.test=\"parametric\"' options).")#
                    message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")                #
                } else {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                }#
#
            }#
#
            #Do test output#
        }#
#
        if(is.null(test_type) & data_type == "Multivariate") {#
            test_type<-"Multivariate"#
        }#
#
        if(test_type == "Multivariate") {#
            #Is the data univariate?#
            if(data_type == "Univariate") {#
                multi_data<-make.univariate.table(data)#
                data.values<-unvi_data[,1]#
                time<-univ_data[,2]#
                message("Multivariate test is performed on univariate data. Remove the multivariate options to enforce univariate test.")#
            } else {#
                multi_data<-make.multivariate.table(data)#
                data.values<-multi_data[[1]]#
                time<-multi_data[[2]]#
            }#
#
            #Running PERMANOVA#
            multi_test<-adonis(data.values~time, method=method, permutations=permutations)#
            message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))#
#
        }#
#
        #Output#
        if(test_type == "Multivariate") {#
            return(multi_test)#
        } else {#
            return(univ_test)#
        }#
#
    }#
#
}
disparity.test(time_pco, "Time")
disparity.test<-function(data, type, time=NULL, force.test=NULL, method=NULL, permutations=NULL, ...) {#
#
    #SANITIZING#
    message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }#
    #type#
    check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }#
    if(type != "Time") {#
        #Time#
        #TIME CAN ALSO BE A STRATA#
        #time (only in type = Age or Lag)#
        check.class(time, "numeric")#
        check.length(time, 1, " must be a single numerical value.")#
        #check if time is present in the time_pco#
        #Setting the data type#
        if(data_type == "Multivariate") {#
            #Multivariate data#
            intervals<-names(data)#
        } else {#
            #Univariate data#
            intervals<-names(data[[2]])#
        }#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    } #
#
    #force.test#
    if(!is.null(force.test)) {#
        check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }     #
    }#
#
    #setting the test type to null (default)#
#
    #method#
    if(is.null(method)) {#
        method="euclidean"#
    } else {#
        check.class(method, "character")#
        test_type<-"Multivariate"#
        message("'method' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #method#
    if(is.null(permutations)) {#
        permutations=1000#
    } else {#
        check.class(permutations, "numeric")#
        test_type<-"Multivariate"#
        message("'permutations' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #TEST DIFFERENCES IN DISPARITY#
#
    #TIME: testing the effect of time on data#
    if(type == "Time") {#
#
        if(data_type == "Univariate") {#
            #Univariate analysis (Kruskall Wallis or ANOVA)#
            univ_data<-make.univariate.table(data)#
            data.values<-unvi_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)#
#
            #Running the univariate test#
            if(test[[1]] == TRUE) {#
                if(force.test == "non-parametric") {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                } else {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA.")#
                    message("Residuals are normally distributed and variance within groups is homogeneous.")#
                    message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")#
                }#
            } else {#
                if(force.test == "parametric") {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA (parametric test was enforced using 'force.test=\"parametric\"' options).")#
                    message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")                #
                } else {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                }#
#
            }#
#
            #Do test output#
        }#
#
        if(is.null(test_type) & data_type == "Multivariate") {#
            test_type<-"Multivariate"#
        }#
#
        if(test_type == "Multivariate") {#
            #Is the data univariate?#
            if(data_type == "Univariate") {#
                multi_data<-make.univariate.table(data)#
                data.values<-unvi_data[,1]#
                time<-univ_data[,2]#
                message("Multivariate test is performed on univariate data. Remove the multivariate options to enforce univariate test.")#
            } else {#
                multi_data<-make.multivariate.table(data)#
                data.values<-multi_data[[1]]#
                time<-multi_data[[2]]#
            }#
#
            #Running PERMANOVA#
            multi_test<-adonis(data.values~time, method=method, permutations=permutations)#
            message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))#
#
        }#
#
        #Output#
        if(test_type == "Multivariate") {#
            return(multi_test)#
        } else {#
            return(univ_test)#
        }#
#
    }#
#
}
disparity.test(time_pco, "Time")
disparity.test<-function(data, type, time=NULL, force.test=NULL, method=NULL, permutations=NULL, test.type=NULL, ...) {#
#
    #SANITIZING#
    message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }#
    #type#
    check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }#
    if(type != "Time") {#
        #Time#
        #TIME CAN ALSO BE A STRATA#
        #time (only in type = Age or Lag)#
        check.class(time, "numeric")#
        check.length(time, 1, " must be a single numerical value.")#
        #check if time is present in the time_pco#
        #Setting the data type#
        if(data_type == "Multivariate") {#
            #Multivariate data#
            intervals<-names(data)#
        } else {#
            #Univariate data#
            intervals<-names(data[[2]])#
        }#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    } #
#
    #force.test#
    if(!is.null(force.test)) {#
        check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }     #
    }#
#
    #setting the test type to null (default)#
#
    #method#
    if(is.null(method)) {#
        method="euclidean"#
    } else {#
        check.class(method, "character")#
        test_type<-"Multivariate"#
        message("'method' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #method#
    if(is.null(permutations)) {#
        permutations=1000#
    } else {#
        check.class(permutations, "numeric")#
        test_type<-"Multivariate"#
        message("'permutations' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #TEST DIFFERENCES IN DISPARITY#
#
    #TIME: testing the effect of time on data#
    if(type == "Time") {#
#
        if(data_type == "Univariate") {#
            #Univariate analysis (Kruskall Wallis or ANOVA)#
            univ_data<-make.univariate.table(data)#
            data.values<-unvi_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)#
#
            #Running the univariate test#
            if(test[[1]] == TRUE) {#
                if(force.test == "non-parametric") {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                } else {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA.")#
                    message("Residuals are normally distributed and variance within groups is homogeneous.")#
                    message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")#
                }#
            } else {#
                if(force.test == "parametric") {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA (parametric test was enforced using 'force.test=\"parametric\"' options).")#
                    message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")                #
                } else {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                }#
#
            }#
#
            #Do test output#
        }#
#
        if(is.null(test_type) & data_type == "Multivariate") {#
            test_type<-"Multivariate"#
        }#
#
        if(test_type == "Multivariate") {#
            #Is the data univariate?#
            if(data_type == "Univariate") {#
                multi_data<-make.univariate.table(data)#
                data.values<-unvi_data[,1]#
                time<-univ_data[,2]#
                message("Multivariate test is performed on univariate data. Remove the multivariate options to enforce univariate test.")#
            } else {#
                multi_data<-make.multivariate.table(data)#
                data.values<-multi_data[[1]]#
                time<-multi_data[[2]]#
            }#
#
            #Running PERMANOVA#
            multi_test<-adonis(data.values~time, method=method, permutations=permutations)#
            message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))#
#
        }#
#
        #Output#
        if(test_type == "Multivariate") {#
            return(multi_test)#
        } else {#
            return(univ_test)#
        }#
#
    }#
#
}
disparity.test(time_pco, "Time")
disparity.test<-function(data, type, time=NULL, force.test=NULL, method=NULL, permutations=NULL, ...) {#
#
    #SANITIZING#
    message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }#
    #type#
    check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }#
    if(type != "Time") {#
        #Time#
        #TIME CAN ALSO BE A STRATA#
        #time (only in type = Age or Lag)#
        check.class(time, "numeric")#
        check.length(time, 1, " must be a single numerical value.")#
        #check if time is present in the time_pco#
        #Setting the data type#
        if(data_type == "Multivariate") {#
            #Multivariate data#
            intervals<-names(data)#
        } else {#
            #Univariate data#
            intervals<-names(data[[2]])#
        }#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    } #
#
    #force.test#
    if(!is.null(force.test)) {#
        check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }     #
    }#
#
    #setting the test type to null (default)#
    test_type=NULL#
#
    #method#
    if(is.null(method)) {#
        method="euclidean"#
    } else {#
        check.class(method, "character")#
        test_type<-"Multivariate"#
        message("'method' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #method#
    if(is.null(permutations)) {#
        permutations=1000#
    } else {#
        check.class(permutations, "numeric")#
        test_type<-"Multivariate"#
        message("'permutations' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #TEST DIFFERENCES IN DISPARITY#
#
    #TIME: testing the effect of time on data#
    if(type == "Time") {#
#
        if(data_type == "Univariate") {#
            #Univariate analysis (Kruskall Wallis or ANOVA)#
            univ_data<-make.univariate.table(data)#
            data.values<-unvi_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)#
#
            #Running the univariate test#
            if(test[[1]] == TRUE) {#
                if(force.test == "non-parametric") {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                } else {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA.")#
                    message("Residuals are normally distributed and variance within groups is homogeneous.")#
                    message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")#
                }#
            } else {#
                if(force.test == "parametric") {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA (parametric test was enforced using 'force.test=\"parametric\"' options).")#
                    message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")                #
                } else {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                }#
#
            }#
#
            #Do test output#
        }#
#
        if(is.null(test_type) & data_type == "Multivariate") {#
            test_type<-"Multivariate"#
        }#
#
        if(test_type == "Multivariate") {#
            #Is the data univariate?#
            if(data_type == "Univariate") {#
                multi_data<-make.univariate.table(data)#
                data.values<-unvi_data[,1]#
                time<-univ_data[,2]#
                message("Multivariate test is performed on univariate data. Remove the multivariate options to enforce univariate test.")#
            } else {#
                multi_data<-make.multivariate.table(data)#
                data.values<-multi_data[[1]]#
                time<-multi_data[[2]]#
            }#
#
            #Running PERMANOVA#
            multi_test<-adonis(data.values~time, method=method, permutations=permutations)#
            message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))#
#
        }#
#
        #Output#
        if(test_type == "Multivariate") {#
            return(multi_test)#
        } else {#
            return(univ_test)#
        }#
#
    }#
#
}
disparity.test(time_pco, "Time")
disparity.test(time_dis, "Time")
setwd("/Users/TGuillerme/PhD/Projects/SpatioTemporal_Disparity/Functions/disparity/R")
disparity.test<-function(data, type, time=NULL, force.test=NULL, method=NULL, permutations=NULL, ...) {#
#
    #SANITIZING#
    message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }#
    #type#
    check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }#
    if(type != "Time") {#
        #Time#
        #TIME CAN ALSO BE A STRATA#
        #time (only in type = Age or Lag)#
        check.class(time, "numeric")#
        check.length(time, 1, " must be a single numerical value.")#
        #check if time is present in the time_pco#
        #Setting the data type#
        if(data_type == "Multivariate") {#
            #Multivariate data#
            intervals<-names(data)#
        } else {#
            #Univariate data#
            intervals<-names(data[[2]])#
        }#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    } #
#
    #force.test#
    if(!is.null(force.test)) {#
        check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }     #
    }#
#
    #setting the test type to null (default)#
    test_type=NULL#
#
    #method#
    if(is.null(method)) {#
        method="euclidean"#
    } else {#
        check.class(method, "character")#
        test_type<-"Multivariate"#
        message("'method' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #method#
    if(is.null(permutations)) {#
        permutations=1000#
    } else {#
        check.class(permutations, "numeric")#
        test_type<-"Multivariate"#
        message("'permutations' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #TEST DIFFERENCES IN DISPARITY#
#
    #TIME: testing the effect of time on data#
    if(type == "Time") {#
#
        if(data_type == "Univariate") {#
            #Univariate analysis (Kruskall Wallis or ANOVA)#
            univ_data<-make.univariate.table(data)#
            data.values<-univ_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)#
#
            #Running the univariate test#
            if(test[[1]] == TRUE) {#
                if(force.test == "non-parametric") {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                } else {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA.")#
                    message("Residuals are normally distributed and variance within groups is homogeneous.")#
                    message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")#
                }#
            } else {#
                if(force.test == "parametric") {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA (parametric test was enforced using 'force.test=\"parametric\"' options).")#
                    message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")                #
                } else {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                }#
#
            }#
#
            #Do test output#
        }#
#
        if(is.null(test_type) & data_type == "Multivariate") {#
            test_type<-"Multivariate"#
        }#
#
        if(test_type == "Multivariate") {#
            #Is the data univariate?#
            if(data_type == "Univariate") {#
                multi_data<-make.univariate.table(data)#
                data.values<-unvi_data[,1]#
                time<-univ_data[,2]#
                message("Multivariate test is performed on univariate data. Remove the multivariate options to enforce univariate test.")#
            } else {#
                multi_data<-make.multivariate.table(data)#
                data.values<-multi_data[[1]]#
                time<-multi_data[[2]]#
            }#
#
            #Running PERMANOVA#
            multi_test<-adonis(data.values~time, method=method, permutations=permutations)#
            message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))#
#
        }#
#
        #Output#
        if(test_type == "Multivariate") {#
            return(multi_test)#
        } else {#
            return(univ_test)#
        }#
#
    }#
#
}
disparity.test(time_dis, "Time")
disparity.test<-function(data, type, time=NULL, force.test=NULL, method=NULL, permutations=NULL, ...) {#
#
    #SANITIZING#
    message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }#
    #type#
    check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }#
    if(type != "Time") {#
        #Time#
        #TIME CAN ALSO BE A STRATA#
        #time (only in type = Age or Lag)#
        check.class(time, "numeric")#
        check.length(time, 1, " must be a single numerical value.")#
        #check if time is present in the time_pco#
        #Setting the data type#
        if(data_type == "Multivariate") {#
            #Multivariate data#
            intervals<-names(data)#
        } else {#
            #Univariate data#
            intervals<-names(data[[2]])#
        }#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    } #
#
    #force.test#
    if(!is.null(force.test)) {#
        check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }     #
    }#
#
    #setting the test type to null (default)#
    test_type=NULL#
#
    #method#
    if(is.null(method)) {#
        method="euclidean"#
    } else {#
        check.class(method, "character")#
        test_type<-"Multivariate"#
        message("'method' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #method#
    if(is.null(permutations)) {#
        permutations=1000#
    } else {#
        check.class(permutations, "numeric")#
        test_type<-"Multivariate"#
        message("'permutations' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #TEST DIFFERENCES IN DISPARITY#
#
    #TIME: testing the effect of time on data#
    if(type == "Time") {#
#
        if(data_type == "Univariate") {#
            #Univariate analysis (Kruskall Wallis or ANOVA)#
            univ_data<-make.univariate.table(data)#
            data.values<-univ_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)#
#
            #Running the univariate test#
            if(test[[1]] == TRUE) {#
                if(!is.null(force.test) & force.test == "non-parametric") {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                } else {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA.")#
                    message("Residuals are normally distributed and variance within groups is homogeneous.")#
                    message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")#
                }#
            } else {#
                if(force.test == "parametric") {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA (parametric test was enforced using 'force.test=\"parametric\"' options).")#
                    message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")                #
                } else {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                }#
#
            }#
#
            #Do test output#
        }#
#
        if(is.null(test_type) & data_type == "Multivariate") {#
            test_type<-"Multivariate"#
        }#
#
        if(test_type == "Multivariate") {#
            #Is the data univariate?#
            if(data_type == "Univariate") {#
                multi_data<-make.univariate.table(data)#
                data.values<-unvi_data[,1]#
                time<-univ_data[,2]#
                message("Multivariate test is performed on univariate data. Remove the multivariate options to enforce univariate test.")#
            } else {#
                multi_data<-make.multivariate.table(data)#
                data.values<-multi_data[[1]]#
                time<-multi_data[[2]]#
            }#
#
            #Running PERMANOVA#
            multi_test<-adonis(data.values~time, method=method, permutations=permutations)#
            message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))#
#
        }#
#
        #Output#
        if(test_type == "Multivariate") {#
            return(multi_test)#
        } else {#
            return(univ_test)#
        }#
#
    }#
#
}
disparity.test(time_dis, "Time")
disparity.test<-function(data, type, time=NULL, force.test=NULL, method=NULL, permutations=NULL, ...) {#
#
    #SANITIZING#
    message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }#
    #type#
    check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }#
    if(type != "Time") {#
        #Time#
        #TIME CAN ALSO BE A STRATA#
        #time (only in type = Age or Lag)#
        check.class(time, "numeric")#
        check.length(time, 1, " must be a single numerical value.")#
        #check if time is present in the time_pco#
        #Setting the data type#
        if(data_type == "Multivariate") {#
            #Multivariate data#
            intervals<-names(data)#
        } else {#
            #Univariate data#
            intervals<-names(data[[2]])#
        }#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    } #
#
    #force.test#
    if(!is.null(force.test)) {#
        check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }     #
    } else {#
        force.test<-FALSE#
    }#
#
    #setting the test type to null (default)#
    test_type=NULL#
#
    #method#
    if(is.null(method)) {#
        method="euclidean"#
    } else {#
        check.class(method, "character")#
        test_type<-"Multivariate"#
        message("'method' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #method#
    if(is.null(permutations)) {#
        permutations=1000#
    } else {#
        check.class(permutations, "numeric")#
        test_type<-"Multivariate"#
        message("'permutations' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #TEST DIFFERENCES IN DISPARITY#
#
    #TIME: testing the effect of time on data#
    if(type == "Time") {#
#
        if(data_type == "Univariate") {#
            #Univariate analysis (Kruskall Wallis or ANOVA)#
            univ_data<-make.univariate.table(data)#
            data.values<-univ_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)#
#
            #Running the univariate test#
            if(test[[1]] == TRUE) {#
                if(force.test == "non.parametric") {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                } else {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA.")#
                    message("Residuals are normally distributed and variance within groups is homogeneous.")#
                    message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")#
                }#
            } else {#
                if(force.test == "parametric") {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA (parametric test was enforced using 'force.test=\"parametric\"' options).")#
                    message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")                #
                } else {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                }#
#
            }#
#
            #Do test output#
        }#
#
        if(is.null(test_type) & data_type == "Multivariate") {#
            test_type<-"Multivariate"#
        }#
#
        if(test_type == "Multivariate") {#
            #Is the data univariate?#
            if(data_type == "Univariate") {#
                multi_data<-make.univariate.table(data)#
                data.values<-univ_data[,1]#
                time<-univ_data[,2]#
                message("Multivariate test is performed on univariate data. Remove the multivariate options to enforce univariate test.")#
            } else {#
                multi_data<-make.multivariate.table(data)#
                data.values<-multi_data[[1]]#
                time<-multi_data[[2]]#
            }#
#
            #Running PERMANOVA#
            multi_test<-adonis(data.values~time, method=method, permutations=permutations)#
            message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))#
#
        }#
#
        #Output#
        if(test_type == "Multivariate") {#
            return(multi_test)#
        } else {#
            if(test[[1]] == TRUE) {#
                return(list("Disparity test"=univ_test, "Parametric test"=test[[2]])#
            } else {#
                return(univ_test)#
            }#
        }#
#
    }#
#
}
disparity.test<-function(data, type, time=NULL, force.test=NULL, method=NULL, permutations=NULL, ...) {#
#
    #SANITIZING#
    message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }#
    #type#
    check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }#
    if(type != "Time") {#
        #Time#
        #TIME CAN ALSO BE A STRATA#
        #time (only in type = Age or Lag)#
        check.class(time, "numeric")#
        check.length(time, 1, " must be a single numerical value.")#
        #check if time is present in the time_pco#
        #Setting the data type#
        if(data_type == "Multivariate") {#
            #Multivariate data#
            intervals<-names(data)#
        } else {#
            #Univariate data#
            intervals<-names(data[[2]])#
        }#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    } #
#
    #force.test#
    if(!is.null(force.test)) {#
        check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }     #
    } else {#
        force.test<-FALSE#
    }#
#
    #setting the test type to null (default)#
    test_type=NULL#
#
    #method#
    if(is.null(method)) {#
        method="euclidean"#
    } else {#
        check.class(method, "character")#
        test_type<-"Multivariate"#
        message("'method' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #method#
    if(is.null(permutations)) {#
        permutations=1000#
    } else {#
        check.class(permutations, "numeric")#
        test_type<-"Multivariate"#
        message("'permutations' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #TEST DIFFERENCES IN DISPARITY#
#
    #TIME: testing the effect of time on data#
    if(type == "Time") {#
#
        if(data_type == "Univariate") {#
            #Univariate analysis (Kruskall Wallis or ANOVA)#
            univ_data<-make.univariate.table(data)#
            data.values<-univ_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)#
#
            #Running the univariate test#
            if(test[[1]] == TRUE) {#
                if(force.test == "non.parametric") {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                } else {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA.")#
                    message("Residuals are normally distributed and variance within groups is homogeneous.")#
                    message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")#
                }#
            } else {#
                if(force.test == "parametric") {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA (parametric test was enforced using 'force.test=\"parametric\"' options).")#
                    message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")                #
                } else {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                }#
#
            }#
#
            #Do test output#
        }#
#
        if(is.null(test_type) & data_type == "Multivariate") {#
            test_type<-"Multivariate"#
        }#
#
        if(test_type == "Multivariate") {#
            #Is the data univariate?#
            if(data_type == "Univariate") {#
                multi_data<-make.univariate.table(data)#
                data.values<-univ_data[,1]#
                time<-univ_data[,2]#
                message("Multivariate test is performed on univariate data. Remove the multivariate options to enforce univariate test.")#
            } else {#
                multi_data<-make.multivariate.table(data)#
                data.values<-multi_data[[1]]#
                time<-multi_data[[2]]#
            }#
#
            #Running PERMANOVA#
            multi_test<-adonis(data.values~time, method=method, permutations=permutations)#
            message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))#
#
        }#
#
        #Output#
        if(test_type == "Multivariate") {#
            return(multi_test)#
        } else {#
            if(test[[1]] == TRUE) {#
                return(list("Disparity test"=univ_test, "Parametric test"=test[[2]]))#
            } else {#
                return(univ_test)#
            }#
        }#
#
    }#
#
}
disparity.test(time_dis, "Time")
disparity.test<-function(data, type, time=NULL, force.test=NULL, method=NULL, permutations=NULL, ...) {#
#
    #SANITIZING#
    message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }#
    #type#
    check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }#
    if(type != "Time") {#
        #Time#
        #TIME CAN ALSO BE A STRATA#
        #time (only in type = Age or Lag)#
        check.class(time, "numeric")#
        check.length(time, 1, " must be a single numerical value.")#
        #check if time is present in the time_pco#
        #Setting the data type#
        if(data_type == "Multivariate") {#
            #Multivariate data#
            intervals<-names(data)#
        } else {#
            #Univariate data#
            intervals<-names(data[[2]])#
        }#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    } #
#
    #force.test#
    if(!is.null(force.test)) {#
        check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }     #
    } else {#
        force.test<-FALSE#
    }#
#
    #setting the test type to null (default)#
    test_type=NULL#
#
    #method#
    if(is.null(method)) {#
        method="euclidean"#
    } else {#
        check.class(method, "character")#
        test_type<-"Multivariate"#
        message("'method' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #method#
    if(is.null(permutations)) {#
        permutations=1000#
    } else {#
        check.class(permutations, "numeric")#
        test_type<-"Multivariate"#
        message("'permutations' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #TEST DIFFERENCES IN DISPARITY#
#
    #TIME: testing the effect of time on data#
    if(type == "Time") {#
#
        if(data_type == "Univariate") {#
            #Univariate analysis (Kruskall Wallis or ANOVA)#
            univ_data<-make.univariate.table(data)#
            data.values<-univ_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)#
#
            #Running the univariate test#
            if(test[[1]] == TRUE) {#
                if(force.test == "non.parametric") {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                } else {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA.")#
                    message("Residuals are normally distributed and variance within groups is homogeneous.")#
                    message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")#
                }#
            } else {#
                if(force.test == "parametric") {#
                    #ANOVA#
                    unvi_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA (parametric test was enforced using 'force.test=\"parametric\"' options).")#
                    message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")                #
                } else {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                }#
#
            }#
#
            #Do test output#
        }#
#
        if(is.null(test_type) & data_type == "Multivariate") {#
            test_type<-"Multivariate"#
        } else {#
            test_type<-"Univariate"#
        }#
#
        if(test_type == "Multivariate") {#
            #Is the data univariate?#
            if(data_type == "Univariate") {#
                multi_data<-make.univariate.table(data)#
                data.values<-univ_data[,1]#
                time<-univ_data[,2]#
                message("Multivariate test is performed on univariate data. Remove the multivariate options to enforce univariate test.")#
            } else {#
                multi_data<-make.multivariate.table(data)#
                data.values<-multi_data[[1]]#
                time<-multi_data[[2]]#
            }#
#
            #Running PERMANOVA#
            multi_test<-adonis(data.values~time, method=method, permutations=permutations)#
            message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))#
#
        }#
#
        #Output#
        if(test_type == "Multivariate") {#
            return(multi_test)#
        } else {#
            if(test[[1]] == TRUE) {#
                return(list("Disparity test"=univ_test, "Parametric test"=test[[2]]))#
            } else {#
                return(univ_test)#
            }#
        }#
#
    }#
#
}
disparity.test(time_dis, "Time")
disparity.test<-function(data, type, time=NULL, force.test=NULL, method=NULL, permutations=NULL, ...) {#
#
    #SANITIZING#
    message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }#
    #type#
    check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }#
    if(type != "Time") {#
        #Time#
        #TIME CAN ALSO BE A STRATA#
        #time (only in type = Age or Lag)#
        check.class(time, "numeric")#
        check.length(time, 1, " must be a single numerical value.")#
        #check if time is present in the time_pco#
        #Setting the data type#
        if(data_type == "Multivariate") {#
            #Multivariate data#
            intervals<-names(data)#
        } else {#
            #Univariate data#
            intervals<-names(data[[2]])#
        }#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    } #
#
    #force.test#
    if(!is.null(force.test)) {#
        check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }     #
    } else {#
        force.test<-FALSE#
    }#
#
    #setting the test type to null (default)#
    test_type=NULL#
#
    #method#
    if(is.null(method)) {#
        method="euclidean"#
    } else {#
        check.class(method, "character")#
        test_type<-"Multivariate"#
        message("'method' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #method#
    if(is.null(permutations)) {#
        permutations=1000#
    } else {#
        check.class(permutations, "numeric")#
        test_type<-"Multivariate"#
        message("'permutations' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #TEST DIFFERENCES IN DISPARITY#
#
    #TIME: testing the effect of time on data#
    if(type == "Time") {#
#
        if(data_type == "Univariate") {#
            #Univariate analysis (Kruskall Wallis or ANOVA)#
            univ_data<-make.univariate.table(data)#
            data.values<-univ_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)#
#
            #Running the univariate test#
            if(test[[1]] == TRUE) {#
                if(force.test == "non.parametric") {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                } else {#
                    #ANOVA#
                    univ_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA.")#
                    message("Residuals are normally distributed and variance within groups is homogeneous.")#
                    message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")#
                }#
            } else {#
                if(force.test == "parametric") {#
                    #ANOVA#
                    univ_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA (parametric test was enforced using 'force.test=\"parametric\"' options).")#
                    message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")                #
                } else {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                }#
#
            }#
#
            #Do test output#
        }#
#
        if(is.null(test_type) & data_type == "Multivariate") {#
            test_type<-"Multivariate"#
        } else {#
            test_type<-"Univariate"#
        }#
#
        if(test_type == "Multivariate") {#
            #Is the data univariate?#
            if(data_type == "Univariate") {#
                multi_data<-make.univariate.table(data)#
                data.values<-univ_data[,1]#
                time<-univ_data[,2]#
                message("Multivariate test is performed on univariate data. Remove the multivariate options to enforce univariate test.")#
            } else {#
                multi_data<-make.multivariate.table(data)#
                data.values<-multi_data[[1]]#
                time<-multi_data[[2]]#
            }#
#
            #Running PERMANOVA#
            multi_test<-adonis(data.values~time, method=method, permutations=permutations)#
            message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))#
#
        }#
#
        #Output#
        if(test_type == "Multivariate") {#
            return(multi_test)#
        } else {#
            if(test[[1]] == TRUE) {#
                return(list("Disparity test"=univ_test, "Parametric test"=test[[2]]))#
            } else {#
                return(univ_test)#
            }#
        }#
#
    }#
#
}
disparity.test(time_dis, "Time")
disparity.test(time_dis, "Time", force.test="non-parametric")
force.test="non-parametric"
!is.null(force.test)
disparity.test<-function(data, type, time=NULL, force.test=NULL, method=NULL, permutations=NULL, ...) {#
#
    #SANITIZING#
    message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }#
    #type#
    check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }#
    if(type != "Time") {#
        #Time#
        #TIME CAN ALSO BE A STRATA#
        #time (only in type = Age or Lag)#
        check.class(time, "numeric")#
        check.length(time, 1, " must be a single numerical value.")#
        #check if time is present in the time_pco#
        #Setting the data type#
        if(data_type == "Multivariate") {#
            #Multivariate data#
            intervals<-names(data)#
        } else {#
            #Univariate data#
            intervals<-names(data[[2]])#
        }#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    } #
#
    #force.test#
    if(!is.null(force.test) == TRUE) {#
        check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }     #
    } else {#
        force.test<-FALSE#
    }#
#
    #setting the test type to null (default)#
    test_type=NULL#
#
    #method#
    if(is.null(method)) {#
        method="euclidean"#
    } else {#
        check.class(method, "character")#
        test_type<-"Multivariate"#
        message("'method' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #method#
    if(is.null(permutations)) {#
        permutations=1000#
    } else {#
        check.class(permutations, "numeric")#
        test_type<-"Multivariate"#
        message("'permutations' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #TEST DIFFERENCES IN DISPARITY#
#
    #TIME: testing the effect of time on data#
    if(type == "Time") {#
#
        if(data_type == "Univariate") {#
            #Univariate analysis (Kruskall Wallis or ANOVA)#
            univ_data<-make.univariate.table(data)#
            data.values<-univ_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)#
#
            #Running the univariate test#
            if(test[[1]] == TRUE) {#
                if(force.test == "non.parametric") {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                } else {#
                    #ANOVA#
                    univ_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA.")#
                    message("Residuals are normally distributed and variance within groups is homogeneous.")#
                    message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")#
                }#
            } else {#
                if(force.test == "parametric") {#
                    #ANOVA#
                    univ_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA (parametric test was enforced using 'force.test=\"parametric\"' options).")#
                    message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")                #
                } else {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                }#
#
            }#
#
            #Do test output#
        }#
#
        if(is.null(test_type) & data_type == "Multivariate") {#
            test_type<-"Multivariate"#
        } else {#
            test_type<-"Univariate"#
        }#
#
        if(test_type == "Multivariate") {#
            #Is the data univariate?#
            if(data_type == "Univariate") {#
                multi_data<-make.univariate.table(data)#
                data.values<-univ_data[,1]#
                time<-univ_data[,2]#
                message("Multivariate test is performed on univariate data. Remove the multivariate options to enforce univariate test.")#
            } else {#
                multi_data<-make.multivariate.table(data)#
                data.values<-multi_data[[1]]#
                time<-multi_data[[2]]#
            }#
#
            #Running PERMANOVA#
            multi_test<-adonis(data.values~time, method=method, permutations=permutations)#
            message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))#
#
        }#
#
        #Output#
        if(test_type == "Multivariate") {#
            return(multi_test)#
        } else {#
            if(test[[1]] == TRUE) {#
                return(list("Disparity test"=univ_test, "Parametric test"=test[[2]]))#
            } else {#
                return(univ_test)#
            }#
        }#
#
    }#
#
}
disparity.test(time_dis, "Time", force.test="non-parametric")
!is.null(force.test) == TRUE
check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")
check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")
if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }
force.test
univ_data<-make.univariate.table(data)#
            data.values<-univ_data[,1]#
            time<-univ_data[,2]
test<-test.anova(univ_data)
data<-time_dis
univ_data<-make.univariate.table(data)#
            data.values<-univ_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)
test[[1]] == TRUE
force.test == "non.parametric"
force.test
disparity.test<-function(data, type, time=NULL, force.test=NULL, method=NULL, permutations=NULL, ...) {#
#
    #SANITIZING#
    message("Warning: no sanitizing in this version yet!\nUse this function at your own risks...")#
    #Add data sanitizing input#
    if(class(data[[1]]) == "matrix") {#
        data_type<-"Multivariate"#
    } else {#
        data_type<-"Univariate"#
    }#
    #type#
    check.class(type, "character", " can be either 'Time', 'Age' or 'Lag'.")#
    check.length(type, 1, " can be either 'Time', 'Age' or 'Lag'.")#
    type_list<-c('Time', "Age", "Lag")#
    if(is.na(match(type, type_list))) {#
        stop("Time can be either 'Time', 'Age' or 'Lag'.")#
    }#
    if(type != "Time") {#
        #Time#
        #TIME CAN ALSO BE A STRATA#
        #time (only in type = Age or Lag)#
        check.class(time, "numeric")#
        check.length(time, 1, " must be a single numerical value.")#
        #check if time is present in the time_pco#
        #Setting the data type#
        if(data_type == "Multivariate") {#
            #Multivariate data#
            intervals<-names(data)#
        } else {#
            #Univariate data#
            intervals<-names(data[[2]])#
        }#
        if(length(grep(time, intervals)) == 0) {#
            #Time is within intervals#
            stop("Not developed yet: time within intervals.")#
        } else {#
            if(length(grep(time, intervals))==2) {#
                #Time is between intervals#
                int_befor<-grep(time, intervals)[1]#
                int_after<-grep(time, intervals)[2]#
            } else {#
                #Time is at interval#
                int_befor<-grep(time, intervals)[1]#
                int_after<-int_befor+1#
            }#
        }#
        #Lag#
        if(type == "Lag") {#
            int_after<-int_after:length(intervals)#
        }#
    } #
#
    #force.test#
    if(!is.null(force.test) == TRUE) {#
        check.class(force.test, "character", " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        check.length(force.test, 1, " can be either 'parametric', 'non-parametric' or 'NULL'.")#
        if(force.test != "parametric") {#
            if(force.test != "non-parametric") {#
                stop("force.test must be either 'parametric', 'non-parametric' or 'NULL'.")#
            }#
        }     #
    } else {#
        force.test<-FALSE#
    }#
#
    #setting the test type to null (default)#
    test_type=NULL#
#
    #method#
    if(is.null(method)) {#
        method="euclidean"#
    } else {#
        check.class(method, "character")#
        test_type<-"Multivariate"#
        message("'method' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #method#
    if(is.null(permutations)) {#
        permutations=1000#
    } else {#
        check.class(permutations, "numeric")#
        test_type<-"Multivariate"#
        message("'permutations' options is not null. The test is assumed to be multivariate.")#
    }#
#
    #TEST DIFFERENCES IN DISPARITY#
#
    #TIME: testing the effect of time on data#
    if(type == "Time") {#
#
        if(data_type == "Univariate") {#
            #Univariate analysis (Kruskall Wallis or ANOVA)#
            univ_data<-make.univariate.table(data)#
            data.values<-univ_data[,1]#
            time<-univ_data[,2]#
            #Testing assumptions of anova#
            test<-test.anova(univ_data)#
#
            #Running the univariate test#
            if(test[[1]] == TRUE) {#
                if(force.test == "non-parametric") {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                } else {#
                    #ANOVA#
                    univ_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA.")#
                    message("Residuals are normally distributed and variance within groups is homogeneous.")#
                    message("Is the data independent? If not use the 'force.test=\"non-parametric\"' options.")#
                }#
            } else {#
                if(force.test == "parametric") {#
                    #ANOVA#
                    univ_test<-summary(aov(data.values~time))#
                    message("Tested input values ~ input time using ANOVA (parametric test was enforced using 'force.test=\"parametric\"' options).")#
                    message("Residuals are NOT normally distributed and variance within groups is NOT homogeneous.")                #
                } else {#
                    #KW test#
                    univ_test<-kruskal.test(data.values~time)#
                    message("Tested input values ~ input time using Kruskal-Wallis rank sum test.")#
                }#
#
            }#
#
            #Do test output#
        }#
#
        if(is.null(test_type) & data_type == "Multivariate") {#
            test_type<-"Multivariate"#
        } else {#
            test_type<-"Univariate"#
        }#
#
        if(test_type == "Multivariate") {#
            #Is the data univariate?#
            if(data_type == "Univariate") {#
                multi_data<-make.univariate.table(data)#
                data.values<-univ_data[,1]#
                time<-univ_data[,2]#
                message("Multivariate test is performed on univariate data. Remove the multivariate options to enforce univariate test.")#
            } else {#
                multi_data<-make.multivariate.table(data)#
                data.values<-multi_data[[1]]#
                time<-multi_data[[2]]#
            }#
#
            #Running PERMANOVA#
            multi_test<-adonis(data.values~time, method=method, permutations=permutations)#
            message(paste("Tested input values ~ input time using PERMANOVA with ", method," distance and ", permutations, " permutations.", sep=""))#
#
        }#
#
        #Output#
        if(test_type == "Multivariate") {#
            return(multi_test)#
        } else {#
            if(test[[1]] == TRUE) {#
                return(list("Disparity test"=univ_test, "Parametric test"=test[[2]]))#
            } else {#
                return(univ_test)#
            }#
        }#
#
    }#
#
}
disparity.test(time_dis, "Time", force.test="non-parametric")
