% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{plainnat}
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={dispRity R package manual},
  pdfauthor={Thomas Guillerme (guillert@tcd.ie)},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{dispRity R package manual}
\author{Thomas Guillerme (\href{mailto:guillert@tcd.ie}{\nolinkurl{guillert@tcd.ie}})}
\date{2024-11-12}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{disprity}{%
\chapter{\texorpdfstring{\texttt{dispRity}}{dispRity}}\label{disprity}}

This is a package for measuring disparity (aka multidimensional space occupancy) in \texttt{R}.
It allows users to summarise matrices as representations as multidimensional spaces into a single value or distribution describing a specific aspect of this multidimensional space (the disparity).
Multidimensional spaces can be ordinated matrices from MDS, PCA, PCO, PCoA but the package is \emph{not} restricted to any type of matrices!
This manual is based on the version 1.7.

\hypertarget{what-is-disprity}{%
\section{\texorpdfstring{What is \texttt{dispRity}?}{What is dispRity?}}\label{what-is-disprity}}

This is a modular package for measuring disparity in \texttt{R}.
It allows users to summarise ordinated matrices (e.g.~MDS, PCA, PCO, PCoA) to perform some multidimensional analysis.
Typically, these analysis are used in palaeobiology and evolutionary biology to study the changes in morphology through time.
However, there are many more applications in ecology, evolution and beyond.

\hypertarget{modular}{%
\subsection{Modular?}\label{modular}}

Because their exist a multitude of ways to measure disparity, each adapted to every specific question, this package uses an easy to modify modular architecture.
In coding, each module is simply a function or a modification of a function that can be passed to the main functions of the package to tweak it to your proper needs!
In practice, you will notice throughout this manual that some function can take other functions as arguments: the modular architecture of this package allows you to use any function for these arguments (with some restrictions explained for each specific cases).
This will allow you to finely tune your multidimensional analysis to the needs of your specific question!

\hypertarget{installing-and-running-the-package}{%
\section{Installing and running the package}\label{installing-and-running-the-package}}

You can install this package easily, directly from the CRAN:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"dispRity"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Alternatively, for the most up to data version and some functionalities not compatible with the CRAN, you can use the package through GitHub using \texttt{devtool} (see \protect\hyperlink{noCRAN}{to CRAN or not to CRAN?} for more details):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Checking if devtools is already installed}
\ControlFlowTok{if}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{require}\NormalTok{(devtools)) }\FunctionTok{install.packages}\NormalTok{(}\StringTok{"devtools"}\NormalTok{)}

\DocumentationTok{\#\# Installing the latest released version directly from GitHub}
\FunctionTok{install\_github}\NormalTok{(}\StringTok{"TGuillerme/dispRity"}\NormalTok{, }\AttributeTok{ref =} \StringTok{"release"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Note this uses the \texttt{release} branch (1.7).
For the piping-hot (but potentially unstable) version, you can change the argument \texttt{ref\ =\ release} to \texttt{ref\ =\ master}.
\texttt{dispRity} depends mainly on the \texttt{ape} package and uses functions from several other packages (\texttt{ade4}, \texttt{geometry}, \texttt{grDevices}, \texttt{hypervolume}, \texttt{paleotree}, \texttt{snow}, \texttt{Claddis}, \texttt{geomorph} and \texttt{RCurl}).

\hypertarget{version}{%
\section{Which version do I choose?}\label{version}}

There are always three version of the package available:

\begin{itemize}
\tightlist
\item
  The CRAN one
\item
  The GitHub \texttt{release} one
\item
  The GitHub \texttt{master} one
\end{itemize}

The differences between the CRAN one and the GitHub \texttt{release} or \texttt{master} ones is explained just above.
For the the GitHub version, the differences are that the \texttt{release} one is more stable (i.e.~more rarely modified) and the \texttt{master} one is more live one (i.e.~bug fixes and new functionalities are added as they come).

If you want the latest-latest version of the package I suggest using the GitHub \texttt{master} one, especially if you recently emailed me reporting a minor bug or wanting a new functionality!
Note however that \emph{it can happen} that the \texttt{master} version can sometimes be bugged (especially when there are major \texttt{R} and \texttt{R} packages updates), however, the status of the package state on both the \texttt{release} and the \texttt{master} version is constantly displayed on the \href{https://github.com/TGuillerme/dispRity/}{\texttt{README} page} of the package with the nice badges displaying these different (and constantly tested) information.

\hypertarget{disprity-is-always-changing-how-do-i-know-its-not-broken}{%
\section{\texorpdfstring{\texttt{dispRity} is always changing, how do I know it's not broken?}{dispRity is always changing, how do I know it's not broken?}}\label{disprity-is-always-changing-how-do-i-know-its-not-broken}}

This is a really common a legitimate question in software development. Like \texttt{R} itself:

\begin{quote}
\texttt{dispRity} is free software and comes with ABSOLUTELY NO WARRANTY.
\end{quote}

So you are using it at your own risk.

\textbf{HOWEVER}, there are two points that can be used as objective-ish markers on why it's OK to use \texttt{dispRity}.

First, the package has been use in a number of \href{https://scholar.google.co.uk/scholar?oi=bibs\&hl=en\&cites=13311379491028410826,7753828186872068057}{peer reviewed} publications (the majority of them independently) which could be taken as warranty.

Second, I spend a lot of time and attention in making sure that every function in every version actually does what I think it is supposed to do.
This is done through \href{https://en.wikipedia.org/wiki/Continuous_integration}{CI; continuous integration development}, the \href{https://cran.r-project.org/web/checks/check_results_dispRity.html}{CRAN check}, and \href{https://en.wikipedia.org/wiki/Unit_testing}{unit testing}.
The two first checks (CRAN and CI) ensure that the version you are using is not bugged (the \href{https://cran.r-project.org/web/checks/check_results_dispRity.html}{CRAN check} if you are using the CRAN version and the \href{https://travis-ci.org/TGuillerme/dispRity}{Travis CI} if you are using a GitHub version).
The third check, unit testing, is checking that every function is doing what it is supposed to do. For a real basic example, it is testing that the following expression should always return the same thing no matter what changes in the package.

\begin{verbatim}
> mean(c(1,2,3))
[1] 2
\end{verbatim}

Or, more formally:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{testthat}\SpecialCharTok{::}\FunctionTok{expect\_equal}\NormalTok{(}\AttributeTok{object =} \FunctionTok{mean}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)),}
                       \AttributeTok{expected =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can always access what is actually tested in the \href{https://github.com/TGuillerme/dispRity/tree/master/tests/testthat}{\texttt{test/testthat}} sub-folder.
For example \href{https://github.com/TGuillerme/dispRity/blob/master/tests/testthat/test-dispRity.R}{here is how the core function \texttt{dispRity}} is tested (through \textgreater{} 500 tests!).
All these tests are run every time a change is made to the package and you can always see for yourself how much a single function is covered (i.e.~what percentage of the function is actually covered by at least one test).
You can always see the global coverage \href{https://app.codecov.io/gh/TGuillerme/dispRity}{here} or the specific coverage for each function \href{https://codecov.io/gh/TGuillerme/dispRity/tree/master/R}{here}.

Finally, this package is build on the shoulders of the whole open science philosophy so when bugs do occur and are caught by myself or the package users, they are quickly fixed and notified in the \href{https://github.com/TGuillerme/dispRity/blob/master/NEWS.md}{\texttt{NEWS.md} file}. And all the changes to the package are \href{https://github.com/TGuillerme/dispRity/commits/master}{public and annotated} so there's that too\ldots{}

\hypertarget{help}{%
\section{Help}\label{help}}

If you need help with the package, hopefully the following manual will be useful.
However, parts of this package are still in development and some other parts are probably not covered.
Thus if you have suggestions or comments on on what has already been developed or will be developed, please send me an email (\href{mailto:guillert@tcd.ie}{\nolinkurl{guillert@tcd.ie}}) or if you are a GitHub user, directly create an issue on the \href{https://github.com/TGuillerme/dispRity}{GitHub page}.

\hypertarget{citations}{%
\section{Citations}\label{citations}}

To cite the package, this manual or some specific functionalities, you can use the following references:

The package main paper:

\begin{quote}
Guillerme T. dispRity: A modular R package for measuring disparity. Methods Ecol Evol. 2018;9:1755--1763. \href{https://doi.org/10.1111/2041-210X.13022}{doi.org/10.1111/2041-210X.13022}.
\end{quote}

The package manual (regularly updated!):

\begin{quote}
Guillerme, T. \& Cooper, N. (2018): dispRity manual. figshare. Preprint. \href{https://doi.org/10.6084/m9.figshare.6187337.v1}{10.6084/m9.figshare.6187337.v1}.
\end{quote}

The time-slicing method implemented in \texttt{chrono.subsets} (unfortunately not Open Access, but you can still get a \href{https://tguillerme.github.io/papers/Guillerme\&Cooper-2018-Palaeontology.pdf}{free copy from here}):

\begin{quote}
Guillerme, T. and Cooper, N. (2018), Time for a rethink: time sub-sampling methods in disparity-through-time analyses. Palaeontology, 61: 481-493. \href{https://onlinelibrary.wiley.com/doi/abs/10.1111/pala.12364}{doi:10.1111/pala.12364}.
\end{quote}

Furthermore, don't forget to cite \texttt{R}:

\begin{quote}
R Core Team (2020). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL \url{https://www.R-project.org/}.
\end{quote}

Bonus: you can also cite \texttt{ape} since the \texttt{dispRity} package heavily relies on it:

\begin{quote}
Paradis E. \& Schliep K. 2019. ape 5.0: an environment for modern phylogenetics and evolutionary analyses in R. Bioinformatics 35: 526-528.
\end{quote}

\hypertarget{why-is-it-important-to-cite-us}{%
\subsection{Why is it important to cite us?}\label{why-is-it-important-to-cite-us}}

Aside from how science works (if you're using a method from a specific paper, cite that specific paper to refer to that specific method), why is it important to also cite the package and the manual?

All the people involve in making the \texttt{dispRity} package happened to do it enthusiastically, freely and most amazingly without asking anything in return!
I created the package with this idea in mind and I am still sticking to it.
However, academia (the institutions and people producing science around the globe) is unfortunately not optimal at many level (some might even say ``broken''): high impact papers attract big grants that attract high impact papers and big grants again, all this along with livelihood, permanent position and job security.
Unfortunately however, method development has a hard time to catch up with the current publish or perish system: constantly updating the \texttt{dispRity} package and this manual is hugely time consuming (but really fun!) and that is not even taking into account maintenance and helping users.
Although I do truly believe that this time spent doing these things modestly help the scientific endeavour, it does not contribute to our paper list!

Therefore, by citing the package and this manual, you help provide visibility to other workers and you might help them in their work!
And you directly contribute in making this project fun for all the people involved and most of all, free, updated and independent from the publish and perish system!

Thank you!

\hypertarget{glossary}{%
\chapter{Glossary}\label{glossary}}

\begin{itemize}
\item
  \textbf{Multidimensional space} (or just space). The mathematical multidimensional object that will be analysed with this package.
  In morphometrics, this is often referred to as the morphospace.
  However it may also be referred to as the cladisto-space for cladistic data or the eco-space for ecological data etc.
  In practice, this term designates a matrix where the columns represent the dimensions of the space (often -- but not necessarily - \textgreater{} 3!) and the rows represent the elements within this space.
\item
  \textbf{Elements}. The rows of the multidimensional space matrix. Elements can be taxa, field sites, countries etc.
\item
  \textbf{Dimensions}. The columns of the multidimensional space matrix. The dimensions can be referred to as axes of variation, or principal components, for ordinated spaces obtained from a PCA for example.
\item
  \textbf{Subsets}. Subsets of the multidimensional space.
  A subset (or subsets) contains the same number of dimensions as the space but may contain a smaller subset of elements.
  For example, if our space is composed of birds and mammals (the elements) and 50 principal components of variation (the dimensions), we can create two subsets containing just mammals or birds, but with the same 50 dimensions, to compare disparity in the two clades.
\item
  \textbf{Disparity}. A metric expressing the similarities/dissimilarities of the elements within the space or a summarising the space dimensions. For example the pairwise distances between elements or the range of each dimensions.
\end{itemize}

\hypertarget{glossary-equivalences-in-palaeobiology-and-ecology}{%
\section{Glossary equivalences in palaeobiology and ecology}\label{glossary-equivalences-in-palaeobiology-and-ecology}}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2459}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2459}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2951}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2131}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
In this manual
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
In \texttt{dispRity}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
E.g. in palaeobiology
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
E.g. in ecology
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
the multidimensional space & a \texttt{matrix} object (\(n\times d\)) & a morphospace & a function-space \\
elements & rows (\(n\)) & taxa & field experiments \\
dimensions & columns (\(d\)) & morphological characters & communities' compositions \\
subsets & a \texttt{matrix} (\(m \times d\), with \(m \leq n\)) & time series & experimental treatments \\
disparity & a \texttt{function} & sum of variances & ellipsoid volume \\
\end{longtable}

\hypertarget{getting-started-with-disprity}{%
\chapter{\texorpdfstring{Getting started with \texttt{dispRity}}{Getting started with dispRity}}\label{getting-started-with-disprity}}

\hypertarget{what-sort-of-data-does-disprity-work-with}{%
\section{\texorpdfstring{What sort of data does \texttt{dispRity} work with?}{What sort of data does dispRity work with?}}\label{what-sort-of-data-does-disprity-work-with}}

\textbf{Any matrix object in \texttt{R}.}
Disparity can be estimated from pretty much any matrix as long as rows represent the elements and columns the dimensions.
These matrices can be observations, pairwise differences between elements, ordinations, etc\ldots{}

Since version \texttt{1.4} it is also possible to include a \texttt{"list"} containing matrices.
These matrices need to have the same dimensions and rownames but can contain different values.
This is especially useful for modelling uncertainty (see \protect\hyperlink{multi.input}{here} for more details).

\hypertarget{ordinated-matrices}{%
\section{Ordinated matrices}\label{ordinated-matrices}}

Classically, when a high number of variables is used, disparity is calculated from ordinated matrices.
These can be any type of ordinations (PCO, PCA, PCoA, MDS, etc.) as long as elements are the rows (taxa, countries, field experiments) and the dimensions are the columns.
However, note that this is not required from any of the functions in this package.
You can also use distance matrices or any other matrix type that suits your question and your analysis!

\hypertarget{ordination-matrices-from-geomorph}{%
\subsection{\texorpdfstring{Ordination matrices from \texttt{geomorph}}{Ordination matrices from geomorph}}\label{ordination-matrices-from-geomorph}}

You can also easily use data from \texttt{geomorph} using the \texttt{geomorph.ordination} function.
This function simply takes Procrustes aligned data and performs an ordination:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(geomorph)}

\DocumentationTok{\#\# Loading the plethodon dataset}
\FunctionTok{data}\NormalTok{(plethodon)}

\DocumentationTok{\#\# Performing a Procrustes transform on the landmarks}
\NormalTok{procrustes }\OtherTok{\textless{}{-}} \FunctionTok{gpagen}\NormalTok{(plethodon}\SpecialCharTok{$}\NormalTok{land, }\AttributeTok{PrinAxes =} \ConstantTok{FALSE}\NormalTok{,}
                     \AttributeTok{print.progress =} \ConstantTok{FALSE}\NormalTok{)}

\DocumentationTok{\#\# Ordinating this data}
\FunctionTok{geomorph.ordination}\NormalTok{(procrustes)[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                PC1        PC2           PC3          PC4          PC5
## [1,] -0.0369930887 0.05118246 -0.0016971586 -0.003128881 -0.010935739
## [2,] -0.0007493689 0.05942083  0.0001371682 -0.002768621 -0.008117767
## [3,]  0.0056004751 0.07419599 -0.0052612189 -0.005034502 -0.002747104
## [4,] -0.0134808326 0.06463958 -0.0458436274 -0.007887336  0.009817034
## [5,] -0.0334696064 0.06863518  0.0136292227  0.007359383  0.022347215
\end{verbatim}

Options for the ordination (from \texttt{?prcomp}) can be directly passed to this function to perform customised ordinations.
Additionally you can give the function a \texttt{geomorph.data.frame} object.
If the latter contains sorting information (i.e.~factors), they can be directly used to make a customised \texttt{dispRity} object \protect\hyperlink{customised-subsets}{customised \texttt{dispRity} object}!

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Using a geomorph.data.frame}
\NormalTok{geomorph\_df }\OtherTok{\textless{}{-}} \FunctionTok{geomorph.data.frame}\NormalTok{(procrustes,}
     \AttributeTok{species =}\NormalTok{ plethodon}\SpecialCharTok{$}\NormalTok{species, }\AttributeTok{site =}\NormalTok{ plethodon}\SpecialCharTok{$}\NormalTok{site)}

\DocumentationTok{\#\# Ordinating this data and making a dispRity object}
\FunctionTok{geomorph.ordination}\NormalTok{(geomorph\_df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 4 customised subsets for 40 elements in one matrix:
##     species.Jord, species.Teyah, site.Allo, site.Symp.
\end{verbatim}

More about these \texttt{dispRity} objects below!

\hypertarget{Claddis-ordination}{%
\subsection{\texorpdfstring{Ordination matrices from \texttt{Claddis}}{Ordination matrices from Claddis}}\label{Claddis-ordination}}

\texttt{dispRity} package can also easily take data from the \texttt{Claddis} package using the \texttt{Claddis.ordination} function.
For this, simply input a matrix in the \texttt{Claddis} format to the function and it will automatically calculate and ordinate the distances among taxa:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(Claddis)}

\DocumentationTok{\#\# Ordinating the example data from Claddis}
\FunctionTok{Claddis.ordination}\NormalTok{(michaux\_1989)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                      [,1]          [,2]       [,3]
## Ancilla      0.000000e+00  4.154578e-01  0.2534942
## Turrancilla -5.106645e-01 -1.304614e-16 -0.2534942
## Ancillista   5.106645e-01 -1.630768e-17 -0.2534942
## Amalda       1.603581e-16 -4.154578e-01  0.2534942
\end{verbatim}

Note that several options are available, namely which type of distance should be computed.
See more info in the function manual (\texttt{?Claddis.ordination}).
Alternatively, it is of course also possible to manual calculate the ordination matrix using the functions \texttt{Claddis::calculate\_morphological\_distances} and \texttt{stats::cmdscale}.

\hypertarget{other-kinds-of-ordination-matrices}{%
\subsection{Other kinds of ordination matrices}\label{other-kinds-of-ordination-matrices}}

If you are not using the packages mentioned above (\texttt{Claddis} and \texttt{geomorph}) you can easily make your own ordination matrices by using the following functions from the \texttt{stats} package.
Here is how to do it for the following types of matrices:

\begin{itemize}
\tightlist
\item
  Multivariate matrices (principal components analysis; PCA)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A multivariate matrix}
\FunctionTok{head}\NormalTok{(USArrests)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##            Murder Assault UrbanPop Rape
## Alabama      13.2     236       58 21.2
## Alaska       10.0     263       48 44.5
## Arizona       8.1     294       80 31.0
## Arkansas      8.8     190       50 19.5
## California    9.0     276       91 40.6
## Colorado      7.9     204       78 38.7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Ordinating the matrix using \textasciigrave{}prcomp\textasciigrave{} }
\NormalTok{ordination }\OtherTok{\textless{}{-}} \FunctionTok{prcomp}\NormalTok{(USArrests)}

\DocumentationTok{\#\# Selecting the ordinated matrix}
\NormalTok{ordinated\_matrix }\OtherTok{\textless{}{-}}\NormalTok{ ordination}\SpecialCharTok{$}\NormalTok{x}
\FunctionTok{head}\NormalTok{(ordinated\_matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                  PC1        PC2        PC3        PC4
## Alabama     64.80216 -11.448007 -2.4949328 -2.4079009
## Alaska      92.82745 -17.982943 20.1265749  4.0940470
## Arizona    124.06822   8.830403 -1.6874484  4.3536852
## Arkansas    18.34004 -16.703911  0.2101894  0.5209936
## California 107.42295  22.520070  6.7458730  2.8118259
## Colorado    34.97599  13.719584 12.2793628  1.7214637
\end{verbatim}

This results in a ordinated matrix with US states as elements and four dimensions (PC 1 to 4). For an alternative method, see the \texttt{?princomp} function.

\begin{itemize}
\tightlist
\item
  Distance matrices (classical multidimensional scaling; MDS)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A matrix of distances between cities}
\FunctionTok{str}\NormalTok{(eurodist)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  'dist' num [1:210] 3313 2963 3175 3339 2762 ...
##  - attr(*, "Size")= num 21
##  - attr(*, "Labels")= chr [1:21] "Athens" "Barcelona" "Brussels" "Calais" ...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Ordinating the matrix using cmdscale() with k = 5 dimensions }
\NormalTok{ordinated\_matrix }\OtherTok{\textless{}{-}} \FunctionTok{cmdscale}\NormalTok{(eurodist, }\AttributeTok{k =} \DecValTok{5}\NormalTok{)}
\FunctionTok{head}\NormalTok{(ordinated\_matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                 [,1]      [,2]       [,3]       [,4]       [,5]
## Athens    2290.27468 1798.8029   53.79314 -103.82696 -156.95511
## Barcelona -825.38279  546.8115 -113.85842   84.58583  291.44076
## Brussels    59.18334 -367.0814  177.55291   38.79751  -95.62045
## Calais     -82.84597 -429.9147  300.19274  106.35369 -180.44614
## Cherbourg -352.49943 -290.9084  457.35294  111.44915 -417.49668
## Cologne    293.68963 -405.3119  360.09323 -636.20238  159.39266
\end{verbatim}

This results in a ordinated matrix with European cities as elements and five dimensions.

Of course any other method for creating the ordination matrix is totally valid, you can also not use any ordination at all!
The only requirements for the \texttt{dispRity} functions is that the input is a matrix with elements as rows and dimensions as columns.

\hypertarget{simpleanalysis}{%
\section{Performing a simple dispRity analysis}\label{simpleanalysis}}

Two \texttt{dispRity} functions allow users to run an analysis pipeline simply by inputting an ordination matrix.
These functions allow users to either calculate the disparity through time (\texttt{dispRity.through.time}) or the disparity of user-defined groups (\texttt{dispRity.per.group}).

\textbf{IMPORTANT}

Note that \texttt{disparity.through.time} and \texttt{disparity.per.group} are wrapper functions (i.e.~they incorporate lots of other functions) that allow users to run a basic disparity-through-time, or disparity among groups, analysis without too much effort.
As such they use a lot of default options.
These are described in the help files for the functions that are used to make the wrapper functions, and not described in the help files for \texttt{disparity.through.time} and \texttt{disparity.per.group}.
These defaults are good enough for \textbf{data exploration}, but for a proper analysis you should consider the \textbf{best parameters for your question and data}.
For example, which metric should you use?
How many bootstraps do you require?
What model of evolution is most appropriate if you are time slicing?
Should you rarefy the data?
See \protect\hyperlink{time-slicing}{\texttt{chrono.subsets}}, \protect\hyperlink{customised-subsets}{\texttt{custom.subsets}}, \protect\hyperlink{bootstraps-and-rarefactions}{\texttt{boot.matrix}} and \protect\hyperlink{disparity-metrics}{\texttt{dispRity.metric}} for more details of the defaults used in each of these functions.
Note that any of these default arguments can be changed within the \texttt{disparity.through.time} or \texttt{disparity.per.group} functions.

\hypertarget{example-data}{%
\subsection{Example data}\label{example-data}}

To illustrate these functions, we will use data from \citet{beckancient2014}.
This dataset contains an ordinated matrix of 50 discrete characters from mammals (\texttt{BeckLee\_mat50}), another matrix of the same 50 mammals and the estimated discrete data characters of their descendants (thus 50 + 49 rows, \texttt{BeckLee\_mat99}), a dataframe containing the ages of each taxon in the dataset (\texttt{BeckLee\_ages}) and finally a phylogenetic tree with the relationships among the 50 mammals (\texttt{BeckLee\_tree}).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading the ordinated matrices}
\FunctionTok{data}\NormalTok{(BeckLee\_mat50)}
\FunctionTok{data}\NormalTok{(BeckLee\_mat99)}

\DocumentationTok{\#\# The first five taxa and dimensions of the 50 taxa matrix}
\FunctionTok{head}\NormalTok{(BeckLee\_mat50[, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                    [,1]        [,2]        [,3]       [,4]       [,5]
## Cimolestes   -0.5613001  0.06006259  0.08414761 -0.2313084 0.18825039
## Maelestes    -0.4186019 -0.12186005  0.25556379  0.2737995 0.28510479
## Batodon      -0.8337640  0.28718501 -0.10594610 -0.2381511 0.07132646
## Bulaklestes  -0.7708261 -0.07629583  0.04549285 -0.4951160 0.39962626
## Daulestes    -0.8320466 -0.09559563  0.04336661 -0.5792351 0.37385914
## Uchkudukodon -0.5074468 -0.34273248  0.40410310 -0.1223782 0.34857351
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The first five taxa and dimensions of the 99 taxa + ancestors matrix}
\NormalTok{BeckLee\_mat99[}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{98}\NormalTok{, }\DecValTok{99}\NormalTok{), }\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                  [,1]         [,2]        [,3]        [,4]        [,5]
## Cimolestes -0.6662114  0.152778203  0.04859246 -0.34158286  0.26817202
## Maelestes  -0.5719365  0.051636855 -0.19877079 -0.08318416 -0.14166592
## n48         0.2511551 -0.002014967  0.22408002  0.06857018 -0.05660113
## n49         0.3860798  0.131742956  0.12604056 -0.14738050  0.05095751
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading a list of first and last occurrence dates for the fossils}
\FunctionTok{data}\NormalTok{(BeckLee\_ages)}
\FunctionTok{head}\NormalTok{(BeckLee\_ages)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             FAD  LAD
## Adapis     37.2 36.8
## Asioryctes 83.6 72.1
## Leptictis  33.9 33.3
## Miacis     49.0 46.7
## Mimotona   61.6 59.2
## Notharctus 50.2 47.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading and plotting the phylogeny}
\FunctionTok{data}\NormalTok{(BeckLee\_tree)}
\FunctionTok{plot}\NormalTok{(BeckLee\_tree, }\AttributeTok{cex =} \FloatTok{0.8}\NormalTok{) }
\FunctionTok{axisPhylo}\NormalTok{(}\AttributeTok{root =} \DecValTok{140}\NormalTok{)}
\FunctionTok{nodelabels}\NormalTok{(}\AttributeTok{cex =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-13-1.pdf}

Of course you can use your own data as detailed in the \protect\hyperlink{What-sort-of-data-does-dispRity-work-with}{previous section}.

\hypertarget{disparity-through-time}{%
\subsection{Disparity through time}\label{disparity-through-time}}

The \texttt{dispRity.through.time} function calculates disparity through time, a common analysis in palaeontology.
This function (and the following one) uses an analysis pipeline with a lot of default parameters to make the analysis as simple as possible.
Of course all the defaults can be changed if required, more on this later.

For a disparity through time analysis, you will need:

\begin{itemize}
\tightlist
\item
  An ordinated matrix (we covered that above)
\item
  A phylogenetic tree: this must be a \texttt{phylo} object (from the \texttt{ape} package) and needs a \texttt{root.time} element. To give your tree a root time (i.e.~an age for the root), you can simply do\textbackslash{} \texttt{my\_tree\$root.time\ \textless{}-\ my\_age}.
\item
  The required number of time subsets (here \texttt{time\ =\ 3})
\item
  Your favourite disparity metric (here the sum of variances)
\end{itemize}

Using the Beck and Lee (2014) data described \protect\hyperlink{example-data}{above}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring disparity through time}
\NormalTok{disparity\_data }\OtherTok{\textless{}{-}} \FunctionTok{dispRity.through.time}\NormalTok{(BeckLee\_mat50, BeckLee\_tree,}
                                        \AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, variances),}
                                        \AttributeTok{time =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This generates a \texttt{dispRity} object (see \protect\hyperlink{guts}{here} for technical details).
When displayed, these \texttt{dispRity} objects provide us with information on the operations done to the matrix:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Print the disparity\_data object}
\NormalTok{disparity\_data}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 3 discrete time subsets for 50 elements in one matrix with 48 dimensions with 1 phylogenetic tree
##     133.51 - 89.01, 89.01 - 44.5, 44.5 - 0.
## Rows were bootstrapped 100 times (method:"full").
## Disparity was calculated as: metric.
\end{verbatim}

We asked for three subsets (evenly spread across the age of the tree), the data was bootstrapped 100 times (default) and the metric used was the sum of variances.

We can now summarise or plot the \texttt{disparity\_data} object, or perform statistical tests on it (e.g.~a simple \texttt{lm}):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Summarising disparity through time}
\FunctionTok{summary}\NormalTok{(disparity\_data)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          subsets  n   obs bs.median  2.5%   25%   75% 97.5%
## 1 133.51 - 89.01  5 2.123     1.775 1.017 1.496 1.942 2.123
## 2   89.01 - 44.5 29 2.456     2.384 2.295 2.350 2.404 2.427
## 3       44.5 - 0 16 2.528     2.363 2.213 2.325 2.406 2.466
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Plotting the results}
\FunctionTok{plot}\NormalTok{(disparity\_data, }\AttributeTok{type =} \StringTok{"continuous"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-16-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Testing for an difference among the time bins}
\NormalTok{disp\_lm }\OtherTok{\textless{}{-}} \FunctionTok{test.dispRity}\NormalTok{(disparity\_data, }\AttributeTok{test =}\NormalTok{ lm,}
                         \AttributeTok{comparisons =} \StringTok{"all"}\NormalTok{)}
\FunctionTok{summary}\NormalTok{(disp\_lm)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Call:
## test(formula = data ~ subsets, data = data)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.87430 -0.04100  0.01456  0.05318  0.41059 
## 
## Coefficients:
##                     Estimate Std. Error t value Pr(>|t|)    
## (Intercept)          1.71217    0.01703  100.55   <2e-16 ***
## subsets44.5 - 0      0.64824    0.02408   26.92   <2e-16 ***
## subsets89.01 - 44.5  0.66298    0.02408   27.53   <2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 0.1703 on 297 degrees of freedom
## Multiple R-squared:  0.769,  Adjusted R-squared:  0.7674 
## F-statistic: 494.3 on 2 and 297 DF,  p-value: < 2.2e-16
\end{verbatim}

Please refer to the \protect\hyperlink{specific-tutorial}{specific tutorials} for (much!) more information on the nuts and bolts of the package.
You can also directly explore the specific function help files within R and navigate to related functions.

\hypertarget{disparity-among-groups}{%
\subsection{Disparity among groups}\label{disparity-among-groups}}

The \texttt{dispRity.per.group} function is used if you are interested in looking at disparity among groups rather than through time.
For example, you could ask if there is a difference in disparity between two groups?

To perform such an analysis, you will need:

\begin{itemize}
\tightlist
\item
  An matrix with rows as elements and columns as dimensions (always!)
\item
  A list of group members: this list should be a list of numeric vectors or names corresponding to the row names in the matrix. For example \texttt{list("A"\ =\ c(1,2),\ "B"\ =\ c(3,4))} will create a group \emph{A} containing elements 1 and 2 from the matrix and a group \emph{B} containing elements 3 and 4. Note that elements can be present in multiple groups at once.
\item
  Your favourite disparity metric (here the sum of variances)
\end{itemize}

Using the \citet{beckancient2014} data described \protect\hyperlink{example-data}{above}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating the two groups (crown versus stem) as a list}
\NormalTok{mammal\_groups }\OtherTok{\textless{}{-}} \FunctionTok{crown.stem}\NormalTok{(BeckLee\_tree, }\AttributeTok{inc.nodes =} \ConstantTok{FALSE}\NormalTok{)}

\DocumentationTok{\#\# Measuring disparity for each group}
\NormalTok{disparity\_data }\OtherTok{\textless{}{-}} \FunctionTok{dispRity.per.group}\NormalTok{(BeckLee\_mat50,}
                                     \AttributeTok{group =}\NormalTok{ mammal\_groups,}
                                     \AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, variances))}
\end{Highlighting}
\end{Shaded}

We can display the disparity of both groups by simply looking at the output variable (\texttt{disparity\_data}) and then summarising the \texttt{disparity\_data} object and plotting it, and/or by performing a statistical test to compare disparity across the groups (here a Wilcoxon test).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Print the disparity\_data object}
\NormalTok{disparity\_data}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 2 customised subsets for 50 elements in one matrix with 48 dimensions:
##     crown, stem.
## Rows were bootstrapped 100 times (method:"full").
## Disparity was calculated as: metric.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Summarising disparity in the different groups}
\FunctionTok{summary}\NormalTok{(disparity\_data)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs bs.median  2.5%   25%   75% 97.5%
## 1   crown 30 2.526     2.446 2.380 2.429 2.467 2.498
## 2    stem 20 2.244     2.134 2.025 2.105 2.164 2.208
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Plotting the results}
\FunctionTok{plot}\NormalTok{(disparity\_data)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-18-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Testing for a difference between the groups}
\FunctionTok{test.dispRity}\NormalTok{(disparity\_data, }\AttributeTok{test =}\NormalTok{ wilcox.test, }\AttributeTok{details =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $`crown : stem`
## $`crown : stem`[[1]]
## 
##  Wilcoxon rank sum test with continuity correction
## 
## data:  dots[[1L]][[1L]] and dots[[2L]][[1L]]
## W = 10000, p-value < 2.2e-16
## alternative hypothesis: true location shift is not equal to 0
\end{verbatim}

\hypertarget{details-of-specific-functions}{%
\chapter{Details of specific functions}\label{details-of-specific-functions}}

The following section contains information specific to some functions.
If any of your questions are not covered in these sections, please refer to the function help files in \texttt{R}, send me an email (\href{mailto:guillert@tcd.ie}{\nolinkurl{guillert@tcd.ie}}), or raise an issue on \href{https://github.com/TGuillerme/dispRity/issues}{GitHub}.
The several tutorials below describe specific functionalities of certain functions; please always refer to the function help files for the full function documentation!

Before each section, make sure you loaded the \citet{beckancient2014} data (see \protect\hyperlink{example-data}{example data} for more details).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading the data}
\FunctionTok{data}\NormalTok{(BeckLee\_mat50)}
\FunctionTok{data}\NormalTok{(BeckLee\_mat99)}
\FunctionTok{data}\NormalTok{(BeckLee\_tree)}
\FunctionTok{data}\NormalTok{(BeckLee\_ages)}
\end{Highlighting}
\end{Shaded}

\hypertarget{chrono-subsets}{%
\section{Time slicing}\label{chrono-subsets}}

The function \texttt{chrono.subsets} allows users to divide the matrix into different time subsets or slices given a dated phylogeny that contains all the elements (i.e.~taxa) from the matrix.
Each subset generated by this function will then contain all the elements present at a specific point in time or during a specific period in time.

Two types of time subsets can be performed by using the \texttt{method} option:

\begin{itemize}
\tightlist
\item
  Discrete time subsets (or time-binning) using \texttt{method\ =\ discrete}
\item
  Continuous time subsets (or time-slicing) using \texttt{method\ =\ continuous}
\end{itemize}

For the time-slicing method details see \citet{time-slice}.
For both methods, the function takes the \texttt{time} argument which can be a vector of \texttt{numeric} values for:

\begin{itemize}
\tightlist
\item
  Defining the boundaries of the time bins (when \texttt{method\ =\ discrete})
\item
  Defining the time slices (when \texttt{method\ =\ continuous})
\end{itemize}

Otherwise, the \texttt{time} argument can be set as a single \texttt{numeric} value for automatically generating a given number of equidistant time-bins/slices.
Additionally, it is also possible to input a dataframe containing the first and last occurrence data (FAD/LAD) for taxa that span over a longer time than the given tips/nodes age, so taxa can appear in more than one time bin/slice.

\hypertarget{time-binning}{%
\subsection{Time-binning}\label{time-binning}}

Here is an example for the time binning method (\texttt{method\ =\ discrete}):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Generating three time bins containing the taxa present every 40 Ma}
\FunctionTok{chrono.subsets}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_mat50, }\AttributeTok{tree =}\NormalTok{ BeckLee\_tree,}
               \AttributeTok{method =} \StringTok{"discrete"}\NormalTok{,}
               \AttributeTok{time =} \FunctionTok{c}\NormalTok{(}\DecValTok{120}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{0}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 3 discrete time subsets for 50 elements in one matrix with 1 phylogenetic tree
##     120 - 80, 80 - 40, 40 - 0.
\end{verbatim}

Note that we can also generate equivalent results by just telling the function that we want three time-bins as follow:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Automatically generate three equal length bins:}
\FunctionTok{chrono.subsets}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_mat50, }\AttributeTok{tree =}\NormalTok{ BeckLee\_tree,}
               \AttributeTok{method =} \StringTok{"discrete"}\NormalTok{,}
               \AttributeTok{time =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 3 discrete time subsets for 50 elements in one matrix with 1 phylogenetic tree
##     133.51 - 89.01, 89.01 - 44.5, 44.5 - 0.
\end{verbatim}

In this example, the taxa were split inside each time-bin according to their age.
However, the taxa here are considered as single points in time.
It is totally possible that some taxa could have had longer longevity and that they exist in multiple time bins.
In this case, it is possible to include them in more than one bin by providing a table of first and last occurrence dates (FAD/LAD).
This table should have the taxa names as row names and two columns for respectively the first and last occurrence age:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Displaying the table of first and last occurrence dates}
\DocumentationTok{\#\# for each taxa}
\FunctionTok{head}\NormalTok{(BeckLee\_ages)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             FAD  LAD
## Adapis     37.2 36.8
## Asioryctes 83.6 72.1
## Leptictis  33.9 33.3
## Miacis     49.0 46.7
## Mimotona   61.6 59.2
## Notharctus 50.2 47.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Generating time bins including taxa that might span between them}
\FunctionTok{chrono.subsets}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_mat50, }\AttributeTok{tree =}\NormalTok{ BeckLee\_tree,}
               \AttributeTok{method =} \StringTok{"discrete"}\NormalTok{,}
               \AttributeTok{time =} \FunctionTok{c}\NormalTok{(}\DecValTok{120}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{0}\NormalTok{), }\AttributeTok{FADLAD =}\NormalTok{ BeckLee\_ages)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 3 discrete time subsets for 50 elements in one matrix with 1 phylogenetic tree
##     120 - 80, 80 - 40, 40 - 0.
\end{verbatim}

When using this method, the oldest boundary of the first bin (or the first slice, see below) is automatically generated as the root age plus 1\% of the tree length, as long as at least three elements/taxa are present at that point in time.
The algorithm adds an extra 1\% tree length until reaching the required minimum of three elements.
It is also possible to include nodes in each bin by using \texttt{inc.nodes\ =\ TRUE} and providing a matrix that contains the ordinated distance among tips \emph{and} nodes.

If you want to generate time subsets based on stratigraphy, the package proposes a useful functions to do it for you: \texttt{get.bin.ages} (check out the function's manual in \texttt{R})!

\hypertarget{time-slicing}{%
\subsection{Time-slicing}\label{time-slicing}}

For the time-slicing method (\texttt{method\ =\ continuous}), the idea is fairly similar.
This option, however, requires a matrix that contains the ordinated distance among taxa \emph{and} nodes and an extra argument describing the assumed evolutionary model (via the \texttt{model} argument).
This model argument is used when the time slice occurs along a branch of the tree rather than on a tip or a node, meaning that a decision must be made about what the value for the branch should be.
The model can be one of the following:

\begin{itemize}
\tightlist
\item
  \textbf{Punctuated models}

  \begin{itemize}
  \tightlist
  \item
    \texttt{acctran} where the data chosen along the branch is always the one of the descendant
  \item
    \texttt{deltran} where the data chosen along the branch is always the one of the ancestor
  \item
    \texttt{random} where the data chosen along the branch is randomly chosen between the descendant or the ancestor
  \item
    \texttt{proximity} where the data chosen along the branch is either the descendant or the ancestor depending on branch length
  \end{itemize}
\item
  \textbf{Gradual models}

  \begin{itemize}
  \tightlist
  \item
    \texttt{equal.split} where the data chosen along the branch is both the descendant and the ancestor with an even probability
  \item
    \texttt{gradual.split} where the data chosen along the branch is both the descendant and the ancestor with a probability depending on branch length
  \end{itemize}
\end{itemize}

\begin{quote}
Note that the four first models are a proxy for punctuated evolution: the selected data is always either the one of the descendant or the ancestor.
In other words, changes along the branches always occur at either ends of it.
The two last models are a proxy for gradual evolution: the data from both the descendant and the ancestor is used with an associate probability.
These later models perform better when bootstrapped, effectively approximating the ``intermediate'' state between and the ancestor and the descendants.
\end{quote}

More details about the differences between these methods can be found in \citet{time-slice}.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Generating four time slices every 40 million years}
\DocumentationTok{\#\# under a model of proximity evolution}
\FunctionTok{chrono.subsets}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_mat99, }\AttributeTok{tree =}\NormalTok{ BeckLee\_tree, }
               \AttributeTok{method =} \StringTok{"continuous"}\NormalTok{, }\AttributeTok{model =} \StringTok{"proximity"}\NormalTok{,}
               \AttributeTok{time =} \FunctionTok{c}\NormalTok{(}\DecValTok{120}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{0}\NormalTok{),}
               \AttributeTok{FADLAD =}\NormalTok{ BeckLee\_ages)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 4 continuous (proximity) time subsets for 99 elements in one matrix with 1 phylogenetic tree
##     120, 80, 40, 0.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Generating four time slices automatically}
\FunctionTok{chrono.subsets}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_mat99, }\AttributeTok{tree =}\NormalTok{ BeckLee\_tree,}
               \AttributeTok{method =} \StringTok{"continuous"}\NormalTok{, }\AttributeTok{model =} \StringTok{"proximity"}\NormalTok{,}
               \AttributeTok{time =} \DecValTok{4}\NormalTok{, }\AttributeTok{FADLAD =}\NormalTok{ BeckLee\_ages)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 4 continuous (proximity) time subsets for 99 elements in one matrix with 1 phylogenetic tree
##     133.51, 89.01, 44.5, 0.
\end{verbatim}

\hypertarget{custom-subsets}{%
\section{Customised subsets}\label{custom-subsets}}

Another way of separating elements into different categories is to use customised subsets as briefly explained \protect\hyperlink{disparity-among-groups}{above}.
This function simply takes the list of elements to put in each group (whether they are the actual element names or their position in the matrix).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating the two groups (crown and stems)}
\NormalTok{mammal\_groups }\OtherTok{\textless{}{-}} \FunctionTok{crown.stem}\NormalTok{(BeckLee\_tree, }\AttributeTok{inc.nodes =} \ConstantTok{FALSE}\NormalTok{)}

\DocumentationTok{\#\# Separating the dataset into two different groups}
\FunctionTok{custom.subsets}\NormalTok{(BeckLee\_mat50, }\AttributeTok{group =}\NormalTok{ mammal\_groups)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 2 customised subsets for 50 elements in one matrix:
##     crown, stem.
\end{verbatim}

Like in this example, you can use the utility function \texttt{crown.stem} that allows to automatically separate the crown and stems taxa given a phylogenetic tree.
Also, elements can easily be assigned to different groups if necessary!

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating the three groups as a list}
\NormalTok{weird\_groups }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\StringTok{"even"} \OtherTok{=} \FunctionTok{seq}\NormalTok{(}\AttributeTok{from =} \DecValTok{1}\NormalTok{, }\AttributeTok{to =} \DecValTok{49}\NormalTok{, }\AttributeTok{by =} \DecValTok{2}\NormalTok{),}
                      \StringTok{"odd"} \OtherTok{=} \FunctionTok{seq}\NormalTok{(}\AttributeTok{from =} \DecValTok{2}\NormalTok{, }\AttributeTok{to =} \DecValTok{50}\NormalTok{, }\AttributeTok{by =} \DecValTok{2}\NormalTok{),}
                      \StringTok{"all"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{50}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

The \texttt{custom.subsets} function can also take a phylogeny (as a \texttt{phylo} object) as an argument to create groups as clades:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating groups as clades}
\FunctionTok{custom.subsets}\NormalTok{(BeckLee\_mat50, }\AttributeTok{group =}\NormalTok{ BeckLee\_tree)}
\end{Highlighting}
\end{Shaded}

This automatically creates 49 (the number of nodes) groups containing between two and 50 (the number of tips) elements.

\hypertarget{bootstraps-and-rarefactions}{%
\section{Bootstraps and rarefactions}\label{bootstraps-and-rarefactions}}

One important step in analysing ordinated matrices is to pseudo-replicate the data to see how robust the results are, and how sensitive they are to outliers in the dataset.
This can be achieved using the function \texttt{boot.matrix} to bootstrap and/or rarefy the data.
The default options will bootstrap the matrix 100 times without rarefaction using the ``full'' bootstrap method (see below):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Default bootstrapping}
\FunctionTok{boot.matrix}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_mat50)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 50 elements in one matrix with 48 dimensions.
## Rows were bootstrapped 100 times (method:"full").
\end{verbatim}

The number of bootstrap replicates can be defined using the \texttt{bootstraps} option.
The method can be modified by controlling which bootstrap algorithm to use through the \texttt{boot.type} argument.
Currently two algorithms are implemented:

\begin{itemize}
\tightlist
\item
  \texttt{"full"} where the bootstrapping is entirely stochastic (\emph{n} elements are replaced by any \emph{m} elements drawn from the data)
\item
  \texttt{"single"} where only one random element is replaced by one other random element for each pseudo-replicate
\item
  \texttt{"null"} where every element is resampled across the whole matrix (not just the subsets). I.e. for each subset of \emph{n} elements, this algorithm resamples \emph{n} elements across \emph{ALL} subsets (not just the current one). If only one subset (or none) is used, this does the same as the \texttt{"full"} algorithm.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Bootstrapping with the single bootstrap method}
\FunctionTok{boot.matrix}\NormalTok{(BeckLee\_mat50, }\AttributeTok{boot.type =} \StringTok{"single"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 50 elements in one matrix with 48 dimensions.
## Rows were bootstrapped 100 times (method:"single").
\end{verbatim}

This function also allows users to rarefy the data using the \texttt{rarefaction} argument.
Rarefaction allows users to limit the number of elements to be drawn at each bootstrap replication.
This is useful if, for example, one is interested in looking at the effect of reducing the number of elements on the results of an analysis.

This can be achieved by using the \texttt{rarefaction} option that draws only \emph{n-x} at each bootstrap replicate (where \emph{x} is the number of elements not sampled).
The default argument is \texttt{FALSE} but it can be set to \texttt{TRUE} to fully rarefy the data (i.e.~remove \emph{x} elements for the number of pseudo-replicates, where \emph{x} varies from the maximum number of elements present in each subset to a minimum of three elements).
It can also be set to one or more \texttt{numeric} values to only rarefy to the corresponding number of elements.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Bootstrapping with the full rarefaction}
\FunctionTok{boot.matrix}\NormalTok{(BeckLee\_mat50, }\AttributeTok{bootstraps =} \DecValTok{20}\NormalTok{,}
            \AttributeTok{rarefaction =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 50 elements in one matrix with 48 dimensions.
## Rows were bootstrapped 20 times (method:"full") and fully rarefied.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Or with a set number of rarefaction levels}
\FunctionTok{boot.matrix}\NormalTok{(BeckLee\_mat50, }\AttributeTok{bootstraps =} \DecValTok{20}\NormalTok{,}
            \AttributeTok{rarefaction =} \FunctionTok{c}\NormalTok{(}\DecValTok{6}\SpecialCharTok{:}\DecValTok{8}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 50 elements in one matrix with 48 dimensions.
## Rows were bootstrapped 20 times (method:"full") and rarefied to 6, 7, 8, 3 elements.
\end{verbatim}

\begin{quote}
Note that using the \texttt{rarefaction} argument also bootstraps the data. In these examples, the function bootstraps the data (without rarefaction) AND also bootstraps the data with the different rarefaction levels.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating subsets of crown and stem mammals}
\NormalTok{crown\_stem }\OtherTok{\textless{}{-}} \FunctionTok{custom.subsets}\NormalTok{(BeckLee\_mat50,}
                             \AttributeTok{group =} \FunctionTok{crown.stem}\NormalTok{(BeckLee\_tree,}
                                                \AttributeTok{inc.nodes =} \ConstantTok{FALSE}\NormalTok{))}
\DocumentationTok{\#\# Bootstrapping and rarefying these groups}
\FunctionTok{boot.matrix}\NormalTok{(crown\_stem, }\AttributeTok{bootstraps =} \DecValTok{200}\NormalTok{, }\AttributeTok{rarefaction =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 2 customised subsets for 50 elements in one matrix with 48 dimensions:
##     crown, stem.
## Rows were bootstrapped 200 times (method:"full") and fully rarefied.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating time slice subsets}
\NormalTok{time\_slices }\OtherTok{\textless{}{-}} \FunctionTok{chrono.subsets}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_mat99,}
                              \AttributeTok{tree =}\NormalTok{ BeckLee\_tree, }
                              \AttributeTok{method =} \StringTok{"continuous"}\NormalTok{,}
                              \AttributeTok{model =} \StringTok{"proximity"}\NormalTok{, }
                              \AttributeTok{time =} \FunctionTok{c}\NormalTok{(}\DecValTok{120}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{0}\NormalTok{),}
                              \AttributeTok{FADLAD =}\NormalTok{ BeckLee\_ages)}

\DocumentationTok{\#\# Bootstrapping the time slice subsets}
\FunctionTok{boot.matrix}\NormalTok{(time\_slices, }\AttributeTok{bootstraps =} \DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 4 continuous (proximity) time subsets for 99 elements in one matrix with 97 dimensions with 1 phylogenetic tree
##     120, 80, 40, 0.
## Rows were bootstrapped 100 times (method:"full").
\end{verbatim}

\hypertarget{bootstrapping-with-probabilities}{%
\subsection{Bootstrapping with probabilities}\label{bootstrapping-with-probabilities}}

It is also possible to specify the sampling probability in the bootstrap for each elements.
This can be useful for weighting analysis for example (i.e.~giving more importance to specific elements).
These probabilities can be passed to the \texttt{prob} argument individually with a vector with the elements names or with a matrix with the rownames as elements names.
The elements with no specified probability will be assigned a probability of 1 (or 1/maximum weight if the argument is weights rather than probabilities).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Attributing a weight of 0 to Cimolestes and 10 to Maelestes}
\FunctionTok{boot.matrix}\NormalTok{(BeckLee\_mat50,}
            \AttributeTok{prob =} \FunctionTok{c}\NormalTok{(}\StringTok{"Cimolestes"} \OtherTok{=} \DecValTok{0}\NormalTok{, }\StringTok{"Maelestes"} \OtherTok{=} \DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 50 elements in one matrix with 48 dimensions.
## Rows were bootstrapped 100 times (method:"full").
\end{verbatim}

\hypertarget{bootstrapping-dimensions}{%
\subsection{Bootstrapping dimensions}\label{bootstrapping-dimensions}}

In some cases, you might also be interested in bootstrapping dimensions rather than observations.
I.e. bootstrapping the columns of a matrix rather than the rows.

It's pretty easy! By default, \texttt{boot.matrix} uses the option \texttt{boot.by\ =\ "rows"} which you can toggle to \texttt{boot.by\ =\ "columns"}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Bootstrapping the observations (default)}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{boot\_obs }\OtherTok{\textless{}{-}} \FunctionTok{boot.matrix}\NormalTok{(}\AttributeTok{data =}\NormalTok{ crown\_stem, }\AttributeTok{boot.by =} \StringTok{"rows"}\NormalTok{)}

\DocumentationTok{\#\# Bootstrapping the columns rather than the rows}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{boot\_dim }\OtherTok{\textless{}{-}} \FunctionTok{boot.matrix}\NormalTok{(}\AttributeTok{data =}\NormalTok{ crown\_stem, }\AttributeTok{boot.by =} \StringTok{"columns"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In these two examples, the first one \texttt{boot\_obs} bootstraps the rows as showed before (default behaviour).
But the second one, \texttt{boot\_dim} bootstraps the dimensions.
That means that for each bootstrap sample, the value calculated is actually obtained by reshuffling the dimensions (columns) rather than the observations (rows).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring disparity and summarising}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(boot\_obs, }\AttributeTok{metric =}\NormalTok{ sum))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n  obs bs.median  2.5%   25%   75% 97.5%
## 1   crown 30 -1.1     -2.04 -19.4 -7.56 3.621 14.64
## 2    stem 20  1.1      1.52 -10.8 -1.99 6.712 13.97
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(boot\_dim, }\AttributeTok{metric =}\NormalTok{ sum))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n  obs bs.median  2.5%   25%   75% 97.5%
## 1   crown 30 -1.1     -2.04 -18.5 -8.84 5.440 19.80
## 2    stem 20  1.1      1.31 -16.7 -2.99 6.338 14.99
\end{verbatim}

Note here how the observed sum is the same (no bootstrapping) but the bootstrapping distributions are quiet different even though the same seed was used.

\hypertarget{disparity-metrics}{%
\section{Disparity metrics}\label{disparity-metrics}}

There are many ways of measuring disparity!
In brief, disparity is a summary metric that will represent an aspect of an ordinated space (e.g.~a MDS, PCA, PCO, PCoA).
For example, one can look at ellipsoid hyper-volume of the ordinated space (Donohue \emph{et al.} 2013), the sum and the product of the ranges and variances (Wills \emph{et al.} 1994) or the median position of the elements relative to their centroid (Wills \emph{et al.} 1994).
Of course, there are many more examples of metrics one can use for describing some aspect of the ordinated space, with some performing better than other ones at particular descriptive tasks, and some being more generalist.
Check out this paper on selecting the best metric for your specific question in \href{https://onlinelibrary.wiley.com/doi/full/10.1002/ece3.6452}{Ecology and Evolution}.
You can also use the \href{https://tguillerme.shinyapps.io/moms/}{\texttt{moms} shiny app} to test which metric captures which aspect of traitspace occupancy regarding your specific space and your specific question.

Regardless, and because of this great diversity of metrics, the package \texttt{dispRity} does not have one way to measure disparity but rather proposes to facilitate users in defining their own disparity metric that will best suit their particular analysis.
In fact, the core function of the package, \texttt{dispRity}, allows the user to define any metric with the \texttt{metric} argument.
However the \texttt{metric} argument has to follow certain rules:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  It must be composed from one to three \texttt{function} objects;
\item
  The function(s) must take as a first argument a \texttt{matrix} or a \texttt{vector};
\item
  The function(s) must be of one of the three dimension-levels described below;
\item
  At least one of the functions must be of dimension-level 1 or 2 (see below).
\end{enumerate}

\hypertarget{the-function-dimension-levels}{%
\subsection{The function dimension-levels}\label{the-function-dimension-levels}}

The metric function dimension-levels determine the ``dimensionality of decomposition'' of the input matrix.
In other words, each dimension-level designates the dimensions of the output, i.e.~either three (a \texttt{matrix}); two (a \texttt{vector}); or one (a single \texttt{numeric} value) dimension.

\begin{figure}
\centering
\includegraphics{dispRity_fun.png}
\caption{Illustration of the different dimension-levels of functions with an input \texttt{matrix}}
\end{figure}

\hypertarget{dimension-level-1-functions}{%
\subsubsection{Dimension-level 1 functions}\label{dimension-level-1-functions}}

A dimension-level 1 function will decompose a \texttt{matrix} or a \texttt{vector} into a single value:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating a dummy matrix}
\NormalTok{dummy\_matrix }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{12}\NormalTok{), }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{)}

\DocumentationTok{\#\# Example of dimension{-}level 1 functions}
\FunctionTok{mean}\NormalTok{(dummy\_matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.183358
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{median}\NormalTok{(dummy\_matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.3909538
\end{verbatim}

Any summary metric such as mean or median are good examples of dimension-level 1 functions as they reduce the matrix to a single dimension (i.e.~one value).

\hypertarget{dimension-level-2-functions}{%
\subsubsection{Dimension-level 2 functions}\label{dimension-level-2-functions}}

A dimension-level 2 function will decompose a \texttt{matrix} into a \texttt{vector}.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Defining the function as the product of rows}
\NormalTok{prod.rows }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(matrix) }\FunctionTok{apply}\NormalTok{(matrix, }\DecValTok{1}\NormalTok{, prod)}

\DocumentationTok{\#\# A dimension{-}level 2 metric}
\FunctionTok{prod.rows}\NormalTok{(dummy\_matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  0.63727584 -0.09516528 -1.24477435 -0.10958022
\end{verbatim}

Several dimension-level 2 functions are implemented in \texttt{dispRity} (see \texttt{?dispRity.metric}) such as the \texttt{variances} or \texttt{ranges} functions that calculate the variance or the range of each dimension of the ordinated matrix respectively.

\hypertarget{dimension-level-3-functions}{%
\subsubsection{Dimension-level 3 functions}\label{dimension-level-3-functions}}

Finally a dimension-level 3 function will transform the matrix into another matrix.
Note that the dimension of the output matrix doesn't need to match the the input matrix:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A dimension{-}level 3 metric}
\FunctionTok{var}\NormalTok{(dummy\_matrix)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##            [,1]       [,2]      [,3]
## [1,]  0.6356714 -0.2017617 0.2095042
## [2,] -0.2017617  1.3656124 1.0850900
## [3,]  0.2095042  1.0850900 1.0879400
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A dimension{-}level 3 metric with a forced matrix output}
\FunctionTok{as.matrix}\NormalTok{(}\FunctionTok{dist}\NormalTok{(dummy\_matrix))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          1        2        3        4
## 1 0.000000 1.390687 2.156388 2.984951
## 2 1.390687 0.000000 2.557670 1.602143
## 3 2.156388 2.557670 0.000000 3.531033
## 4 2.984951 1.602143 3.531033 0.000000
\end{verbatim}

\hypertarget{betweengroupmetricsexplain}{%
\subsection{Between groups metrics}\label{betweengroupmetricsexplain}}

One specific category of metrics in the \texttt{dispRity} package is the between groups metrics.
As the name suggest, these metrics can be used to calculate the disparity between groups rather than within the groups.
These metrics follow the same classifications as the ``normal'' (within group) metrics with dimension-level 1, 2 and 3 between groups metrics.
However, at the difference of the ``normal'' metrics, their input arguments must be \texttt{matrix} and \texttt{matrix2} (and of course any other additional arguments).
For example, this metric measures the difference in mean between two matrices:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A simple example}
\NormalTok{mean.difference }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(matrix, matrix2) \{}
  \FunctionTok{mean}\NormalTok{(matrix) }\SpecialCharTok{{-}} \FunctionTok{mean}\NormalTok{(matrix2)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You can find the list of implemented between groups metric \protect\hyperlink{betweengroupmetricslist}{here} or design them yourself for your specific needs (potentially using \protect\hyperlink{makemetric}{\texttt{make.metric}} for help).

The function works by simply using the two available matrices, with no restriction in terms of dimensions (although you'd probably want both matrices to have the same number of dimensions)

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A second matrix}
\NormalTok{dummy\_matrix2 }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{runif}\NormalTok{(}\DecValTok{12}\NormalTok{), }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{)}

\DocumentationTok{\#\# The difference between groups}
\FunctionTok{mean.difference}\NormalTok{(dummy\_matrix, dummy\_matrix2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.5620336
\end{verbatim}

Beyond this super simple example, it might probably be interesting to use this metric on \texttt{dispRity} objects, especially the ones from \protect\hyperlink{custom-subsets}{\texttt{custom.subsets}} and \protect\hyperlink{chrono-subsets}{\texttt{chrono.subsets}}.
In fact, the \texttt{dispRity} function allows to apply the between groups metric directly to the \texttt{dispRity} objects using the \texttt{between.groups\ =\ TRUE} option.
For example:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Combining both matrices}
\NormalTok{big\_matrix }\OtherTok{\textless{}{-}} \FunctionTok{rbind}\NormalTok{(dummy\_matrix, dummy\_matrix2)}
\FunctionTok{rownames}\NormalTok{(big\_matrix) }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{8}

\DocumentationTok{\#\# Making a dispRity object with both groups}
\NormalTok{grouped\_matrix }\OtherTok{\textless{}{-}} \FunctionTok{custom.subsets}\NormalTok{(big\_matrix,}
                                 \AttributeTok{group =} \FunctionTok{c}\NormalTok{(}\FunctionTok{list}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{), }\FunctionTok{list}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{)))}

\DocumentationTok{\#\# Calculating the mean difference between groups}
\NormalTok{(mean\_differences }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(grouped\_matrix,}
                              \AttributeTok{metric =}\NormalTok{ mean.difference,}
                              \AttributeTok{between.groups =} \ConstantTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 2 customised subsets for 8 elements in one matrix with 3 dimensions:
##     1, 2.
## Disparity was calculated as: mean.difference between groups.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Summarising the object}
\FunctionTok{summary}\NormalTok{(mean\_differences)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n_1 n_2 obs
## 1     1:2   4   4   0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Note how the summary table now indicates}
\DocumentationTok{\#\# the number of elements for each group}
\end{Highlighting}
\end{Shaded}

For \texttt{dispRity} objects generated by \texttt{custom.subsets}, the \texttt{dispRity} function will by default apply the metric on the groups in a pairwise fashion.
For example, if the object contains multiple groups, all groups will be compared to each other:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A dispRity object with multiple groups}
\NormalTok{grouped\_matrix }\OtherTok{\textless{}{-}} \FunctionTok{custom.subsets}\NormalTok{(big\_matrix,}
                                 \AttributeTok{group =} \FunctionTok{c}\NormalTok{(}\StringTok{"A"} \OtherTok{=} \FunctionTok{list}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{),}
                                           \StringTok{"B"} \OtherTok{=} \FunctionTok{list}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{),}
                                           \StringTok{"C"} \OtherTok{=} \FunctionTok{list}\NormalTok{(}\DecValTok{2}\SpecialCharTok{:}\DecValTok{6}\NormalTok{), }
                                           \StringTok{"D"} \OtherTok{=} \FunctionTok{list}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{8}\NormalTok{)))}

\DocumentationTok{\#\# Measuring disparity between all groups}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(grouped\_matrix, }\AttributeTok{metric =}\NormalTok{ mean.difference,}
                 \AttributeTok{between.groups =} \ConstantTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n_1 n_2    obs
## 1     A:B   4   4  0.000
## 2     A:C   4   5 -0.269
## 3     A:D   4   8 -0.281
## 4     B:C   4   5 -0.269
## 5     B:D   4   8 -0.281
## 6     C:D   5   8 -0.012
\end{verbatim}

For \texttt{dispRity} objects generated by \texttt{chrono.subsets} (not shown here), the \texttt{dispRity} function will by default apply the metric on the groups in a serial way (group 1 vs.~group 2, group 2 vs.~group 3, group 3 vs.~group 4, etc\ldots).
However, in both cases (for objects from \texttt{custom.subsets} or \texttt{chrono.subsets}) it is possible to manually specific the list of pairs of comparisons through their ID numbers:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring disparity between specific groups}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(grouped\_matrix, }\AttributeTok{metric =}\NormalTok{ mean.difference,}
                 \AttributeTok{between.groups =} \FunctionTok{list}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{1}\NormalTok{))))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n_1 n_2    obs
## 1     A:C   4   5 -0.269
## 2     C:A   5   4  0.269
## 3     D:A   8   4  0.281
\end{verbatim}

Note that in any case, the order of the comparison can matter.
In our example, it is obvious that \texttt{mean(matrix)\ -\ mean(matrix2)} is not the same as \texttt{mean(matrix2)\ -\ mean(matrix)}.

\hypertarget{makemetric}{%
\subsection{\texorpdfstring{\texttt{make.metric}}{make.metric}}\label{makemetric}}

Of course, functions can be more complex and involve multiple operations such as the \texttt{centroids} function (see \texttt{?dispRity.metric}) that calculates the Euclidean distance between each element and the centroid of the ordinated space.
The \texttt{make.metric} function implemented in \texttt{dispRity} is designed to help test and find the dimension-level of the functions.
This function tests:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  If your function can deal with a \texttt{matrix} or a \texttt{vector} as an input;
\item
  Your function's dimension-level according to its output (dimension-level 1, 2 or 3, see above);
\item
  Whether the function can be implemented in the \texttt{dispRity} function (the function is fed into a \texttt{lapply} loop).
\end{enumerate}

For example, let's see if the functions described above are the right dimension-levels:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Which dimension{-}level is the mean function?}
\DocumentationTok{\#\# And can it be used in dispRity?}
\FunctionTok{make.metric}\NormalTok{(mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## mean outputs a single value.
## mean is detected as being a dimension-level 1 function.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Which dimension{-}level is the prod.rows function?}
\DocumentationTok{\#\# And can it be used in dispRity?}
\FunctionTok{make.metric}\NormalTok{(prod.rows)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## prod.rows outputs a matrix object.
## prod.rows is detected as being a dimension-level 2 function.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Which dimension{-}level is the var function?}
\DocumentationTok{\#\# And can it be used in dispRity?}
\FunctionTok{make.metric}\NormalTok{(var)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## var outputs a matrix object.
## var is detected as being a dimension-level 3 function.
## Additional dimension-level 2 and/or 1 function(s) will be needed.
\end{verbatim}

A non verbose version of the function is also available.
This can be done using the option \texttt{silent\ =\ TRUE} and will simply output the dimension-level of the metric.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Testing whether mean is dimension{-}level 1}
\ControlFlowTok{if}\NormalTok{(}\FunctionTok{make.metric}\NormalTok{(mean, }\AttributeTok{silent =} \ConstantTok{TRUE}\NormalTok{)}\SpecialCharTok{$}\NormalTok{type }\SpecialCharTok{!=} \StringTok{"level1"}\NormalTok{) \{}
    \FunctionTok{message}\NormalTok{(}\StringTok{"The metric is not dimension{-}level 1."}\NormalTok{)}
\NormalTok{\}}
\DocumentationTok{\#\# Testing whether var is dimension{-}level 1}
\ControlFlowTok{if}\NormalTok{(}\FunctionTok{make.metric}\NormalTok{(var, }\AttributeTok{silent =} \ConstantTok{TRUE}\NormalTok{)}\SpecialCharTok{$}\NormalTok{type }\SpecialCharTok{!=} \StringTok{"level1"}\NormalTok{) \{}
    \FunctionTok{message}\NormalTok{(}\StringTok{"The metric is not dimension{-}level 1."}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## The metric is not dimension-level 1.
\end{verbatim}

\hypertarget{metrics-in-the-disprity-function}{%
\subsection{\texorpdfstring{Metrics in the \texttt{dispRity} function}{Metrics in the dispRity function}}\label{metrics-in-the-disprity-function}}

Using this metric structure, we can easily use any disparity metric in the \texttt{dispRity} function as follows:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring disparity as the standard deviation}
\DocumentationTok{\#\# of all the values of the}
\DocumentationTok{\#\# ordinated matrix (dimension{-}level 1 function).}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(BeckLee\_mat50, }\AttributeTok{metric =}\NormalTok{ sd))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 50 0.227
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring disparity as the standard deviation}
\DocumentationTok{\#\# of the variance of each axis of}
\DocumentationTok{\#\# the ordinated matrix (dimension{-}level 1 and 2 functions).}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(BeckLee\_mat50, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sd, variances)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 50 0.032
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring disparity as the standard deviation}
\DocumentationTok{\#\# of the variance of each axis of}
\DocumentationTok{\#\# the variance covariance matrix (dimension{-}level 1, 2 and 3 functions).}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(BeckLee\_mat50, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sd, variances, var)), }\AttributeTok{round =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs
## 1       1 50   0
\end{verbatim}

Note that the order of each function in the metric argument does not matter, the \texttt{dispRity} function will automatically detect the function dimension-levels (using \texttt{make.metric}) and apply them to the data in decreasing order (dimension-level 3 \textgreater{} 2 \textgreater{} 1).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Disparity as the standard deviation of the variance of each axis of the}
\DocumentationTok{\#\# variance covariance matrix:}
\NormalTok{disparity1 }\OtherTok{\textless{}{-}} \FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(BeckLee\_mat50,}
                               \AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sd, variances, var)),}
                      \AttributeTok{round =} \DecValTok{10}\NormalTok{)}

\DocumentationTok{\#\# Same as above but using a different function order for the metric argument}
\NormalTok{disparity2 }\OtherTok{\textless{}{-}} \FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(BeckLee\_mat50,}
                               \AttributeTok{metric =} \FunctionTok{c}\NormalTok{(variances, sd, var)),}
                      \AttributeTok{round =} \DecValTok{10}\NormalTok{)}

\DocumentationTok{\#\# Both ways output the same disparity values:}
\NormalTok{disparity1 }\SpecialCharTok{==}\NormalTok{ disparity2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      subsets    n  obs
## [1,]    TRUE TRUE TRUE
\end{verbatim}

In these examples, we considered disparity to be a single value.
For example, in the previous example, we defined disparity as the standard deviation of the variances of each column of the variance/covariance matrix (\texttt{metric\ =\ c(variances,\ sd,\ var)}).
It is, however, possible to calculate \protect\hyperlink{disparity-as-a-distribution}{disparity as a distribution}.

\hypertarget{metrics-implemented-in-disprity}{%
\subsection{\texorpdfstring{Metrics implemented in \texttt{dispRity}}{Metrics implemented in dispRity}}\label{metrics-implemented-in-disprity}}

Several disparity metrics are implemented in the \texttt{dispRity} package.
The detailed list can be found in \texttt{?dispRity.metric} along with some description of each metric.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.0845}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.0845}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.7183}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.1127}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Level
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Name
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Source
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2 & \texttt{ancestral.dist} & The distance between an element and its ancestor & \texttt{dispRity} \\
2 & \texttt{angles} & The angle of main variation of each dimensions & \texttt{dispRity} \\
2 & \texttt{centroids}1 & The distance between each element and the centroid of the ordinated space & \texttt{dispRity} \\
1 & \texttt{convhull.surface} & The surface of the convex hull formed by all the elements & \href{https://cran.r-project.org/web/packages/geometry/index.html}{\texttt{geometry}}\texttt{::convhulln\$area} \\
1 & \texttt{convhull.volume} & The volume of the convex hull formed by all the elements & \href{https://cran.r-project.org/web/packages/geometry/index.html}{\texttt{geometry}}\texttt{::convhulln\$vol} \\
2 & \texttt{count.neighbours} & The number of neigbhours to each element in a specified radius & \texttt{dispRity} \\
2 & \texttt{deviations} & The minimal distance between each element and a hyperplane & \texttt{dispRity} \\
1 & \texttt{diagonal} & The longest distance in the ordinated space (like the diagonal in two dimensions) & \texttt{dispRity} \\
1 & \texttt{disalignment} & The rejection of the centroid of a matrix from the major axis of another (typically an \texttt{"as.covar"} metric) & \texttt{dispRity} \\
2 & \texttt{displacements} & The ratio between the distance from a reference and the distance from the centroid & \texttt{dispRity} \\
1 & \texttt{edge.length.tree} & The edge lengths of the elements on a tree & \texttt{ape} \\
1 & \texttt{ellipsoid.volume}1 & The volume of the ellipsoid of the space & Donohue \emph{et al.} (2013) \\
1 & \texttt{func.div} & The functional divergence (the ratio of deviation from the centroid) & \texttt{dispRity} (similar to \href{https://cran.r-project.org/web/packages/FD/index.html}{\texttt{FD}}\texttt{::dbFD\$FDiv} but without abundance) \\
1 & \texttt{func.eve} & The functional evenness (the minimal spanning tree distances evenness) & \texttt{dispRity} (similar to \href{https://cran.r-project.org/web/packages/FD/index.html}{\texttt{FD}}\texttt{::dbFD\$FEve} but without abundance) \\
1 & \texttt{group.dist} & The distance between two groups & \texttt{dispRity} \\
1 & \texttt{mode.val} & The modal value & \texttt{dispRity} \\
1 & \texttt{n.ball.volume} & The hyper-spherical (\emph{n}-ball) volume & \texttt{dispRity} \\
2 & \texttt{neighbours} & The distance to specific neighbours (e.g.~the nearest neighbours - by default) & \texttt{dispRity} \\
2 & \texttt{pairwise.dist} & The pairwise distances between elements & \href{https://cran.r-project.org/web/packages/vegan/index.html}{\texttt{vegan}}\texttt{::vegist} \\
2 & \texttt{point.dist} & The distance between one group and the point of another group & \texttt{dispRity} \\
2 & \texttt{projections} & The distance \emph{on} (projection) or \emph{from} (rejection) an arbitrary vector & \texttt{dispRity} \\
1 & \texttt{projections.between} & \texttt{projections} metric applied between groups & \texttt{dispRity} \\
2 & \texttt{projections.tree} & The \texttt{projections} metric but where the vector can be based on a tree & \texttt{dispRity} \\
2 & \texttt{quantiles} & The \emph{n}th quantile range per axis & \texttt{dispRity} \\
2 & \texttt{radius} & The radius of each dimensions & \texttt{dispRity} \\
2 & \texttt{ranges} & The range of each dimension & \texttt{dispRity} \\
1 & \texttt{roundness} & The integral of the ranked scaled eigenvalues of a variance-covariance matrix & \texttt{dispRity} \\
2 & \texttt{span.tree.length} & The minimal spanning tree length & \href{https://cran.r-project.org/web/packages/vegan/index.html}{\texttt{vegan}}\texttt{::spantree} \\
2 & \texttt{variances} & The variance of each dimension & \texttt{dispRity} \\
\end{longtable}

1: Note that by default, the centroid is the centroid of the elements.
It can, however, be fixed to a different value by using the \texttt{centroid} argument \texttt{centroids(space,\ centroid\ =\ rep(0,\ ncol(space)))}, for example the origin of the ordinated space.

2: This function uses an estimation of the eigenvalue that only works for MDS or PCoA ordinations (\emph{not} PCA).

You can find more informations on the vast variety of metrics that you can use in your analysis in this \href{https://onlinelibrary.wiley.com/doi/10.1002/ece3.6452}{paper}.

\hypertarget{equations-and-implementations}{%
\subsection{Equations and implementations}\label{equations-and-implementations}}

Some of the functions described below are implemented in the \texttt{dispRity} package and do not require any other packages to calculate (\href{https://github.com/TGuillerme/dispRity/blob/master/R/dispRity.metric.R}{see implementation here}).

\begin{equation}
    ancestral.dist = \sqrt{\sum_{i=1}^{n}{({d}_{n}-Ancestor_{n})^2}}
\end{equation}

\begin{equation}
    centroids = \sqrt{\sum_{i=1}^{n}{({d}_{n}-Centroid_{d})^2}}
\end{equation}

\begin{equation}
    diagonal = \sqrt{\sum_{i=1}^{d}|max(d_i) - min(k_i)|}
\end{equation}

\begin{equation}
    deviations = \frac{|Ax + By + ... + Nm + Intercept|}{\sqrt{A^2 + B^2 + ... + N^2}}
\end{equation}

\begin{equation}
    displacements = \frac{\sqrt{\sum_{i=1}^{n}{({d}_{n}-Reference_{d})^2}}}{\sqrt{\sum_{i=1}^{n}{({d}_{n}-Centroid_{k})^2}}}
\end{equation}

\begin{equation}
    ellipsoid.volume = \frac{\pi^{d/2}}{\Gamma(\frac{d}{2}+1)}\displaystyle\prod_{i=1}^{d} (\lambda_{i}^{0.5})
\end{equation}

\begin{equation}
    n.ball.volume = \frac{\pi^{d/2}}{\Gamma(\frac{d}{2}+1)}\displaystyle\prod_{i=1}^{d} R
\end{equation}

\begin{equation}
    projection_{on} = \| \overrightarrow{i} \cdot \overrightarrow{b} \|
\end{equation}
\begin{equation}
    projection_{from} = \| \overrightarrow{i} - \overrightarrow{i} \cdot \overrightarrow{b} \|
\end{equation}

\begin{equation}
    radius = |\frac{\sum_{i=1}^{n}d_i}{n} - f(\mathbf{v}d)|
\end{equation}

\begin{equation}
    ranges = |max(d_i) - min(d_i)|
\end{equation}

\begin{equation}
    roundness = \int_{i = 1}^{n}{\frac{\lambda_{i}}{\text{max}(\lambda)}}
\end{equation}

\begin{equation}
    variances = \sigma^{2}{d_i}
\end{equation}

\begin{equation}
    span.tree.length = \mathrm{branch\ length}
\end{equation}

Where \emph{d} is the number of dimensions,
\emph{n} the number of elements,
\(\Gamma\) is the Gamma distribution,
\(\lambda_i\) is the eigenvalue of each dimensions,
\(\sigma^{2}\) is their variance and
\(Centroid_{k}\) is their mean,
\(Ancestor_{n}\) is the coordinates of the ancestor of element \(n\),
\(f(\mathbf{v}k)\) is function to select one value from the vector \(\mathbf{v}\) of the dimension \(k\) (e.g.~it's maximum, minimum, mean, etc.),
\emph{R} is the radius of the sphere or the product of the radii of each dimensions (\(\displaystyle\prod_{i=1}^{k}R_{i}\) - for a hyper-ellipsoid),
\(Reference_{k}\) is an arbitrary point's coordinates (usually 0),
\(\overrightarrow{b}\) is the vector defined by (\texttt{(point1,\ point2)}),
and \(\overrightarrow{i}\) is the vector defined by (\texttt{(point1,\ i)} where \texttt{i} is any row of the matrix).

\hypertarget{using-the-different-disparity-metrics}{%
\subsection{Using the different disparity metrics}\label{using-the-different-disparity-metrics}}

Here is a brief demonstration of the main metrics implemented in \texttt{dispRity}.
First, we will create a dummy/simulated ordinated space using the \texttt{space.maker} utility function (more about that \protect\hyperlink{space.maker}{here}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating a 10*5 normal space}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{dummy\_space }\OtherTok{\textless{}{-}} \FunctionTok{space.maker}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{5}\NormalTok{, rnorm)}
\FunctionTok{rownames}\NormalTok{(dummy\_space) }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}
\end{Highlighting}
\end{Shaded}

We will use this simulated space to demonstrate the different metrics.

\hypertarget{volumes-and-surface-metrics}{%
\subsubsection{Volumes and surface metrics}\label{volumes-and-surface-metrics}}

The functions \texttt{ellipsoid.volume}, \texttt{convhull.surface}, \texttt{convhull.volume} and \texttt{n.ball.volume} all measure the surface or the volume of the ordinated space occupied:

Because there is only one subset (i.e.~one matrix) in the dispRity object, the operations below are the equivalent of \texttt{metric(dummy\_space)} (with rounding).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating the ellipsoid volume}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ ellipsoid.volume))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 1.061
\end{verbatim}

\begin{quote}
WARNING: in such dummy space, this gives the estimation of the ellipsoid volume, not the real ellipsoid volume! See the cautionary note in \texttt{?ellipsoid.volume}.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating the convex hull surface}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ convhull.surface))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 11.91
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating the convex hull volume}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ convhull.volume))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 1.031
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating the convex hull volume}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ n.ball.volume))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n  obs
## 1       1 10 4.43
\end{verbatim}

The convex hull based functions are a call to the \texttt{geometry::convhulln} function with the \texttt{"FA"} option (computes total area and volume).
Also note that they are really sensitive to the size of the dataset.

\begin{quote}
Cautionary note: measuring volumes in a high number of dimensions can be strongly affected by the \href{https://en.wikipedia.org/wiki/Curse_of_dimensionality}{curse of dimensionality} that often results in near 0 disparity values. I strongly recommend reading \href{https://beta.observablehq.com/@tophtucker/theres-plenty-of-room-in-the-corners}{this really intuitive explanation} from \href{https://github.com/tophtucker}{Toph Tucker}.
\end{quote}

\hypertarget{ranges-variances-quantiles-radius-pairwise-distance-neighbours-and-counting-them-modal-value-and-diagonal}{%
\subsubsection{Ranges, variances, quantiles, radius, pairwise distance, neighbours (and counting them), modal value and diagonal}\label{ranges-variances-quantiles-radius-pairwise-distance-neighbours-and-counting-them-modal-value-and-diagonal}}

The functions \texttt{ranges}, \texttt{variances} \texttt{radius}, \texttt{pairwise.dist}, \texttt{mode.val} and \texttt{diagonal} all measure properties of the ordinated space based on its dimensional properties (they are also less affected by the ``curse of dimensionality''):

\texttt{ranges}, \texttt{variances} \texttt{quantiles} and \texttt{radius} work on the same principle and measure the range/variance/radius of each dimension:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating the ranges of each dimension in the ordinated space}
\FunctionTok{ranges}\NormalTok{(dummy\_space)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.430909 3.726481 2.908329 2.735739 1.588603
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating disparity as the distribution of these ranges}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ ranges))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      2.736 1.673 2.431 2.908 3.645
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating disparity as the sum and the product of these ranges}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, ranges)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 13.39
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(prod, ranges)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 114.5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating the variances of each dimension in the}
\DocumentationTok{\#\# ordinated space}
\FunctionTok{variances}\NormalTok{(dummy\_space)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.6093144 1.1438620 0.9131859 0.6537768 0.3549372
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating disparity as the distribution of these variances}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ variances))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median 2.5%   25%   75% 97.5%
## 1       1 10      0.654 0.38 0.609 0.913 1.121
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating disparity as the sum and}
\DocumentationTok{\#\# the product of these variances}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, variances)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 3.675
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(prod, variances)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 0.148
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating the quantiles of each dimension}
\DocumentationTok{\#\# in the ordinated space}
\FunctionTok{quantiles}\NormalTok{(dummy\_space)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.234683 3.280911 2.760855 2.461077 1.559057
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating disparity as the distribution of these variances}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ quantiles))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      2.461 1.627 2.235 2.761 3.229
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# By default, the quantile calculated is the 95\%}
\DocumentationTok{\#\# (i.e. 95\% of the data on each axis)}
\DocumentationTok{\#\# this can be changed using the option quantile:}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ quantiles, }\AttributeTok{quantile =} \DecValTok{50}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      0.967 0.899 0.951 0.991 1.089
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating the radius of each dimension in the ordinated space}
\FunctionTok{radius}\NormalTok{(dummy\_space)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.4630780 2.4635449 1.8556785 1.4977898 0.8416318
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# By default the radius is the maximum distance from the centre of}
\DocumentationTok{\#\# the dimension. It can however be changed to any function:}
\FunctionTok{radius}\NormalTok{(dummy\_space, }\AttributeTok{type =}\NormalTok{ min)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.05144054 0.14099827 0.02212226 0.17453525 0.23044528
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{radius}\NormalTok{(dummy\_space, }\AttributeTok{type =}\NormalTok{ mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.6233501 0.7784888 0.7118713 0.6253263 0.5194332
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating disparity as the mean average radius}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space,}
                 \AttributeTok{metric =} \FunctionTok{c}\NormalTok{(mean, radius),}
                 \AttributeTok{type =}\NormalTok{ mean))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 0.652
\end{verbatim}

The pairwise distances and the neighbours distances uses the function \texttt{vegan::vegdist} and can take the normal \texttt{vegdist} options:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The average pairwise euclidean distance}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(mean, pairwise.dist)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 2.539
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The distribution of the Manhattan distances}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ pairwise.dist,}
                 \AttributeTok{method =} \StringTok{"manhattan"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      4.427 2.566 3.335 5.672  9.63
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The average nearest neighbour distances}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ neighbours))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      1.517 1.266 1.432 1.646 2.787
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The average furthest neighbour manhattan distances}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ neighbours,}
                 \AttributeTok{which =}\NormalTok{ max, }\AttributeTok{method =} \StringTok{"manhattan"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median 2.5%   25%   75% 97.5%
## 1       1 10      7.895 6.15 6.852 9.402 10.99
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The overall number of neighbours per point}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ count.neighbours,}
                 \AttributeTok{relative =} \ConstantTok{FALSE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%  25% 75% 97.5%
## 1       1 10        6.5 0.675 4.25   7 7.775
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The relative number of neigbhours}
\DocumentationTok{\#\# two standard deviations of each element}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ count.neighbours,}
                 \AttributeTok{radius =} \ControlFlowTok{function}\NormalTok{(x)(}\FunctionTok{sd}\NormalTok{(x)}\SpecialCharTok{*}\DecValTok{2}\NormalTok{),}
                 \AttributeTok{relative =} \ConstantTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5% 25% 75% 97.5%
## 1       1 10       0.55 0.068 0.3 0.7   0.7
\end{verbatim}

Note that this function is a direct call to \texttt{vegan::vegdist(matrix,\ method\ =\ method,\ diag\ =\ FALSE,\ upper\ =\ FALSE,\ ...)}.

The \texttt{diagonal} function measures the multidimensional diagonal of the whole space (i.e.~in our case the longest Euclidean distance in our five dimensional space).
The \texttt{mode.val} function measures the modal value of the matrix:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating the ordinated space\textquotesingle{}s diagonal}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ diagonal))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 3.659
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating the modal value of the matrix}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ mode.val))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 -2.21
\end{verbatim}

\begin{quote}
This metric is only a Euclidean diagonal (mathematically valid) if the dimensions within the space are all orthogonal!
\end{quote}

\hypertarget{centroids}{%
\subsubsection{Centroids, displacements and ancestral distances metrics}\label{centroids}}

The \texttt{centroids} metric allows users to measure the position of the different elements compared to a fixed point in the ordinated space.
By default, this function measures the distance between each element and their centroid (centre point):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The distribution of the distances between each element and their centroid}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ centroids))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      1.435 0.788 1.267 1.993 3.167
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Disparity as the median value of these distances}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(median, centroids)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 1.435
\end{verbatim}

It is however possible to fix the coordinates of the centroid to a specific point in the ordinated space, as long as it has the correct number of dimensions:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The distance between each element and the origin}
\DocumentationTok{\#\# of the ordinated space}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ centroids, }\AttributeTok{centroid =} \DecValTok{0}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5% 25%   75% 97.5%
## 1       1 10      1.487 0.785 1.2 2.044 3.176
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Disparity as the distance between each element}
\DocumentationTok{\#\# and a specific point in space}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ centroids,}
                 \AttributeTok{centroid =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      5.489 4.293 5.032 6.155 6.957
\end{verbatim}

If you have subsets in your \texttt{dispRity} object, you can also use the \texttt{matrix.dispRity} (see \protect\hyperlink{utilities}{utilities}) and \texttt{colMeans} to get the centre of a specific subgroup.
For example

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Create a custom subsets object}
\NormalTok{dummy\_groups }\OtherTok{\textless{}{-}} \FunctionTok{custom.subsets}\NormalTok{(dummy\_space,}
                               \AttributeTok{group =} \FunctionTok{list}\NormalTok{(}\StringTok{"group1"} \OtherTok{=} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{,}
                                            \StringTok{"group2"} \OtherTok{=} \DecValTok{6}\SpecialCharTok{:}\DecValTok{10}\NormalTok{))}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_groups, }\AttributeTok{metric =}\NormalTok{ centroids,}
    \AttributeTok{centroid =} \FunctionTok{colMeans}\NormalTok{(}\FunctionTok{get.matrix}\NormalTok{(dummy\_groups, }\StringTok{"group1"}\NormalTok{))))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n obs.median  2.5%   25%   75% 97.5%
## 1  group1 5      2.011 0.902 1.389 2.284 3.320
## 2  group2 5      1.362 0.760 1.296 1.505 1.985
\end{verbatim}

The \texttt{displacements} distance is the ratio between the \texttt{centroids} distance and the \texttt{centroids} distance with \texttt{centroid\ =\ 0}.
Note that it is possible to measure a ratio from another point than \texttt{0} using the \texttt{reference} argument.
It gives indication of the relative displacement of elements in the multidimensional space: a score \textgreater1 signifies a displacement \emph{away} from the reference. A score of \textgreater1 signifies a displacement \emph{towards} the reference.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The relative displacement of the group in space to the centre}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ displacements))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25% 75% 97.5%
## 1       1 10      1.014 0.841 0.925 1.1 1.205
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The relative displacement of the group to an arbitrary point}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ displacements,}
                 \AttributeTok{reference =} \FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%  25%   75% 97.5%
## 1       1 10      3.368 2.066 3.19 4.358 7.166
\end{verbatim}

The \texttt{ancestral.dist} metric works on a similar principle as the \texttt{centroids} function but changes the centroid to be the coordinates of each element's ancestor (if \texttt{to.root\ =\ FALSE}; default) or to the root of the tree (\texttt{to.root\ =\ TRUE}).
Therefore this function needs a matrix that contains tips and nodes and a tree as additional argument.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A generating a random tree with node labels}
\NormalTok{my\_tree }\OtherTok{\textless{}{-}} \FunctionTok{makeNodeLabel}\NormalTok{(}\FunctionTok{rtree}\NormalTok{(}\DecValTok{5}\NormalTok{), }\AttributeTok{prefix =} \StringTok{"n"}\NormalTok{)}
\DocumentationTok{\#\# Adding the tip and node names to the matrix}
\NormalTok{dummy\_space2 }\OtherTok{\textless{}{-}}\NormalTok{ dummy\_space[}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{,]}
\FunctionTok{rownames}\NormalTok{(dummy\_space2) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(my\_tree}\SpecialCharTok{$}\NormalTok{tip.label,}
\NormalTok{                            my\_tree}\SpecialCharTok{$}\NormalTok{node.label)}

\DocumentationTok{\#\# Calculating the distances from the ancestral nodes}
\NormalTok{ancestral\_dist }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(dummy\_space2, }\AttributeTok{metric =}\NormalTok{ ancestral.dist,}
                           \AttributeTok{tree =}\NormalTok{ my\_tree)}

\DocumentationTok{\#\# The ancestral distances distributions}
\FunctionTok{summary}\NormalTok{(ancestral\_dist)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n obs.median  2.5%   25%   75% 97.5%
## 1       1 9      2.193 0.343 1.729 2.595 3.585
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating disparity as the sum of the distances from all the ancestral nodes}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(ancestral\_dist, }\AttributeTok{metric =}\NormalTok{ sum))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n   obs
## 1       1 9 18.93
\end{verbatim}

\hypertarget{minimal-spanning-tree-length}{%
\subsubsection{Minimal spanning tree length}\label{minimal-spanning-tree-length}}

The \texttt{span.tree.length} uses the \texttt{vegan::spantree} function to heuristically calculate the minimum spanning tree (the shortest multidimensional tree connecting each elements) and calculates its length as the sum of every branch lengths.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The length of the minimal spanning tree}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, span.tree.length)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n  obs
## 1       1 10 15.4
\end{verbatim}

Note that because the solution is heuristic, this metric can take a long time to compute for big matrices.

\hypertarget{functional-divergence-and-evenness}{%
\subsubsection{Functional divergence and evenness}\label{functional-divergence-and-evenness}}

The \texttt{func.div} and \texttt{func.eve} functions are based on the \texttt{FD::dpFD} package.
They are the equivalent to \texttt{FD::dpFD(matrix)\$FDiv} and \texttt{FD::dpFD(matrix)\$FEve} but a bit faster (since they don't deal with abundance data).
They are pretty straightforward to use:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The ratio of deviation from the centroid }
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ func.div))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 0.747
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The minimal spanning tree distances evenness}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ func.eve))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 0.898
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The minimal spanning tree manhanttan distances evenness}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ func.eve,}
                 \AttributeTok{method =} \StringTok{"manhattan"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1       1 10 0.913
\end{verbatim}

\hypertarget{orientation-angles-and-deviations}{%
\subsubsection{Orientation: angles and deviations}\label{orientation-angles-and-deviations}}

The \texttt{angles} performs a least square regression (via the \texttt{lm} function) and returns slope of the main axis of variation for each dimension. This slope can be converted into different units, \texttt{"slope"}, \texttt{"degree"} (the default) and \texttt{"radian"}. This can be changed through the \texttt{unit} argument.
By default, the angle is measured from the slope 0 (the horizontal line in a 2D plot) but this can be changed through the \texttt{base} argument (using the defined \texttt{unit}):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The distribution of each angles in degrees for each}
\DocumentationTok{\#\# main axis in the matrix}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ angles))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      21.26 -39.8 3.723 39.47    56
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The distribution of slopes deviating from the 1:1 slope:}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ angles, }\AttributeTok{unit =} \StringTok{"slope"}\NormalTok{,}
                 \AttributeTok{base =} \DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      1.389 0.118 1.065 1.823 2.514
\end{verbatim}

The \texttt{deviations} function is based on a similar algorithm as above but measures the deviation from the main axis (or hyperplane) of variation.
In other words, it finds the least square line (for a 2D dataset), plane (for a 3D dataset) or hyperplane (for a \textgreater3D dataset) and measures the shortest distances between every points and the line/plane/hyperplane.
By default, the hyperplane is fitted using the least square algorithm from \texttt{stats::glm}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The distribution of the deviation of each point}
\DocumentationTok{\#\# from the least square hyperplane}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ deviations))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median 2.5%   25%   75% 97.5%
## 1       1 10      0.274 0.02 0.236 0.453 0.776
\end{verbatim}

It is also possible to specify the hyperplane equation through the \texttt{hyperplane} equation. The equation must contain the intercept first and then all the slopes and is interpreted as \(intercept + Ax + By + ... + Nd = 0\). For example, a 2 line defined as beta + intercept (e.g.~\(y = 2x + 1\)) should be defined as \texttt{hyperplane\ =\ c(1,\ 2,\ 1)} (\(2x - y + 1 = 0\)).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The distribution of the deviation of each point}
\DocumentationTok{\#\# from a slope (with only the two first dimensions)}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space[, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{)], }\AttributeTok{metric =}\NormalTok{ deviations,}
                 \AttributeTok{hyperplane =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      0.516 0.038 0.246 0.763  2.42
\end{verbatim}

Since both the functions \texttt{angles} and \texttt{deviations} effectively run a \texttt{lm} or \texttt{glm} to estimate slopes or hyperplanes, it is possible to use the option \texttt{significant\ =\ TRUE} to only consider slopes or intercepts that have a slope significantly different than zero using an \texttt{aov} with a significant threshold of \(p = 0.05\).
Note that depending on your dataset, using and \texttt{aov} could be completely inappropriate!
In doubt, it's probably better to enter your \texttt{base} (for \texttt{angles}) or your \texttt{hyperplane} (for \texttt{deviations}) manually so you're sure you know what the function is measuring.

\hypertarget{projections}{%
\subsubsection{Projections and phylo projections: elaboration and exploration}\label{projections}}

The \texttt{projections} metric calculates the geometric projection and corresponding rejection of all the rows in a matrix on an arbitrary vector (respectively the distance \emph{on} and the distance \emph{from} that vector). The function is based on \citet{aguilera2004}'s n-dimensional rotation algorithm to use linear algebra in mutidimensional spaces. The projection or rejection can be seen as respectively the elaboration and exploration scores on a trajectory (\emph{sensu} \citet{endler2005}).

By default, the vector (e.g.~a trajectory, an axis), on which the data is projected is the one going from the centre of the space (coordinates 0,0, \ldots) and the centroid of the matrix.
However, we advice you do define this axis to something more meaningful using the \texttt{point1} and \texttt{point2} options, to create the vector (the vector's norm will be \texttt{dist(point1,\ point2)} and its direction will be from \texttt{point1} towards \texttt{point2}).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The elaboration on the axis defined by the first and}
\DocumentationTok{\#\# second row in the dummy\_space}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ projections,}
                              \AttributeTok{point1 =}\NormalTok{ dummy\_space[}\DecValTok{1}\NormalTok{,],}
                              \AttributeTok{point2 =}\NormalTok{ dummy\_space[}\DecValTok{2}\NormalTok{,]))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10      0.998 0.118 0.651 1.238 1.885
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The exploration on the same axis}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ projections,}
                              \AttributeTok{point1 =}\NormalTok{ dummy\_space[}\DecValTok{1}\NormalTok{,],}
                              \AttributeTok{point2 =}\NormalTok{ dummy\_space[}\DecValTok{2}\NormalTok{,],}
                              \AttributeTok{measure =} \StringTok{"distance"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median 2.5%   25%   75% 97.5%
## 1       1 10      0.719    0 0.568 0.912  1.65
\end{verbatim}

By default, the vector \texttt{(point1,\ point2)} is used as unit vector of the projections (i.e.~the Euclidean distance between \texttt{(point1,\ point2)} is set to 1) meaning that a projection value (\texttt{"distance"} or \texttt{"position"}) of \emph{X} means \emph{X} times the distance between \texttt{point1} and \texttt{point2}.
If you want use the unit vector of the input matrix or are using a space where Euclidean distances are non-sensical, you can remove this option using \texttt{scale\ =\ FALSE}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The elaboration on the same axis using the dummy\_space\textquotesingle{}s}
\DocumentationTok{\#\# unit vector}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(dummy\_space, }\AttributeTok{metric =}\NormalTok{ projections,}
                              \AttributeTok{point1 =}\NormalTok{ dummy\_space[}\DecValTok{1}\NormalTok{,],}
                              \AttributeTok{point2 =}\NormalTok{ dummy\_space[}\DecValTok{2}\NormalTok{,],}
                              \AttributeTok{scale =} \ConstantTok{FALSE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%  75% 97.5%
## 1       1 10      4.068 0.481 2.655 5.05 7.685
\end{verbatim}

The \texttt{projections.tree} is the same as the \texttt{projections} metric but allows to determine the vector (\texttt{(point1,\ point2)}) using a tree rather than manually entering these points.
The function intakes the exact same options as the \texttt{projections} function described above at the exception of \texttt{point1} and \texttt{point2}.
Instead it takes a the argument \texttt{type} that designates the type of vector to draw from the data based on a phylogenetic tree \texttt{phy}.
The argument \texttt{type} can be a pair of any of the following inputs:

\begin{itemize}
\tightlist
\item
  \texttt{"root"}: to automatically use the coordinates of the root of the tree (the first element in \texttt{phy\$node.label});
\item
  \texttt{"ancestor"}: to automatically use the coordinates of the elements' (i.e.~any row in the matrix) most recent ancestor;
\item
  \texttt{"tips"}: to automatically use the coordinates from the centroid of all tips;
\item
  \texttt{"nodes"}: to automatically use the coordinates from the centroid of all nodes;
\item
  \texttt{"livings"}: to automatically use the coordinates from the centroid of all ``living'' tips (i.e.~the tips that are the furthest away from the root);
\item
  \texttt{"fossils"}: to automatically use the coordinates from the centroid of all ``fossil'' tips and nodes (i.e.~not the ``living'' ones);
\item
  any numeric values that can be interpreted as \texttt{point1} and \texttt{point2} in \texttt{projections} (e.g.~\texttt{0}, \texttt{c(0,\ 1.2,\ 3/4)}, etc.);
\item
  or a user defined function that with the inputs \texttt{matrix} and \texttt{phy} and \texttt{row} (the element's ID, i.e.~the row number in \texttt{matrix}).
\end{itemize}

For example, if you want to measure the projection of each element in the matrix (tips and nodes) on the axis from the root of the tree to each element's most recent ancestor, you can define the vector as \texttt{type\ =\ c("root",\ "ancestor")}.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Adding a extra row to dummy matrix (to match dummy\_tree)}
\NormalTok{tree\_space }\OtherTok{\textless{}{-}} \FunctionTok{rbind}\NormalTok{(dummy\_space, }\AttributeTok{root =} \FunctionTok{rnorm}\NormalTok{(}\DecValTok{5}\NormalTok{))}
\DocumentationTok{\#\# Creating a random dummy tree (with labels matching the ones from tree\_space)}
\NormalTok{dummy\_tree }\OtherTok{\textless{}{-}} \FunctionTok{rtree}\NormalTok{(}\DecValTok{6}\NormalTok{)}
\NormalTok{dummy\_tree}\SpecialCharTok{$}\NormalTok{tip.label }\OtherTok{\textless{}{-}} \FunctionTok{rownames}\NormalTok{(tree\_space)[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{]}
\NormalTok{dummy\_tree}\SpecialCharTok{$}\NormalTok{node.label }\OtherTok{\textless{}{-}} \FunctionTok{rownames}\NormalTok{(tree\_space)[}\FunctionTok{rev}\NormalTok{(}\DecValTok{7}\SpecialCharTok{:}\DecValTok{11}\NormalTok{)]}

\DocumentationTok{\#\# Measuring the disparity as the projection of each element}
\DocumentationTok{\#\# on its root{-}ancestor vector}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(tree\_space, }\AttributeTok{metric =}\NormalTok{ projections.tree,}
                             \AttributeTok{tree   =}\NormalTok{ dummy\_tree,}
                             \AttributeTok{type   =} \FunctionTok{c}\NormalTok{(}\StringTok{"root"}\NormalTok{, }\StringTok{"ancestor"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in max(nchar(round(column)), na.rm = TRUE): no non-missing arguments to
## max; returning -Inf
## Warning in max(nchar(round(column)), na.rm = TRUE): no non-missing arguments to
## max; returning -Inf
\end{verbatim}

\begin{verbatim}
##   subsets  n obs.median 2.5%    25%   75% 97.5%
## 1       1 11         NA -0.7 -0.196 0.908 1.774
\end{verbatim}

Of course you can also use any other options from the projections function:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A user defined function that\textquotesingle{}s returns the centroid of}
\DocumentationTok{\#\# the first three nodes}
\NormalTok{fun.root }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(matrix, tree, }\AttributeTok{row =} \ConstantTok{NULL}\NormalTok{) \{}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{colMeans}\NormalTok{(matrix[tree}\SpecialCharTok{$}\NormalTok{node.label[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{], ]))}
\NormalTok{\}}
\DocumentationTok{\#\# Measuring the unscaled rejection from the vector from the}
\DocumentationTok{\#\# centroid of the three first nodes}
\DocumentationTok{\#\# to the coordinates of the first tip}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(tree\_space, }\AttributeTok{metric  =}\NormalTok{ projections.tree,}
                             \AttributeTok{tree    =}\NormalTok{ dummy\_tree,}
                             \AttributeTok{measure =} \StringTok{"distance"}\NormalTok{,}
                             \AttributeTok{type    =} \FunctionTok{list}\NormalTok{(fun.root,}
\NormalTok{                                            tree\_space[}\DecValTok{1}\NormalTok{, ])))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median 2.5%   25%   75% 97.5%
## 1       1 11      0.763 0.07 0.459 0.873 1.371
\end{verbatim}

\hypertarget{roundness}{%
\subsubsection{Roundness}\label{roundness}}

The roundness coefficient (or metric) ranges between 0 and 1 and expresses the distribution of and ellipse' major axis ranging from 1, a totally round ellipse (i.e.~a circle) to 0 a totally flat ellipse (i.e.~a line). A value of \(0.5\) represents a regular ellipse where each major axis is half the size of the previous major axis. A value \(> 0.5\) describes a pancake where the major axis distribution is convex (values close to 1 can be pictured in 3D as a cr`\{e\}pes with the first two axis being rather big - a circle - and the third axis being particularly thin; values closer to \(0.5\) can be pictured as flying saucers). Conversely, a value \(< 0.5\) describes a cigar where the major axis distribution is concave (values close to 0 can be pictured in 3D as a spaghetti with the first axis rather big and the two next ones being small; values closer to \(0.5\) can be pictured in 3D as a fat cigar).

This is what it looks for example for three simulated variance-covariance matrices in 3D:

\begin{verbatim}
## Warning in snapshot3d(scene = x, width = width, height = height): webshot =
## TRUE requires the webshot2 package and Chrome browser; using rgl.snapshot()
## instead
\end{verbatim}

\begin{verbatim}
## Warning in rgl.snapshot(filename, fmt, top): this build of rgl does not support
## snapshots
\end{verbatim}

\includegraphics[width=4in]{../../../../../../tmp/RtmpNRJYtO/filedc8b70fa877c}

\begin{verbatim}
## Warning in snapshot3d(scene = x, width = width, height = height): webshot =
## TRUE requires the webshot2 package and Chrome browser; using rgl.snapshot()
## instead
\end{verbatim}

\begin{verbatim}
## Warning in rgl.snapshot(filename, fmt, top): this build of rgl does not support
## snapshots
\end{verbatim}

\includegraphics[width=4in]{../../../../../../tmp/RtmpNRJYtO/filedc8b241ab6ff}

\begin{verbatim}
## Warning in snapshot3d(scene = x, width = width, height = height): webshot =
## TRUE requires the webshot2 package and Chrome browser; using rgl.snapshot()
## instead
\end{verbatim}

\begin{verbatim}
## Warning in rgl.snapshot(filename, fmt, top): this build of rgl does not support
## snapshots
\end{verbatim}

\includegraphics[width=4in]{../../../../../../tmp/RtmpNRJYtO/filedc8b6be23fa7}
\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-70-1.pdf}

\hypertarget{betweengroupmetricslist}{%
\subsubsection{Between group metrics}\label{betweengroupmetricslist}}

You can find detailed explanation on how between group metrics work \protect\hyperlink{betweengroupmetricsexplain}{here}.

\hypertarget{group.dist}{%
\paragraph{\texorpdfstring{\texttt{group.dist}}{group.dist}}\label{group.dist}}

The \texttt{group.dist} metric allows to measure the distance between two groups in the multidimensional space.
This function needs to intake several groups and use the option \texttt{between.groups\ =\ TRUE} in the \texttt{dispRity} function.
It calculates the vector normal distance (euclidean) between two groups and returns 0 if that distance is negative.
Note that it is possible to set up which quantiles to consider for calculating the distances between groups.
For example, one might be interested in only considering the 95\% CI for each group.
This can be done through the option \texttt{probs\ =\ c(0.025,\ 0.975)} that is passed to the \texttt{quantile} function.
It is also possible to use this function to measure the distance between the groups centroids by calculating the 50\% quantile (\texttt{probs\ =\ c(0.5)}).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating a dispRity object with two groups}
\NormalTok{grouped\_space }\OtherTok{\textless{}{-}} \FunctionTok{custom.subsets}\NormalTok{(dummy\_space,}
                      \AttributeTok{group =} \FunctionTok{list}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\DecValTok{6}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)))}

\DocumentationTok{\#\# Measuring the minimum distance between both groups}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(grouped\_space, }\AttributeTok{metric =}\NormalTok{ group.dist,}
                 \AttributeTok{between.groups =} \ConstantTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n_1 n_2 obs
## 1     1:2   5   5   0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring the centroid distance between both groups}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(grouped\_space, }\AttributeTok{metric =}\NormalTok{ group.dist,}
                 \AttributeTok{between.groups =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{probs =} \FloatTok{0.5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n_1 n_2   obs
## 1     1:2   5   5 0.708
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring the distance between both group\textquotesingle{}s 75\% CI}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(grouped\_space, }\AttributeTok{metric =}\NormalTok{ group.dist,}
                 \AttributeTok{between.groups =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{probs =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.25}\NormalTok{, }\FloatTok{0.75}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n_1 n_2   obs
## 1     1:2   5   5 0.059
\end{verbatim}

\hypertarget{point.dist}{%
\paragraph{\texorpdfstring{\texttt{point.dist}}{point.dist}}\label{point.dist}}

The metric measures the distance between the elements in one group (\texttt{matrix}) and a point calculated from a second group (\texttt{matrix2}).
By default this point is the centroid but can be any point defined by a function passed to the \texttt{point} argument.
For example, the centroid of \texttt{matrix2} is the mean of each column of that matrix so \texttt{point\ =\ colMeans} (default).
This function also takes the \texttt{method} argument like previous one described above to measure either the \texttt{"euclidean"} (default) or the \texttt{"manhattan"} distances:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring the distance between the elements of the first group}
\DocumentationTok{\#\# and the centroid of the second group}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(grouped\_space, }\AttributeTok{metric =}\NormalTok{ point.dist,}
                 \AttributeTok{between.groups =} \ConstantTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n_1 n_2 obs.median  2.5%   25%   75% 97.5%
## 1     1:2   5   5      2.182 1.304 1.592 2.191 3.355
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring the distance between the elements of the second group}
\DocumentationTok{\#\# and the centroid of the first group}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(grouped\_space, }\AttributeTok{metric =}\NormalTok{ point.dist,}
                 \AttributeTok{between.groups =} \FunctionTok{list}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{))))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n_1 n_2 obs.median 2.5%   25%   75% 97.5%
## 1     2:1   5   5      1.362 0.76 1.296 1.505 1.985
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring the distance between the elements of the first group}
\DocumentationTok{\#\# a point defined as the standard deviation of each column}
\DocumentationTok{\#\# in the second group}
\NormalTok{sd.point }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(matrix2) \{}\FunctionTok{apply}\NormalTok{(matrix2, }\DecValTok{2}\NormalTok{, sd)\}}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(grouped\_space, }\AttributeTok{metric =}\NormalTok{ point.dist,}
                 \AttributeTok{point =}\NormalTok{ sd.point, }\AttributeTok{method =} \StringTok{"manhattan"}\NormalTok{,}
                 \AttributeTok{between.groups =} \ConstantTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n_1 n_2 obs.median  2.5%   25%   75% 97.5%
## 1     1:2   5   5      4.043 2.467 3.567 4.501 6.884
\end{verbatim}

\hypertarget{projections.between-and-disalignment}{%
\paragraph{\texorpdfstring{\texttt{projections.between} and \texttt{disalignment}}{projections.between and disalignment}}\label{projections.between-and-disalignment}}

These two metrics are typically based on variance-covariance matrices from a \texttt{dispRity} object that has a \texttt{\$covar} component (see more about that \protect\hyperlink{covar}{here}).
Both are based on the \texttt{projections} metric and can take the same optional arguments (more info \protect\hyperlink{projections}{here}).
The examples and explanations below are based on the default arguments but it is possible (and easy!) to change them.

We are going to use the \texttt{charadriiformes} example for both metrics (see more about that \protect\hyperlink{covar}{here}).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading the charadriiformes data}
\FunctionTok{data}\NormalTok{(charadriiformes)}

\DocumentationTok{\#\# Creating the dispRity object (see the \#covar section in the manual for more info)}
\NormalTok{my\_covar }\OtherTok{\textless{}{-}} \FunctionTok{MCMCglmm.subsets}\NormalTok{(}\AttributeTok{n =} \DecValTok{50}\NormalTok{,}
                             \AttributeTok{data =}\NormalTok{ charadriiformes}\SpecialCharTok{$}\NormalTok{data,}
                             \AttributeTok{posteriors =}\NormalTok{ charadriiformes}\SpecialCharTok{$}\NormalTok{posteriors,}
                             \AttributeTok{group =} \FunctionTok{MCMCglmm.levels}\NormalTok{(charadriiformes}\SpecialCharTok{$}\NormalTok{posteriors)[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{],}
                             \AttributeTok{tree =}\NormalTok{ charadriiformes}\SpecialCharTok{$}\NormalTok{tree,}
                             \AttributeTok{rename.groups =} \FunctionTok{c}\NormalTok{(}\FunctionTok{levels}\NormalTok{(charadriiformes}\SpecialCharTok{$}\NormalTok{data}\SpecialCharTok{$}\NormalTok{clade), }\StringTok{"phylogeny"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

The first metric, \texttt{projections.between} projects the major axis of one group (\texttt{matrix}) onto the major axis of another one (\texttt{matrix2}).
For example we might want to know how some groups compare in terms of angle (orientation) to a base group:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating the list of groups to compare}
\NormalTok{comparisons\_list }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"gulls"}\NormalTok{, }\StringTok{"phylogeny"}\NormalTok{),}
                         \FunctionTok{c}\NormalTok{(}\StringTok{"plovers"}\NormalTok{, }\StringTok{"phylogeny"}\NormalTok{),}
                         \FunctionTok{c}\NormalTok{(}\StringTok{"sandpipers"}\NormalTok{, }\StringTok{"phylogeny"}\NormalTok{))}

\DocumentationTok{\#\# Measuring the angles between each groups}
\DocumentationTok{\#\# (note that we set the metric as.covar, more on that in the \#covar section below)}
\NormalTok{groups\_angles }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(}\AttributeTok{data =}\NormalTok{ my\_covar,}
                          \AttributeTok{metric =} \FunctionTok{as.covar}\NormalTok{(projections.between),}
                          \AttributeTok{between.groups =}\NormalTok{ comparisons\_list,}
                          \AttributeTok{measure =} \StringTok{"degree"}\NormalTok{)}
\DocumentationTok{\#\# And here are the angles in degrees:}
\FunctionTok{summary}\NormalTok{(groups\_angles)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                subsets n_1 n_2 obs.median  2.5%   25%   75% 97.5%
## 1      gulls:phylogeny 159 359       9.39 2.480  5.95 16.67  43.2
## 2    plovers:phylogeny  98 359      20.42 4.500 12.36 51.31 129.8
## 3 sandpipers:phylogeny 102 359      10.82 1.777  7.60 13.89  43.0
\end{verbatim}

The second metric, \texttt{disalignment} rejects the centroid of a group (\texttt{matrix}) onto the major axis of another one (\texttt{matrix2}).
This allows to measure wether the center of a group is aligned with the major axis of another.
A disalignement value of 0 means that the groups are aligned. A higher disalignment value means the groups are more and more disaligned.
We can use the same set of comparisons as in the \texttt{projections.between} examples to measure which group is most aligned (less disaligned) with the phylogenetic major axis:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring the disalignement of each group}
\NormalTok{groups\_alignement }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(}\AttributeTok{data =}\NormalTok{ my\_covar,}
                              \AttributeTok{metric =} \FunctionTok{as.covar}\NormalTok{(disalignment),}
                              \AttributeTok{between.groups =}\NormalTok{ comparisons\_list)}
\DocumentationTok{\#\# And here are the groups alignment (0 = aligned)}
\FunctionTok{summary}\NormalTok{(groups\_alignement)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                subsets n_1 n_2 obs.median  2.5%   25%   75% 97.5%
## 1      gulls:phylogeny 159 359      0.003 0.001 0.002 0.005 0.021
## 2    plovers:phylogeny  98 359      0.001 0.000 0.001 0.001 0.006
## 3 sandpipers:phylogeny 102 359      0.002 0.000 0.001 0.005 0.018
\end{verbatim}

\hypertarget{which-disparity-metric-to-choose}{%
\subsection{Which disparity metric to choose?}\label{which-disparity-metric-to-choose}}

The disparity metric that gives the most consistent results is the following one:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{best.metric }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() }\FunctionTok{return}\NormalTok{(}\DecValTok{42}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Joke aside, this is a legitimate question that has no simple answer: \textbf{it depends on the dataset and question at hand}.
Thoughts on which metric to choose can be find in \citet{moms} and \citet{Guillerme2020} but again, will ultimately depend on the question and dataset.
The question should help figuring out which type of metric is desired: for example, in the question ``does the extinction released niches for mammals to evolve'', the metric in interest should probably pick up a change in size in the trait space (the release could result in some expansion of the mammalian morphospace); or if the question is ``does group X compete with group Y'', maybe the metric of interested should pick up changes in position (group X can be displaced by group Y).

In order to visualise what signal different disparity metrics are picking, you can use the \href{https://tguillerme.shinyapps.io/moms/}{\texttt{moms}} that come with a detailed \href{https://rawcdn.githack.com/TGuillerme/moms/master/inst/moms_vignette.html}{manual} on how to use it.

Alternatively, you can use the \texttt{test.metric} function:

\hypertarget{test-metric}{%
\subsubsection{\texorpdfstring{\texttt{test.metric}}{test.metric}}\label{test-metric}}

This function allows to test whether a metric picks different changes in disparity. It intakes the space on which to test the metric, the disparity metric and the type of changes to apply gradually to the space.
Basically this is a type of biased data rarefaction (or non-biased for \texttt{"random"}) to see how the metric reacts to specific changes in trait space.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating a 2D uniform space}
\NormalTok{example\_space }\OtherTok{\textless{}{-}} \FunctionTok{space.maker}\NormalTok{(}\DecValTok{300}\NormalTok{, }\DecValTok{2}\NormalTok{, runif)}

\DocumentationTok{\#\# Testing the product of ranges metric on the example space}
\NormalTok{example\_test }\OtherTok{\textless{}{-}} \FunctionTok{test.metric}\NormalTok{(example\_space, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(prod, ranges),}
                           \AttributeTok{shifts =} \FunctionTok{c}\NormalTok{(}\StringTok{"random"}\NormalTok{, }\StringTok{"size"}\NormalTok{)) }
\end{Highlighting}
\end{Shaded}

By default, the test runs three replicates of space reduction as described in \citet{moms} by gradually removing 10\% of the data points following the different algorithms from \citet{moms} (here the \texttt{"random"} reduction and the \texttt{"size"}) reduction, resulting in a \texttt{dispRity} object that can be summarised or plotted.
The number of replicates can be changed using the \texttt{replicates} option.
Still by default, the function then runs a linear model on the simulated data to measure some potential trend in the changes in disparity.
The model can be changed using the \texttt{model} option.
Finally, the function runs 10 reductions by default from keeping 10\% of the data (removing 90\%) and way up to keeping 100\% of the data (removing 0\%).
This can be changed using the \texttt{steps} option.
A good disparity metric for your dataset will typically have no trend in the \texttt{"random"} reduction (the metric is ideally not affected by sample size) but should have a trend for the reduction of interest.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The results as a dispRity object}
\NormalTok{example\_test}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Metric testing:
## The following metric was tested: c(prod, ranges).
## The test was run on the random, size shifts for 3 replicates using the following model:
## lm(disparity ~ reduction, data = data)
## Use summary(x) or plot(x) for more details.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Summarising these results}
\FunctionTok{summary}\NormalTok{(example\_test)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                  10%  20%  30%  40%  50%  60%  70%  80%  90% 100%        slope
## random          0.94 0.97 0.94 0.97 0.98 0.98 0.99 0.99 0.99 0.99 6.389477e-04
## size.increase   0.11 0.21 0.38 0.54 0.68 0.79 0.87 0.93 0.98 0.99 1.040938e-02
## size.hollowness 0.98 0.99 0.99 0.99 0.99 0.99 0.99 0.99 0.99 0.99 1.880225e-05
##                      p_value  R^2(adj)
## random          5.891773e-06 0.5084747
## size.increase   4.331947e-19 0.9422289
## size.hollowness 3.073793e-03 0.2467532
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Or visualising them}
\FunctionTok{plot}\NormalTok{(example\_test)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-78-1.pdf}

\hypertarget{summarising-disprity-data-plots}{%
\section{Summarising dispRity data (plots)}\label{summarising-disprity-data-plots}}

Because of its architecture, printing \texttt{dispRity} objects only summarises their content but does not print the disparity value measured or associated analysis (more about this \protect\hyperlink{manipulating-dispRity-objects}{here}).
To actually see what is in a dispRity object, one can either use the \texttt{summary} function for visualising the data in a table or \texttt{plot} to have a graphical representation of the results.

\hypertarget{summarising-disprity-data}{%
\subsection{\texorpdfstring{Summarising \texttt{dispRity} data}{Summarising dispRity data}}\label{summarising-disprity-data}}

This function is an S3 function (\texttt{summary.dispRity}) allowing users to summarise the content of \texttt{dispRity} objects that contain disparity calculations.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Example data from previous sections}
\NormalTok{crown\_stem }\OtherTok{\textless{}{-}} \FunctionTok{custom.subsets}\NormalTok{(BeckLee\_mat50,}
                             \AttributeTok{group =} \FunctionTok{crown.stem}\NormalTok{(BeckLee\_tree,}
                             \AttributeTok{inc.nodes =} \ConstantTok{FALSE}\NormalTok{))}
\DocumentationTok{\#\# Bootstrapping and rarefying these groups}
\NormalTok{boot\_crown\_stem }\OtherTok{\textless{}{-}} \FunctionTok{boot.matrix}\NormalTok{(crown\_stem, }\AttributeTok{bootstraps =} \DecValTok{100}\NormalTok{,}
                               \AttributeTok{rarefaction =} \ConstantTok{TRUE}\NormalTok{)}
\DocumentationTok{\#\# Calculate disparity}
\NormalTok{disparity\_crown\_stem }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(boot\_crown\_stem,}
                                 \AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, variances))}

\DocumentationTok{\#\# Creating time slice subsets}
\NormalTok{time\_slices }\OtherTok{\textless{}{-}} \FunctionTok{chrono.subsets}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_mat99,}
                              \AttributeTok{tree =}\NormalTok{ BeckLee\_tree,}
                              \AttributeTok{method =} \StringTok{"continuous"}\NormalTok{,}
                              \AttributeTok{model =} \StringTok{"proximity"}\NormalTok{,}
                              \AttributeTok{time =} \FunctionTok{c}\NormalTok{(}\DecValTok{120}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{0}\NormalTok{),}
                              \AttributeTok{FADLAD =}\NormalTok{ BeckLee\_ages)}
\DocumentationTok{\#\# Bootstrapping the time slice subsets}
\NormalTok{boot\_time\_slices }\OtherTok{\textless{}{-}} \FunctionTok{boot.matrix}\NormalTok{(time\_slices, }\AttributeTok{bootstraps =} \DecValTok{100}\NormalTok{)}
\DocumentationTok{\#\# Calculate disparity}
\NormalTok{disparity\_time\_slices }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(boot\_time\_slices,}
                                  \AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, variances))}

\DocumentationTok{\#\# Creating time bin subsets}
\NormalTok{time\_bins }\OtherTok{\textless{}{-}} \FunctionTok{chrono.subsets}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_mat99,}
                            \AttributeTok{tree =}\NormalTok{ BeckLee\_tree, }
                            \AttributeTok{method =} \StringTok{"discrete"}\NormalTok{,}
                            \AttributeTok{time =} \FunctionTok{c}\NormalTok{(}\DecValTok{120}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{0}\NormalTok{),}
                            \AttributeTok{FADLAD =}\NormalTok{ BeckLee\_ages,}
                            \AttributeTok{inc.nodes =} \ConstantTok{TRUE}\NormalTok{)}
\DocumentationTok{\#\# Bootstrapping the time bin subsets}
\NormalTok{boot\_time\_bins }\OtherTok{\textless{}{-}} \FunctionTok{boot.matrix}\NormalTok{(time\_bins, }\AttributeTok{bootstraps =} \DecValTok{100}\NormalTok{)}
\DocumentationTok{\#\# Calculate disparity}
\NormalTok{disparity\_time\_bins }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(boot\_time\_bins,}
                                \AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, variances))}
\end{Highlighting}
\end{Shaded}

These objects are easy to summarise as follows:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Default summary}
\FunctionTok{summary}\NormalTok{(disparity\_time\_slices)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs bs.median  2.5%   25%   75% 97.5%
## 1     120  5 3.126     2.556 1.446 2.365 2.799 2.975
## 2      80 19 3.351     3.188 3.019 3.137 3.235 3.291
## 3      40 15 3.538     3.346 3.052 3.226 3.402 3.538
## 4       0 10 3.934     3.601 3.219 3.446 3.681 3.819
\end{verbatim}

Information about the number of elements in each subset and the observed (i.e.~non-bootstrapped) disparity are also calculated.
This is specifically handy when rarefying the data for example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(}\FunctionTok{summary}\NormalTok{(disparity\_crown\_stem))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs bs.median  2.5%   25%   75% 97.5%
## 1   crown 30 2.526     2.444 2.374 2.420 2.466 2.490
## 2   crown 29    NA     2.454 2.387 2.427 2.470 2.490
## 3   crown 28    NA     2.443 2.387 2.423 2.462 2.489
## 4   crown 27    NA     2.440 2.366 2.417 2.468 2.493
## 5   crown 26    NA     2.442 2.357 2.408 2.459 2.492
## 6   crown 25    NA     2.445 2.344 2.425 2.469 2.490
\end{verbatim}

The summary functions can also take various options such as:

\begin{itemize}
\tightlist
\item
  \texttt{quantiles} values for the confidence interval levels (by default, the 50 and 95 quantiles are calculated)
\item
  \texttt{cent.tend} for the central tendency to use for summarising the results (default is \texttt{median})
\item
  \texttt{digits} option corresponding to the number of decimal places to print (default is \texttt{2})
\item
  \texttt{recall} option for printing the call of the \texttt{dispRity} object as well (default is \texttt{FALSE})
\end{itemize}

These options can easily be changed from the defaults as follows:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Same as above but using the 88th quantile and the standard deviation as the summary }
\FunctionTok{summary}\NormalTok{(disparity\_time\_slices, }\AttributeTok{quantiles =} \DecValTok{88}\NormalTok{, }\AttributeTok{cent.tend =}\NormalTok{ sd)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs bs.sd    6%   94%
## 1     120  5 3.126 0.366 2.043 2.947
## 2      80 19 3.351 0.072 3.048 3.277
## 3      40 15 3.538 0.133 3.095 3.525
## 4       0 10 3.934 0.167 3.292 3.776
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Printing the details of the object and digits the values to the 5th decimal place}
\FunctionTok{summary}\NormalTok{(disparity\_time\_slices, }\AttributeTok{recall =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{digits =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 4 continuous (proximity) time subsets for 99 elements in one matrix with 97 dimensions with 1 phylogenetic tree
##     120, 80, 40, 0.
## Rows were bootstrapped 100 times (method:"full").
## Disparity was calculated as: c(sum, variances).
\end{verbatim}

\begin{verbatim}
##   subsets  n     obs bs.median    2.5%     25%     75%   97.5%
## 1     120  5 3.12580   2.55631 1.44593 2.36454 2.79905 2.97520
## 2      80 19 3.35072   3.18751 3.01906 3.13720 3.23534 3.29113
## 3      40 15 3.53811   3.34647 3.05242 3.22616 3.40199 3.53793
## 4       0 10 3.93353   3.60071 3.21947 3.44555 3.68095 3.81856
\end{verbatim}

Note that the summary table is a \texttt{data.frame}, hence it is as easy to modify as any dataframe using \texttt{dplyr}.
You can also export it in \texttt{csv} format using \texttt{write.csv} or \texttt{write\_csv} or even directly export into \texttt{LaTeX} format using the following;

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading the xtable package}
\FunctionTok{require}\NormalTok{(xtable)}
\DocumentationTok{\#\# Converting the table in LaTeX}
\FunctionTok{xtable}\NormalTok{(}\FunctionTok{summary}\NormalTok{(disparity\_time\_slices))}
\end{Highlighting}
\end{Shaded}

\hypertarget{plotting-disprity-data}{%
\subsection{\texorpdfstring{Plotting \texttt{dispRity} data}{Plotting dispRity data}}\label{plotting-disprity-data}}

An alternative (and more fun!) way to display the calculated disparity is to plot the results using the S3 method \texttt{plot.dispRity}.
This function takes the same options as \texttt{summary.dispRity} along with various graphical options described in the function help files (see \texttt{?plot.dispRity}).

The plots can be of five different types:

\begin{itemize}
\tightlist
\item
  \texttt{preview} for a 2d preview of the trait-space.
\item
  \texttt{continuous} for displaying continuous disparity curves
\item
  \texttt{box}, \texttt{lines}, and \texttt{polygons} to display discrete disparity results in respectively a boxplot, confidence interval lines, and confidence interval polygons.
\end{itemize}

\begin{quote}
This argument can be left empty. In this case, the algorithm will automatically detect the type of subsets from the \texttt{dispRity} object and plot accordingly.
\end{quote}

It is also possible to display the number of elements in each subset (as a horizontal dotted line) using the option \texttt{elements\ =\ TRUE}.
Additionally, when the data is rarefied, one can indicate which level of rarefaction to display (i.e.~only display the results for a certain number of elements) by using the \texttt{rarefaction} argument.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Graphical parameters}
\NormalTok{op }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{), }\AttributeTok{bty =} \StringTok{"n"}\NormalTok{)}

\DocumentationTok{\#\# Plotting continuous disparity results}
\FunctionTok{plot}\NormalTok{(disparity\_time\_slices, }\AttributeTok{type =} \StringTok{"continuous"}\NormalTok{)}

\DocumentationTok{\#\# Plotting discrete disparity results}
\FunctionTok{plot}\NormalTok{(disparity\_crown\_stem, }\AttributeTok{type =} \StringTok{"box"}\NormalTok{)}

\DocumentationTok{\#\# As above but using lines for the rarefaction level of 20 elements only}
\FunctionTok{plot}\NormalTok{(disparity\_crown\_stem, }\AttributeTok{type =} \StringTok{"line"}\NormalTok{, }\AttributeTok{rarefaction =} \DecValTok{20}\NormalTok{)}

\DocumentationTok{\#\# As above but using polygons while also displaying the number of elements}
\FunctionTok{plot}\NormalTok{(disparity\_crown\_stem, }\AttributeTok{type =} \StringTok{"polygon"}\NormalTok{, }\AttributeTok{elements =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-84-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Resetting graphical parameters}
\FunctionTok{par}\NormalTok{(op)}
\end{Highlighting}
\end{Shaded}

Since \texttt{plot.dispRity} uses the arguments from the generic \texttt{plot} method, it is of course possible to change pretty much everything using the regular plot arguments:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Graphical options}
\NormalTok{op }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{bty =} \StringTok{"n"}\NormalTok{)}

\DocumentationTok{\#\# Plotting the results with some classic options from plot}
\FunctionTok{plot}\NormalTok{(disparity\_time\_slices, }\AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{"blue"}\NormalTok{, }\StringTok{"orange"}\NormalTok{, }\StringTok{"green"}\NormalTok{),}
    \AttributeTok{ylab =} \FunctionTok{c}\NormalTok{(}\StringTok{"Some measurement"}\NormalTok{), }\AttributeTok{xlab =} \StringTok{"Some other measurement"}\NormalTok{,}
    \AttributeTok{main =} \StringTok{"Many options..."}\NormalTok{, }\AttributeTok{ylim =} \FunctionTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{0}\NormalTok{), }\AttributeTok{xlim =} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{0}\NormalTok{))}

\DocumentationTok{\#\# Adding a legend}
\FunctionTok{legend}\NormalTok{(}\StringTok{"topleft"}\NormalTok{, }\AttributeTok{legend =} \FunctionTok{c}\NormalTok{(}\StringTok{"Central tendency"}\NormalTok{,}
                             \StringTok{"Confidence interval 1"}\NormalTok{,}
                             \StringTok{"Confidence interval 2"}\NormalTok{),}
      \AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{"blue"}\NormalTok{, }\StringTok{"orange"}\NormalTok{, }\StringTok{"green"}\NormalTok{), }\AttributeTok{pch =} \DecValTok{19}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-85-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Resetting graphical parameters}
\FunctionTok{par}\NormalTok{(op)}
\end{Highlighting}
\end{Shaded}

In addition to the classic \texttt{plot} arguments, the function can also take arguments that are specific to \texttt{plot.dispRity} like adding the number of elements or rarefaction level (as described above), and also changing the values of the quantiles to plot as well as the central tendency.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Graphical options}
\NormalTok{op }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{bty =} \StringTok{"n"}\NormalTok{)}

\DocumentationTok{\#\# Plotting the results with some plot.dispRity arguments}
\FunctionTok{plot}\NormalTok{(disparity\_time\_slices,}
    \AttributeTok{quantiles =} \FunctionTok{c}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\AttributeTok{from =} \DecValTok{10}\NormalTok{, }\AttributeTok{to =} \DecValTok{100}\NormalTok{, }\AttributeTok{by =} \DecValTok{10}\NormalTok{)),}
    \AttributeTok{cent.tend =}\NormalTok{ sd, }\AttributeTok{type =} \StringTok{"c"}\NormalTok{, }\AttributeTok{elements =} \ConstantTok{TRUE}\NormalTok{,}
    \AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{"black"}\NormalTok{, }\FunctionTok{rainbow}\NormalTok{(}\DecValTok{10}\NormalTok{)),}
    \AttributeTok{ylab =} \FunctionTok{c}\NormalTok{(}\StringTok{"Disparity"}\NormalTok{, }\StringTok{"Diversity"}\NormalTok{),}
    \AttributeTok{xlab =} \StringTok{"Time (in in units from past to present)"}\NormalTok{,}
    \AttributeTok{observed =} \ConstantTok{TRUE}\NormalTok{,}
    \AttributeTok{main =} \StringTok{"Many more options..."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-86-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Resetting graphical parameters}
\FunctionTok{par}\NormalTok{(op)}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Note that the argument \texttt{observed\ =\ TRUE} allows to plot the disparity values calculated from the non-bootstrapped data as crosses on the plot.
\end{quote}

For comparing results, it is also possible to add a plot to the existent plot by using \texttt{add\ =\ TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Graphical options}
\NormalTok{op }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{bty =} \StringTok{"n"}\NormalTok{)}

\DocumentationTok{\#\# Plotting the continuous disparity with a fixed y axis}
\FunctionTok{plot}\NormalTok{(disparity\_time\_slices, }\AttributeTok{ylim =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{))}
\DocumentationTok{\#\# Adding the discrete data}
\FunctionTok{plot}\NormalTok{(disparity\_time\_bins, }\AttributeTok{type =} \StringTok{"line"}\NormalTok{, }\AttributeTok{ylim =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{),}
     \AttributeTok{xlab =} \StringTok{""}\NormalTok{, }\AttributeTok{ylab =} \StringTok{""}\NormalTok{, }\AttributeTok{add =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-87-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Resetting graphical parameters}
\FunctionTok{par}\NormalTok{(op)}
\end{Highlighting}
\end{Shaded}

Finally, if your data has been fully rarefied, it is also possible to easily look at rarefaction curves by using the \texttt{rarefaction\ =\ TRUE} argument:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Graphical options}
\NormalTok{op }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{bty =} \StringTok{"n"}\NormalTok{)}

\DocumentationTok{\#\# Plotting the rarefaction curves}
\FunctionTok{plot}\NormalTok{(disparity\_crown\_stem, }\AttributeTok{rarefaction =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-88-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Resetting graphical parameters}
\FunctionTok{par}\NormalTok{(op)}
\end{Highlighting}
\end{Shaded}

\hypertarget{type-preview}{%
\subsection{\texorpdfstring{\texttt{type\ =\ preview}}{type = preview}}\label{type-preview}}

Note that all the options above are plotting disparity objects for which a disparity metric \emph{has been calculated}.
This makes totally sense for \texttt{dispRity} objects but sometimes it might be interesting to look at what the trait-space looks like before measuring the disparity.
This can be done by plotting \texttt{dispRity} objects with no calculated disparity!

For example, we might be interested in looking at how the distribution of elements change as a function of the distributions of different sub-settings.
For example custom subsets \emph{vs.} time subsets:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Making the different subsets}
\NormalTok{cust\_subsets }\OtherTok{\textless{}{-}} \FunctionTok{custom.subsets}\NormalTok{(BeckLee\_mat99,}
                               \FunctionTok{crown.stem}\NormalTok{(BeckLee\_tree,}
                                          \AttributeTok{inc.nodes =} \ConstantTok{TRUE}\NormalTok{))}
\NormalTok{time\_subsets }\OtherTok{\textless{}{-}} \FunctionTok{chrono.subsets}\NormalTok{(BeckLee\_mat99,}
                               \AttributeTok{tree =}\NormalTok{ BeckLee\_tree,}
                               \AttributeTok{method =} \StringTok{"discrete"}\NormalTok{,}
                               \AttributeTok{time =} \DecValTok{5}\NormalTok{)}

\DocumentationTok{\#\# Note that no disparity has been calculated here:}
\FunctionTok{is.null}\NormalTok{(cust\_subsets}\SpecialCharTok{$}\NormalTok{disparity)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.null}\NormalTok{(time\_subsets}\SpecialCharTok{$}\NormalTok{disparity)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# But we can still plot both spaces by using the default plot functions}
\FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\DocumentationTok{\#\# Default plotting}
\FunctionTok{plot}\NormalTok{(cust\_subsets)}
\DocumentationTok{\#\# Plotting with more arguments}
\FunctionTok{plot}\NormalTok{(time\_subsets, }\AttributeTok{specific.args =} \FunctionTok{list}\NormalTok{(}\AttributeTok{dimensions =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{)),}
     \AttributeTok{main =} \StringTok{"Some }\SpecialCharTok{\textbackslash{}"}\StringTok{low}\SpecialCharTok{\textbackslash{}"}\StringTok{ dimensions"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-89-1.pdf}

\begin{quote}
DISCLAIMER: This functionality can be handy for exploring the data (e.g.~to visually check whether the subset attribution worked) but it might be misleading on how the data is \emph{actually} distributed in the multidimensional space!
Groups that don't overlap on two set dimensions can totally overlap in all other dimensions!
\end{quote}

For \texttt{dispRity} objects that do contain disparity data, the default option is to plot your disparity data.
However you can always force the \texttt{preview} option using the following:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\DocumentationTok{\#\# Default plotting}
\FunctionTok{plot}\NormalTok{(disparity\_time\_slices, }\AttributeTok{main =} \StringTok{"Disparity through time"}\NormalTok{)}
\DocumentationTok{\#\# Plotting with more arguments}
\FunctionTok{plot}\NormalTok{(disparity\_time\_slices, }\AttributeTok{type =} \StringTok{"preview"}\NormalTok{,}
     \AttributeTok{main =} \StringTok{"Two first dimensions of the trait space"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-90-1.pdf}

\hypertarget{graphical-options-with-...}{%
\subsection{\texorpdfstring{Graphical options with \texttt{...}}{Graphical options with ...}}\label{graphical-options-with-...}}

As mentioned above all the plots using \texttt{plot.dispRity} you can use the \texttt{...} options to add any type of graphical parameters recognised by \texttt{plot}.
However, sometimes, plotting more advanced \texttt{"dispRity"} objects also calls other generic functions such as \texttt{lines}, \texttt{points} or \texttt{legend}.
You can fine tune which specific function should be affected by \texttt{...} by using the syntax \texttt{\textless{}function\textgreater{}.\textless{}argument\textgreater{}} where \texttt{\textless{}function\textgreater{}} is usually the function to plot a specific element in the plot (e.g.~\texttt{points}) and the \texttt{\textless{}argument\textgreater{}} is the specific argument you want to change for that function.
For example, in a plot containing several elements, including circles (plotted internally with \texttt{points}), you can decide to colour everything in blue using the normal \texttt{col\ =\ "blue"} option.
But you can also decide to \emph{only} colour the circles in blue using \texttt{points.col\ =\ "blue"}!

Here is an example with multiple elements (lines and points) taken from the \protect\hyperlink{dispRitree}{disparity with trees} section below:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading some demo data:}
\DocumentationTok{\#\# An ordinated matrix with node and tip labels}
\FunctionTok{data}\NormalTok{(BeckLee\_mat99)}
\DocumentationTok{\#\# The corresponding tree with tip and node labels}
\FunctionTok{data}\NormalTok{(BeckLee\_tree)}
\DocumentationTok{\#\# A list of tips ages for the fossil data}
\FunctionTok{data}\NormalTok{(BeckLee\_ages)}

\DocumentationTok{\#\# Time slicing through the tree using the equal split algorithm}
\NormalTok{time\_slices }\OtherTok{\textless{}{-}} \FunctionTok{chrono.subsets}\NormalTok{(}\AttributeTok{data   =}\NormalTok{ BeckLee\_mat99,}
                              \AttributeTok{tree   =}\NormalTok{ BeckLee\_tree,}
                              \AttributeTok{FADLAD =}\NormalTok{ BeckLee\_ages,}
                              \AttributeTok{method =} \StringTok{"continuous"}\NormalTok{,}
                              \AttributeTok{model  =} \StringTok{"acctran"}\NormalTok{,}
                              \AttributeTok{time   =} \DecValTok{15}\NormalTok{)}

\FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\DocumentationTok{\#\# The preview plot with the tree using only defaults}
\FunctionTok{plot}\NormalTok{(time\_slices, }\AttributeTok{type =} \StringTok{"preview"}\NormalTok{, }\AttributeTok{specific.args =} \FunctionTok{list}\NormalTok{(}\AttributeTok{tree =} \ConstantTok{TRUE}\NormalTok{))}
\DocumentationTok{\#\# The same plot but by applying general options}
\FunctionTok{plot}\NormalTok{(time\_slices, }\AttributeTok{type =} \StringTok{"preview"}\NormalTok{, }\AttributeTok{specific.args =} \FunctionTok{list}\NormalTok{(}\AttributeTok{tree =} \ConstantTok{TRUE}\NormalTok{),}
     \AttributeTok{col =} \StringTok{"blue"}\NormalTok{, }\AttributeTok{main =} \StringTok{"General options"}\NormalTok{)}
\DocumentationTok{\#\# The same plot but by applying the colour only to the lines}
\DocumentationTok{\#\# and change of shape only to the points}
\FunctionTok{plot}\NormalTok{(time\_slices, }\AttributeTok{type =} \StringTok{"preview"}\NormalTok{, }\AttributeTok{specific.args =} \FunctionTok{list}\NormalTok{(}\AttributeTok{tree =} \ConstantTok{TRUE}\NormalTok{),}
     \AttributeTok{lines.col =} \StringTok{"blue"}\NormalTok{, }\AttributeTok{points.pch =} \DecValTok{15}\NormalTok{, }\AttributeTok{main =} \StringTok{"Specific options"}\NormalTok{)}
\DocumentationTok{\#\# And now without the legend}
\FunctionTok{plot}\NormalTok{(time\_slices, }\AttributeTok{type =} \StringTok{"preview"}\NormalTok{, }\AttributeTok{specific.args =} \FunctionTok{list}\NormalTok{(}\AttributeTok{tree =} \ConstantTok{TRUE}\NormalTok{),}
     \AttributeTok{lines.col =} \StringTok{"blue"}\NormalTok{, }\AttributeTok{points.pch =} \DecValTok{15}\NormalTok{, }\AttributeTok{legend =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-91-1.pdf}

\hypertarget{testing-disparity-hypotheses}{%
\section{Testing disparity hypotheses}\label{testing-disparity-hypotheses}}

The \texttt{dispRity} package allows users to apply statistical tests to the calculated disparity to test various hypotheses.
The function \texttt{test.dispRity} works in a similar way to the \texttt{dispRity} function: it takes a \texttt{dispRity} object, a \texttt{test} and a \texttt{comparisons} argument.

The \texttt{comparisons} argument indicates the way the test should be applied to the data:

\begin{itemize}
\tightlist
\item
  \texttt{pairwise} (default): to compare each subset in a pairwise manner
\item
  \texttt{referential}: to compare each subset to the first subset
\item
  \texttt{sequential}: to compare each subset to the following subset
\item
  \texttt{all}: to compare all the subsets together (like in analysis of variance)
\end{itemize}

It is also possible to input a list of pairs of \texttt{numeric} values or \texttt{characters} matching the subset names to create personalised tests.
Some other tests implemented in \texttt{dispRity} such as the \texttt{dispRity::null.test} have a specific way they are applied to the data and therefore ignore the \texttt{comparisons} argument.

The \texttt{test} argument can be any statistical or non-statistical test to apply to the disparity object.
It can be a common statistical test function (e.g.~\texttt{stats::t.test}), a function implemented in \texttt{dispRity} (e.g.~see \texttt{?null.test}) or any function defined by the user.

This function also allows users to correct for Type I error inflation (false positives) when using multiple comparisons via the \texttt{correction} argument.
This argument can be empty (no correction applied) or can contain one of the corrections from the \texttt{stats::p.adjust} function (see \texttt{?p.adjust}).

Note that the \texttt{test.dispRity} algorithm deals with some classical test outputs (\texttt{h.test}, \texttt{lm} and \texttt{numeric} vector) and summarises the test output.
It is, however, possible to get the full detailed output by using the options \texttt{details\ =\ TRUE}.

Here we are using the variables generated in the \protect\hyperlink{summarising-dispRity-data-plots}{section above}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# T{-}test to test for a difference in disparity between crown and stem mammals}
\FunctionTok{test.dispRity}\NormalTok{(disparity\_crown\_stem, }\AttributeTok{test =}\NormalTok{ t.test)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
##              statistic: t
## crown : stem     54.10423
## 
## [[2]]
##              parameter: df
## crown : stem      177.9857
## 
## [[3]]
##                    p.value
## crown : stem 1.928983e-112
## 
## [[4]]
##                   stderr
## crown : stem 0.005649615
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Performing the same test but with the detailed t.test output}
\FunctionTok{test.dispRity}\NormalTok{(disparity\_crown\_stem, }\AttributeTok{test =}\NormalTok{ t.test, }\AttributeTok{details =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $`crown : stem`
## $`crown : stem`[[1]]
## 
##  Welch Two Sample t-test
## 
## data:  dots[[1L]][[1L]] and dots[[2L]][[1L]]
## t = 54.104, df = 177.99, p-value < 2.2e-16
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  0.2945193 0.3168170
## sample estimates:
## mean of x mean of y 
##  2.440968  2.135299
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Wilcoxon test applied to time sliced disparity with sequential comparisons,}
\DocumentationTok{\#\# with Bonferroni correction}
\FunctionTok{test.dispRity}\NormalTok{(disparity\_time\_slices, }\AttributeTok{test =}\NormalTok{ wilcox.test,}
              \AttributeTok{comparisons =} \StringTok{"sequential"}\NormalTok{, }\AttributeTok{correction =} \StringTok{"bonferroni"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
##          statistic: W
## 120 : 80           40
## 80 : 40          1812
## 40 : 0           1463
## 
## [[2]]
##               p.value
## 120 : 80 2.534081e-33
## 80 : 40  2.037470e-14
## 40 : 0   1.671038e-17
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring the overlap between distributions in the time bins (using the}
\DocumentationTok{\#\# implemented Bhattacharyya Coefficient function {-} see ?bhatt.coeff)}
\FunctionTok{test.dispRity}\NormalTok{(disparity\_time\_bins, }\AttributeTok{test =}\NormalTok{ bhatt.coeff)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                    bhatt.coeff
## 120 - 80 : 80 - 40    0.000000
## 120 - 80 : 40 - 0     0.000000
## 80 - 40 : 40 - 0      0.450877
\end{verbatim}

Because of the modular design of the package, tests can always be made by the user (the same way disparity metrics can be user made).
The only condition is that the test can be applied to at least two distributions.
In practice, the \texttt{test.dispRity} function will pass the calculated disparity data (distributions) to the provided function in either pairs of distributions (if the \texttt{comparisons} argument is set to \texttt{pairwise}, \texttt{referential} or \texttt{sequential}) or a table containing all the distributions (\texttt{comparisons\ =\ all}; this should be in the same format as data passed to \texttt{lm}-type functions for example).

\hypertarget{adonis}{%
\subsection{\texorpdfstring{NPMANOVA in \texttt{dispRity}}{NPMANOVA in dispRity}}\label{adonis}}

One often useful test to apply to multidimensional data is the permutational multivariate analysis of variance based on distance matrices \texttt{vegan::adonis2}.
This can be done on \texttt{dispRity} objects using the \texttt{adonis.dispRity} wrapper function.
Basically, this function takes the exact same arguments as \texttt{adonis} and a \texttt{dispRity} object for data and performs a PERMANOVA based on the distance matrix of the multidimensional space (unless the multidimensional space was already defined as a distance matrix).
The \texttt{adonis.dispRity} function uses the information from the \texttt{dispRity} object to generate default formulas:

\begin{itemize}
\tightlist
\item
  If the object contains customised subsets, it applies the default formula \texttt{matrix\ \textasciitilde{}\ group} testing the effect of \texttt{group} as a predictor on \texttt{matrix} (called from the \texttt{dispRity} object as \texttt{data\$matrix} see \protect\hyperlink{The-dispRity-object-content}{\texttt{dispRity} object details})
\item
  If the object contains time subsets, it applies the default formula \texttt{matrix\ \textasciitilde{}\ time} testing the effect of \texttt{time} as a predictor (were the different levels of \texttt{time} are the different time slices/bins)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# Generating a random character matrix}
\NormalTok{character\_matrix }\OtherTok{\textless{}{-}} \FunctionTok{sim.morpho}\NormalTok{(}\FunctionTok{rtree}\NormalTok{(}\DecValTok{20}\NormalTok{), }\DecValTok{50}\NormalTok{,}
                               \AttributeTok{rates =} \FunctionTok{c}\NormalTok{(rnorm, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{))}

\DocumentationTok{\#\# Calculating the distance matrix}
\NormalTok{distance\_matrix }\OtherTok{\textless{}{-}} \FunctionTok{as.matrix}\NormalTok{(}\FunctionTok{dist}\NormalTok{(character\_matrix))}

\DocumentationTok{\#\# Creating two groups}
\NormalTok{random\_groups }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\StringTok{"group1"} \OtherTok{=} \DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\StringTok{"group2"} \OtherTok{=} \DecValTok{11}\SpecialCharTok{:}\DecValTok{20}\NormalTok{)}

\DocumentationTok{\#\# Generating a dispRity object}
\NormalTok{random\_disparity }\OtherTok{\textless{}{-}} \FunctionTok{custom.subsets}\NormalTok{(distance\_matrix, random\_groups)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: custom.subsets is applied on what seems to be a distance matrix.
## The resulting matrices won't be distance matrices anymore!
## You can use dist.data = TRUE, if you want to keep the data as a distance matrix.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Running a default NPMANOVA}
\FunctionTok{adonis.dispRity}\NormalTok{(random\_disparity)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Permutation test for adonis under reduced model
## Permutation: free
## Number of permutations: 999
## 
## vegan::adonis2(formula = matrix ~ group, method = "euclidean")
##          Df SumOfSqs      R2      F Pr(>F)
## Model     1     14.2 0.06443 1.2396  0.166
## Residual 18    206.2 0.93557              
## Total    19    220.4 1.00000
\end{verbatim}

Of course, it is possible to pass customised formulas if the disparity object contains more more groups.
In that case the predictors must correspond to the names of the groups explained data must be set as \texttt{matrix}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating two groups with two states each}
\NormalTok{groups }\OtherTok{\textless{}{-}} \FunctionTok{as.data.frame}\NormalTok{(}\FunctionTok{matrix}\NormalTok{(}\AttributeTok{data =} \FunctionTok{c}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{10}\NormalTok{),}
                                        \FunctionTok{rep}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{10}\NormalTok{),}
                                        \FunctionTok{rep}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{), }\DecValTok{10}\NormalTok{)),}
                        \AttributeTok{nrow =} \DecValTok{20}\NormalTok{, }\AttributeTok{ncol =} \DecValTok{2}\NormalTok{,}
                        \AttributeTok{dimnames =} \FunctionTok{list}\NormalTok{(}\FunctionTok{paste0}\NormalTok{(}\StringTok{"t"}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{20}\NormalTok{),}
                                        \FunctionTok{c}\NormalTok{(}\StringTok{"g1"}\NormalTok{, }\StringTok{"g2"}\NormalTok{))))}

\DocumentationTok{\#\# Creating the dispRity object}
\NormalTok{multi\_groups }\OtherTok{\textless{}{-}} \FunctionTok{custom.subsets}\NormalTok{(distance\_matrix, groups)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: custom.subsets is applied on what seems to be a distance matrix.
## The resulting matrices won't be distance matrices anymore!
## You can use dist.data = TRUE, if you want to keep the data as a distance matrix.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Running the NPMANOVA}
\FunctionTok{adonis.dispRity}\NormalTok{(multi\_groups, matrix }\SpecialCharTok{\textasciitilde{}}\NormalTok{ g1 }\SpecialCharTok{+}\NormalTok{ g2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Permutation test for adonis under reduced model
## Permutation: free
## Number of permutations: 999
## 
## vegan::adonis2(formula = matrix ~ g1 + g2, method = "euclidean")
##          Df SumOfSqs      R2      F Pr(>F)
## Model     2     20.6 0.09347 0.8764  0.746
## Residual 17    199.8 0.90653              
## Total    19    220.4 1.00000
\end{verbatim}

Finally, it is possible to use objects generated by \texttt{chrono.subsets}.
In this case, \texttt{adonis.dispRity} will applied the \texttt{matrix\ \textasciitilde{}\ time} formula by default:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating time series}
\NormalTok{time\_subsets }\OtherTok{\textless{}{-}} \FunctionTok{chrono.subsets}\NormalTok{(BeckLee\_mat50, BeckLee\_tree,}
                               \AttributeTok{method =} \StringTok{"discrete"}\NormalTok{,}
                               \AttributeTok{inc.nodes =} \ConstantTok{FALSE}\NormalTok{,}
                               \AttributeTok{time =} \FunctionTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{85}\NormalTok{, }\DecValTok{65}\NormalTok{, }\DecValTok{0}\NormalTok{),}
                               \AttributeTok{FADLAD =}\NormalTok{ BeckLee\_ages)}

\DocumentationTok{\#\# Running the NPMANOVA with time as a predictor}
\FunctionTok{adonis.dispRity}\NormalTok{(time\_subsets)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in adonis.dispRity(time_subsets): The input data for adonis.dispRity was not a distance matrix.
## The results are thus based on the distance matrix for the input data (i.e. dist(data$matrix[[1]])).
## Make sure that this is the desired methodological approach!
\end{verbatim}

\begin{verbatim}
## Permutation test for adonis under reduced model
## Permutation: free
## Number of permutations: 999
## 
## vegan::adonis2(formula = dist(matrix) ~ time, method = "euclidean")
##          Df SumOfSqs      R2      F Pr(>F)    
## Model     2    9.593 0.07769 1.9796  0.001 ***
## Residual 47  113.884 0.92231                  
## Total    49  123.477 1.00000                  
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}

Note that the function warns you that the input data was transformed into a distance matrix.
This is reflected in the Call part of the output (\texttt{formula\ =\ dist(matrix)\ \textasciitilde{}\ time}).

To use each time subset as a separate predictor, you can use the \texttt{matrix\ \textasciitilde{}\ chrono.subsets} formula; this is equivalent to \texttt{matrix\ \textasciitilde{}\ first\_time\_subset\ +\ second\_time\_subset\ +\ ...}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Running the NPMANOVA with each time bin as a predictor}
\FunctionTok{adonis.dispRity}\NormalTok{(time\_subsets, matrix }\SpecialCharTok{\textasciitilde{}}\NormalTok{ chrono.subsets)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in adonis.dispRity(time_subsets, matrix ~ chrono.subsets): The input data for adonis.dispRity was not a distance matrix.
## The results are thus based on the distance matrix for the input data (i.e. dist(data$matrix[[1]])).
## Make sure that this is the desired methodological approach!
\end{verbatim}

\begin{verbatim}
## Permutation test for adonis under reduced model
## Permutation: free
## Number of permutations: 999
## 
## vegan::adonis2(formula = dist(matrix) ~ chrono.subsets, method = "euclidean")
##          Df SumOfSqs      R2      F Pr(>F)    
## Model     2    9.593 0.07769 1.9796  0.001 ***
## Residual 47  113.884 0.92231                  
## Total    49  123.477 1.00000                  
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}

\hypertarget{dtt}{%
\subsection{\texorpdfstring{\texttt{geiger::dtt} model fitting in \texttt{dispRity}}{geiger::dtt model fitting in dispRity}}\label{dtt}}

The \texttt{dtt} function from the \texttt{geiger} package is also often used to compare a trait's disparity observed in living taxa to the disparity of a simulated trait based on a given phylogeny.
The \texttt{dispRity} package proposes a wrapper function for \texttt{geiger::dtt}, \texttt{dtt.dispRity} that allows the use of any disparity metric.
Unfortunately, this implementation is slower that \texttt{geiger::dtt} (so if you're using the metrics implemented in \texttt{geiger} prefer the original version) and, as the original function, is limited to ultrametric trees (only living taxa!)\ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{require}\NormalTok{(geiger)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Loading required package: geiger
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{geiger\_data }\OtherTok{\textless{}{-}} \FunctionTok{get}\NormalTok{(}\FunctionTok{data}\NormalTok{(geospiza))}

\DocumentationTok{\#\# Calculate the disparity of the dataset using the sum of variance}
\NormalTok{dispRity\_dtt }\OtherTok{\textless{}{-}} \FunctionTok{dtt.dispRity}\NormalTok{(}\AttributeTok{data =}\NormalTok{ geiger\_data}\SpecialCharTok{$}\NormalTok{dat,}
                             \AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, variances),}
                             \AttributeTok{tree =}\NormalTok{ geiger\_data}\SpecialCharTok{$}\NormalTok{phy,}
                             \AttributeTok{nsim =} \DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in dtt.dispRity(data = geiger_data$dat, metric = c(sum, variances), :
## The following tip(s) was not present in the data: olivacea.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Plotting the results}
\FunctionTok{plot}\NormalTok{(dispRity\_dtt)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-97-1.pdf}

Note that, like in the original \texttt{dtt} function, it is possible to change the evolutionary model (see \texttt{?geiger::sim.char} documentation).

\hypertarget{null-test}{%
\subsection{\texorpdfstring{null morphospace testing with \texttt{null.test}}{null morphospace testing with null.test}}\label{null-test}}

This test is equivalent to the test performed in \citet{diaz2016global}.
It compares the disparity measured in the observed space to the disparity measured in a set of simulated spaces.
These simulated spaces can be built with based on the hypothesis assumptions: for example, we can test whether our space is normal.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}
\DocumentationTok{\#\# A "normal" multidimensional space with 50 dimensions and 10 elements}
\NormalTok{normal\_space }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{1000}\NormalTok{), }\AttributeTok{ncol =} \DecValTok{50}\NormalTok{)}

\DocumentationTok{\#\# Calculating the disparity as the average pairwise distances}
\NormalTok{obs\_disparity }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(normal\_space,}
                          \AttributeTok{metric =} \FunctionTok{c}\NormalTok{(mean, pairwise.dist))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in check.data(data, match_call): Row names have been automatically
## added to data.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Testing against 100 randomly generated normal spaces}
\NormalTok{(results }\OtherTok{\textless{}{-}} \FunctionTok{null.test}\NormalTok{(obs\_disparity, }\AttributeTok{replicates =} \DecValTok{100}\NormalTok{,}
                      \AttributeTok{null.distrib =}\NormalTok{ rnorm))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Monte-Carlo test
## Call: [1] "dispRity::null.test"
## 
## Observation: 9.910536 
## 
## Based on 100 replicates
## Simulated p-value: 0.8712871 
## Alternative hypothesis: two-sided 
## 
##     Std.Obs Expectation    Variance 
## -0.18217227  9.95101000  0.04936221
\end{verbatim}

Here the results show that disparity measured in our observed space is not significantly different than the one measured in a normal space.
We can then propose that our observed space is normal!

These results have an attributed \texttt{dispRity} and \texttt{randtest} class and can be plotted as \texttt{randtest} objects using the \texttt{dispRity} S3 \texttt{plot} method:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Plotting the results}
\FunctionTok{plot}\NormalTok{(results, }\AttributeTok{main =} \StringTok{"Is this space normal?"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-99-1.pdf}

For more details on generating spaces see the \protect\hyperlink{Simulating-multidimensional-spaces}{\texttt{space.maker}} function tutorial.

\hypertarget{model-fitting}{%
\section{Fitting modes of evolution to disparity data}\label{model-fitting}}

The code used for these models is based on those developed by Gene Hunt \citep{hunt2006fitting, hunt2012measuring, hunt2015simple}.
So we acknowledge and thank Gene Hunt for developing these models and writing the original R code that served as inspiration for these models.

\begin{quote}
DISCLAIMER: this method of analysing disparity has not been published yet and has not been peer reviewed. Caution should be used in interpreting these results: it is unclear what ``a disparity curve fitting a Brownian motion'' actually means biologically.
\end{quote}

As Malcolm said in Jurassic Park: ``although the examples within this chapter all work and produce solid tested results (from an algorithm point of view), that doesn't mean you should use it'' (or something along those lines).

\hypertarget{simple-modes-of-disparity-change-through-time}{%
\subsection{Simple modes of disparity change through time}\label{simple-modes-of-disparity-change-through-time}}

\hypertarget{model.test}{%
\subsubsection{\texorpdfstring{\texttt{model.test}}{model.test}}\label{model.test}}

Changes in disparity-through-time can follow a range of models, such as random walks, stasis, constrained evolution, trends, or an early burst model of evolution.
We will start with by fitting the simplest modes of evolution to our data.
For example we may have a null expectation of time-invariant change in disparity in which values fluctuate with a variance around the mean - this would be best describe by a Stasis model:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading premade disparity data}
\FunctionTok{data}\NormalTok{(BeckLee\_disparity)}
\NormalTok{disp\_time }\OtherTok{\textless{}{-}} \FunctionTok{model.test}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_disparity, }\AttributeTok{model =} \StringTok{"Stasis"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Evidence of equal variance (Bartlett's test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -15.562
\end{verbatim}

We can see the standard output from \texttt{model.test}.
The first output message tells us it has tested for equal variances in each sample.
The model uses Bartlett's test of equal variances to assess if variances are equal, so if p \textgreater{} 0.05 then variance is treated as the same for all samples, but if (p \textless{} 0.05) then each bin variance is unique.
Here we have p \textless{} 0.05, so variance is not pooled between samples.

By default \texttt{model.test} will use Bartlett's test to assess for homogeneity of variances, and then use this to decide to pool variances or not.
This is ignored if the argument \texttt{pool.variance} in \texttt{model.test} is changed from the default \texttt{NULL} to \texttt{TRUE} or \texttt{FALSE}.
For example, to ignore Bartlett's test and pool variances manually we would do the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{disp\_time\_pooled }\OtherTok{\textless{}{-}} \FunctionTok{model.test}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_disparity,}
                               \AttributeTok{model =} \StringTok{"Stasis"}\NormalTok{,}
                               \AttributeTok{pool.variance =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Running Stasis model...Done. Log-likelihood = -13.682
\end{verbatim}

However, unless you have good reason to choose otherwise it is recommended to use the default of \texttt{pool.variance\ =\ NULL}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{disp\_time }\OtherTok{\textless{}{-}} \FunctionTok{model.test}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_disparity,}
                        \AttributeTok{model =} \StringTok{"Stasis"}\NormalTok{,}
                        \AttributeTok{pool.variance =} \ConstantTok{NULL}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Evidence of equal variance (Bartlett's test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -15.562
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{disp\_time}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Disparity evolution model fitting:
## Call: model.test(data = BeckLee_disparity, model = "Stasis", pool.variance = NULL) 
## 
##            aicc delta_aicc weight_aicc
## Stasis 35.22653          0           1
## 
## Use x$full.details for displaying the models details
## or summary(x) for summarising them.
\end{verbatim}

The remaining output gives us the log-likelihood of the Stasis model of -15.6 (you may notice this change when we pooled variances above).
The output also gives us the small sample Akaike Information Criterion (AICc), the delta AICc (the distance from the best fitting model), and the AICc weights (\textasciitilde the relative support of this model compared to all models, scaled to one).

These are all metrics of relative fit, so when we test a single model they are not useful.
By using the function summary in \texttt{dispRity} we can see the maximum likelihood estimates of the model parameters:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(disp\_time)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        aicc delta_aicc weight_aicc log.lik param theta.1 omega
## Stasis 35.2          0           1   -15.6     2     3.5   0.1
\end{verbatim}

So we again see the AICc, delta AICc, AICc weight, and the log-likelihood we saw previously.
We now also see the number of parameters from the model (2: theta and omega), and their estimates so the variance (omega = 0.1) and the mean (theta.1 = 3.5).

The \texttt{model.test} function is designed to test relative model fit, so we need to test more than one model to make relative comparisons.
So let's compare to the fit of the Stasis model to another model with two parameters: the Brownian motion.
Brownian motion assumes a constant mean that is equal to the ancestral estimate of the sequence, and the variance around this mean increases linearly with time.
The easier way to compare these models is to simply add \texttt{"BM"} to the \texttt{models} vector argument:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{disp\_time }\OtherTok{\textless{}{-}} \FunctionTok{model.test}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_disparity,}
                        \AttributeTok{model =} \FunctionTok{c}\NormalTok{(}\StringTok{"Stasis"}\NormalTok{, }\StringTok{"BM"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Evidence of equal variance (Bartlett's test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -15.562
## Running BM model...Done. Log-likelihood = 151.637
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{disp\_time}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Disparity evolution model fitting:
## Call: model.test(data = BeckLee_disparity, model = c("Stasis", "BM")) 
## 
##              aicc delta_aicc  weight_aicc
## Stasis   35.22653   334.3978 2.434618e-73
## BM     -299.17132     0.0000 1.000000e+00
## 
## Use x$full.details for displaying the models details
## or summary(x) for summarising them.
\end{verbatim}

Et voilà! Here we can see by the log-likelihood, AICc, delta AICc, and AICc weight Brownian motion has a much better relative fit to these data than the Stasis model.
Brownian motion has a relative AICc fit334.4 units better than Stasis, and has a AICc weight of 1.

We can also all the information about the relative fit of models alongside the maximum likelihood estimates of model parameters using the summary function

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(disp\_time)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        aicc delta_aicc weight_aicc log.lik param theta.1 omega ancestral state
## Stasis   35      334.4           0   -15.6     2   3.486  0.07              NA
## BM     -299        0.0           1   151.6     2      NA    NA           3.132
##        sigma squared
## Stasis            NA
## BM             0.001
\end{verbatim}

Not that because the parameters per models differ, the summary includes \texttt{NA} for inapplicable parameters per models (e.g.~the theta and omega parameters from the Stasis models are inapplicable for a Brownian motion model).

We can plot the relative fit of our models using the \texttt{plot} function

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(disp\_time)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{dispRity_manual_files/figure-latex/plot1-1} 

}

\caption{relative fit (AICc weight) of Stasis and Brownian models of disparity through time}\label{fig:plot1}
\end{figure}

Here we see and overwhelming support for the Brownian motion model.

Alternatively, we could test all available models single modes: Stasis, Brownian motion, Ornstein-Uhlenbeck (evolution constrained to an optima), Trend (increasing or decreasing mean through time), and Early Burst (exponentially decreasing rate through time)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{disp\_time }\OtherTok{\textless{}{-}} \FunctionTok{model.test}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_disparity,}
                  \AttributeTok{model =} \FunctionTok{c}\NormalTok{(}\StringTok{"Stasis"}\NormalTok{, }\StringTok{"BM"}\NormalTok{, }\StringTok{"OU"}\NormalTok{, }\StringTok{"Trend"}\NormalTok{, }\StringTok{"EB"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Evidence of equal variance (Bartlett's test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -15.562
## Running BM model...Done. Log-likelihood = 151.637
## Running OU model...Done. Log-likelihood = 154.512
## Running Trend model...Done. Log-likelihood = 154.508
## Running EB model...Done. Log-likelihood = 128.008
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(disp\_time)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        aicc delta_aicc weight_aicc log.lik param theta.1 omega ancestral state
## Stasis   35      338.0       0.000   -15.6     2   3.486  0.07              NA
## BM     -299        3.6       0.108   151.6     2      NA    NA           3.132
## OU     -301        2.1       0.229   154.5     4      NA    NA           3.118
## Trend  -303        0.0       0.664   154.5     3      NA    NA           3.119
## EB     -250       53.0       0.000   128.0     3      NA    NA           3.934
##        sigma squared alpha optima.1 trend     eb
## Stasis            NA    NA       NA    NA     NA
## BM             0.001    NA       NA    NA     NA
## OU             0.001 0.001    10.18    NA     NA
## Trend          0.001    NA       NA 0.007     NA
## EB             0.000    NA       NA    NA -0.034
\end{verbatim}

These models indicate support for a Trend model, and we can plot the relative support of all model AICc weights.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(disp\_time)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{dispRity_manual_files/figure-latex/plot2-1} 

}

\caption{relative fit (AICc weight) of various modes of evolution}\label{fig:plot2}
\end{figure}

\begin{quote}
Note that although AIC values are indicator of model best fit, it is also important to look at the parameters themselves.
For example OU can be really well supported but with an alpha parameter really close to 0, making it effectively a BM model \citep{Cooper2016}.
\end{quote}

Is this a trend of increasing or decreasing disparity through time? One way to find out is to look at the summary function for the Trend model:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(disp\_time)[}\StringTok{"Trend"}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##            aicc      delta_aicc     weight_aicc         log.lik           param 
##        -303.000           0.000           0.664         154.500           3.000 
##         theta.1           omega ancestral state   sigma squared           alpha 
##              NA              NA           3.119           0.001              NA 
##        optima.1           trend              eb 
##              NA           0.007              NA
\end{verbatim}

This show a positive trend (0.007) of increasing disparity through time.

\hypertarget{plot-and-run-simulation-tests-in-a-single-step}{%
\subsection{Plot and run simulation tests in a single step}\label{plot-and-run-simulation-tests-in-a-single-step}}

\hypertarget{model.test.wrapper}{%
\subsubsection{\texorpdfstring{\texttt{model.test.wrapper}}{model.test.wrapper}}\label{model.test.wrapper}}

Patterns of evolution can be fit using \texttt{model.test}, but the \texttt{model.test.wrapper} fits the same models as \texttt{model.test} as well as running predictive tests and plots.

The predictive tests use the maximum likelihood estimates of model parameters to simulate a number of datasets (default = 1000), and analyse whether this is significantly different to the empirical input data using the Rank Envelope test \citep{murrell2018global}.
Finally we can plot the empirical data, simulated data, and the Rank Envelope test p values.
This can all be done using the function \texttt{model.test.wrapper}, and we will set the argument \texttt{show.p\ =\ TRUE} so \emph{p} values from the Rank Envelope test are printed on the plot:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{disp\_time }\OtherTok{\textless{}{-}} \FunctionTok{model.test.wrapper}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_disparity,}
                    \AttributeTok{model =} \FunctionTok{c}\NormalTok{(}\StringTok{"Stasis"}\NormalTok{, }\StringTok{"BM"}\NormalTok{, }\StringTok{"OU"}\NormalTok{, }\StringTok{"Trend"}\NormalTok{, }\StringTok{"EB"}\NormalTok{),}
                                \AttributeTok{show.p =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Evidence of equal variance (Bartlett's test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -15.562
## Running BM model...Done. Log-likelihood = 151.637
## Running OU model...Done. Log-likelihood = 154.512
## Running Trend model...Done. Log-likelihood = 154.508
## Running EB model...Done. Log-likelihood = 128.008
\end{verbatim}

\begin{figure}

{\centering \includegraphics{dispRity_manual_files/figure-latex/plot3-1} 

}

\caption{Empirical disparity through time (pink), simulate data based on estimated model parameters (grey), delta AICc, and range of p values from the Rank Envelope test for Trend, OU, BM, EB, and Stasis models}\label{fig:plot3}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{disp\_time}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        aicc delta_aicc weight_aicc log.lik param theta.1 omega ancestral state
## Trend  -303        0.0       0.664   154.5     3      NA    NA           3.119
## OU     -301        2.1       0.229   154.5     4      NA    NA           3.118
## BM     -299        3.6       0.108   151.6     2      NA    NA           3.132
## EB     -250       53.0       0.000   128.0     3      NA    NA           3.934
## Stasis   35      338.0       0.000   -15.6     2   3.486  0.07              NA
##        sigma squared alpha optima.1 trend     eb median p value lower p value
## Trend          0.001    NA       NA 0.007     NA    0.986013986     0.9850150
## OU             0.001 0.001    10.18    NA     NA    0.979020979     0.9770230
## BM             0.001    NA       NA    NA     NA    0.107892108     0.0969031
## EB             0.000    NA       NA    NA -0.034    0.000999001     0.0000000
## Stasis            NA    NA       NA    NA     NA    1.000000000     0.9990010
##        upper p value
## Trend      0.9860140
## OU         0.9800200
## BM         0.1388611
## EB         0.1378621
## Stasis     1.0000000
\end{verbatim}

From this plot we can see the empirical estimates of disparity through time (pink) compared to the predictive data based upon the simulations using the estimated parameters from each model.
There is no significant differences between the empirical data and simulated data, except for the Early Burst model.

Trend is the best-fitting model but the plot suggests the OU model also follows a trend-like pattern.
This is because the optima for the OU model (10.18) is different to the ancestral state (3.118) and outside the observed value.
This is potentially unrealistic, and one way to alleviate this issue is to set the optima of the OU model to equal the ancestral estimate - this is the normal practice for OU models in comparative phylogenetics.
To set the optima to the ancestral value we change the argument \texttt{fixed.optima\ =\ TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{disp\_time }\OtherTok{\textless{}{-}} \FunctionTok{model.test.wrapper}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_disparity,}
                    \AttributeTok{model =} \FunctionTok{c}\NormalTok{(}\StringTok{"Stasis"}\NormalTok{, }\StringTok{"BM"}\NormalTok{, }\StringTok{"OU"}\NormalTok{, }\StringTok{"Trend"}\NormalTok{, }\StringTok{"EB"}\NormalTok{),}
                                \AttributeTok{show.p =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{fixed.optima =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Evidence of equal variance (Bartlett's test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -15.562
## Running BM model...Done. Log-likelihood = 151.637
## Running OU model...Done. Log-likelihood = 151.637
## Running Trend model...Done. Log-likelihood = 154.508
## Running EB model...Done. Log-likelihood = 128.008
\end{verbatim}

\begin{figure}

{\centering \includegraphics{dispRity_manual_files/figure-latex/plot4-1} 

}

\caption{Empirical disparity through time (pink), simulate data based on estimated model parameters (grey), delta AICc, and range of p values from the Rank Envelope test for Trend, OU, BM, EB, and Stasis models with the optima of the OU model set to equal the ancestral value}\label{fig:plot4}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{disp\_time}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        aicc delta_aicc weight_aicc log.lik param theta.1 omega ancestral state
## Trend  -303        0.0       0.821   154.5     3      NA    NA           3.119
## BM     -299        3.6       0.133   151.6     2      NA    NA           3.132
## OU     -297        5.7       0.046   151.6     3      NA    NA           3.132
## EB     -250       53.0       0.000   128.0     3      NA    NA           3.934
## Stasis   35      338.0       0.000   -15.6     2   3.486  0.07              NA
##        sigma squared alpha trend     eb median p value lower p value
## Trend          0.001    NA 0.007     NA    0.989010989     0.9880120
## BM             0.001    NA    NA     NA    0.224775225     0.2117882
## OU             0.001     0    NA     NA    0.264735265     0.2637363
## EB             0.000    NA    NA -0.034    0.000999001     0.0000000
## Stasis            NA    NA    NA     NA    0.999000999     0.9980020
##        upper p value
## Trend      0.9890110
## BM         0.2507493
## OU         0.2967033
## EB         0.1378621
## Stasis     0.9990010
\end{verbatim}

The relative fit of the OU model is decreased by constraining the fit of the optima to equal the ancestral state value.
In fact as the OU attraction parameter (alpha) is zero, the model is equal to a Brownian motion model but is penalised by having an extra parameter.
Note that indeed, the plots of the BM model and the OU model look nearly identical.

\hypertarget{multiple-modes-of-evolution-time-shifts}{%
\subsection{Multiple modes of evolution (time shifts)}\label{multiple-modes-of-evolution-time-shifts}}

As well as fitting a single model to a sequence of disparity values we can also allow for the mode of evolution to shift at a single or multiple points in time.
The timing of a shift in mode can be based on an a prior expectation, such as a mass extinction event, or the model can test multiple points to allow to find time shift point with the highest likelihood.

Models can be fit using \texttt{model.test} but it can be more convenient to use \texttt{model.test.wrapper}.
Here we will compare the relative fit of Brownian motion, Trend, Ornstein-Uhlenbeck and a multi-mode Ornstein Uhlenbck model in which the optima changes at 66 million years ago, the Cretaceous-Palaeogene boundary.

For example, we could be testing the hypothesis that the extinction of non-avian dinosaurs allowed mammals to go from scurrying in the undergrowth (low optima/low disparity) to dominating all habitats (high optima/high disparity).
We will constrain the optima of OU model in the first time begin (i.e, pre-66 Mya) to equal the ancestral value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{disp\_time }\OtherTok{\textless{}{-}} \FunctionTok{model.test.wrapper}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_disparity,}
                        \AttributeTok{model =} \FunctionTok{c}\NormalTok{(}\StringTok{"BM"}\NormalTok{, }\StringTok{"Trend"}\NormalTok{, }\StringTok{"OU"}\NormalTok{, }\StringTok{"multi.OU"}\NormalTok{),}
                                \AttributeTok{time.split =} \DecValTok{66}\NormalTok{,}
                                \AttributeTok{pool.variance =} \ConstantTok{NULL}\NormalTok{,}
                                \AttributeTok{show.p =} \ConstantTok{TRUE}\NormalTok{,}
                                \AttributeTok{fixed.optima =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Evidence of equal variance (Bartlett's test of equal variances p = 0).
## Variance is not pooled.
## Running BM model...Done. Log-likelihood = 151.637
## Running Trend model...Done. Log-likelihood = 154.508
## Running OU model...Done. Log-likelihood = 151.637
## Running multi.OU model...Done. Log-likelihood = 154.492
\end{verbatim}

\begin{figure}

{\centering \includegraphics{dispRity_manual_files/figure-latex/plot5-1} 

}

\caption{Empirical disparity through time (pink), simulate data based on estimated model parameters (grey), delta AICc, and range of p values from the Rank Envelope test for BM, Trend, OU, and multi OU models with a shift in optima allowed at 66 Ma}\label{fig:plot5}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{disp\_time}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          aicc delta_aicc weight_aicc log.lik param ancestral state
## Trend    -303      0.000       0.642   154.5     3           3.119
## multi.OU -301      2.170       0.217   154.5     4           3.117
## BM       -299      3.639       0.104   151.6     2           3.132
## OU       -297      5.742       0.036   151.6     3           3.132
##          sigma squared trend alpha optima.2 median p value lower p value
## Trend            0.001 0.007    NA       NA      0.9870130     0.9860140
## multi.OU         0.001    NA 0.003    5.582      0.9620380     0.9610390
## BM               0.001    NA    NA       NA      0.1848152     0.1838162
## OU               0.001    NA 0.000       NA      0.2787213     0.2757243
##          upper p value
## Trend        0.9870130
## multi.OU     0.9620380
## BM           0.2217782
## OU           0.3046953
\end{verbatim}

The multi-OU model shows an increase an optima at the Cretaceous-Palaeogene boundary, indicating a shift in disparity.
However, this model does not fit as well as a model in which there is an increasing trend through time.
We can also fit a model in which the we specify a heterogeneous model but we do not give a \texttt{time.split}.
In this instance the model will test all splits that have at least 10 time slices on either side of the split.
That's 102 potential time shifts in this example dataset so be warned, the following code will estimate 105 models!

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# An example of a time split model in which all potential splits are tested}
\DocumentationTok{\#\# }\AlertTok{WARNING}\DocumentationTok{: this will take between 20 minutes and half and hour to run!}
\NormalTok{disp\_time }\OtherTok{\textless{}{-}} \FunctionTok{model.test.wrapper}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_disparity,}
                        \AttributeTok{model =} \FunctionTok{c}\NormalTok{(}\StringTok{"BM"}\NormalTok{, }\StringTok{"Trend"}\NormalTok{, }\StringTok{"OU"}\NormalTok{, }\StringTok{"multi.OU"}\NormalTok{),}
                                \AttributeTok{show.p =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{fixed.optima =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

As well as specifying a multi-OU model we can run any combination of models.
For example we could fit a model at the Cretaceous-Palaeogene boundary that goes from an OU to a BM model, a Trend to an OU model, a Stasis to a Trend model or any combination you want to use.
The only model that can't be used in combination is a multi-OU model.

These can be introduced by changing the input for the models into a list, and supplying a vector with the two models.
This is easier to see with an example:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The models to test}
\NormalTok{my\_models }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"BM"}\NormalTok{, }\StringTok{"OU"}\NormalTok{),}
                  \FunctionTok{c}\NormalTok{(}\StringTok{"Stasis"}\NormalTok{, }\StringTok{"OU"}\NormalTok{),}
                  \FunctionTok{c}\NormalTok{(}\StringTok{"BM"}\NormalTok{, }\StringTok{"Stasis"}\NormalTok{),}
                  \FunctionTok{c}\NormalTok{(}\StringTok{"OU"}\NormalTok{, }\StringTok{"Trend"}\NormalTok{),}
                  \FunctionTok{c}\NormalTok{(}\StringTok{"Stasis"}\NormalTok{, }\StringTok{"BM"}\NormalTok{))}

\DocumentationTok{\#\# Testing the models}
\NormalTok{disp\_time }\OtherTok{\textless{}{-}} \FunctionTok{model.test.wrapper}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_disparity,}
                                \AttributeTok{model =}\NormalTok{ my\_models, }\AttributeTok{time.split =} \DecValTok{66}\NormalTok{,}
                                \AttributeTok{show.p =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{fixed.optima =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Evidence of equal variance (Bartlett's test of equal variances p = 0).
## Variance is not pooled.
## Running BM:OU model...Done. Log-likelihood = 146.472
## Running Stasis:OU model...Done. Log-likelihood = 127.707
## Running BM:Stasis model...Done. Log-likelihood = 72.456
## Running OU:Trend model...Done. Log-likelihood = 150.208
## Running Stasis:BM model...Done. Log-likelihood = 127.707
\end{verbatim}

\begin{figure}

{\centering \includegraphics{dispRity_manual_files/figure-latex/plot6-1} 

}

\caption{Empirical disparity through time (pink), simulate data based on estimated model parameters (grey), delta AICc, and range of p values from the Rank Envelope test for a variety of models with a shift in optima allowed at 66 Ma}\label{fig:plot6}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{disp\_time}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           aicc delta_aicc weight_aicc log.lik param ancestral state
## OU:Trend  -292        0.0       0.977   150.2     4           3.218
## BM:OU     -285        7.5       0.023   146.5     4           3.216
## Stasis:BM -249       42.9       0.000   127.7     3              NA
## Stasis:OU -245       47.2       0.000   127.7     5              NA
## BM:Stasis -137      155.5       0.000    72.5     4           3.132
##           sigma squared alpha optima.1 theta.1 omega trend median p value
## OU:Trend          0.001 0.042       NA      NA    NA 0.011      0.3066933
## BM:OU             0.001 0.000    3.934      NA    NA    NA      0.4985015
## Stasis:BM         0.002    NA       NA    3.25 0.004    NA      0.9960040
## Stasis:OU         0.002 0.000    3.934    3.25 0.004    NA      0.9990010
## BM:Stasis         0.000    NA       NA    3.66 0.053    NA      1.0000000
##           lower p value upper p value
## OU:Trend      0.3026973     0.3626374
## BM:OU         0.4945055     0.5184815
## Stasis:BM     0.9950050     0.9960040
## Stasis:OU     0.9980020     1.0000000
## BM:Stasis     0.9990010     1.0000000
\end{verbatim}

\hypertarget{model.test.sim}{%
\subsection{\texorpdfstring{\texttt{model.test.sim}}{model.test.sim}}\label{model.test.sim}}

Note that all the models above where run using the \texttt{model.test.wrapper} function that is a\ldots{} wrapping function!
In practice, this function runs two main functions from the \texttt{dispRity} package and then plots the results:

\begin{itemize}
\tightlist
\item
  \texttt{model.test} and
\item
  \texttt{model.test.sim}
\end{itemize}

The \texttt{model.test.sim} allows to simulate disparity evolution given a \texttt{dispRity} object input (as in \texttt{model.test.wrapper}) or given a model and its specification.
For example, it is possible to simulate a simple Brownian motion model (or any of the other models or models combination described above):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A simple BM model}
\NormalTok{model\_simulation }\OtherTok{\textless{}{-}} \FunctionTok{model.test.sim}\NormalTok{(}\AttributeTok{sim =} \DecValTok{1000}\NormalTok{, }\AttributeTok{model =} \StringTok{"BM"}\NormalTok{,}
                                   \AttributeTok{time.span =} \DecValTok{50}\NormalTok{, }\AttributeTok{variance =} \FloatTok{0.1}\NormalTok{,}
                                   \AttributeTok{sample.size =} \DecValTok{100}\NormalTok{,}
                                   \AttributeTok{parameters =} \FunctionTok{list}\NormalTok{(}\AttributeTok{ancestral.state =} \DecValTok{0}\NormalTok{))}
\NormalTok{model\_simulation}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Disparity evolution model simulation:
## Call: model.test.sim(sim = 1000, model = "BM", time.span = 50, variance = 0.1, sample.size = 100, parameters = list(ancestral.state = 0)) 
## 
## Model simulated (1000 times):
## [1] "BM"
\end{verbatim}

This will simulate 1000 Brownian motions for 50 units of time with 100 sampled elements, a variance of 0.1 and an ancestral state of 0.
We can also pass multiple models in the same way we did it for \texttt{model.test}
This model can then be summarised and plotted as most \texttt{dispRity} objects:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Displaying the 5 first rows of the summary}
\FunctionTok{head}\NormalTok{(}\FunctionTok{summary}\NormalTok{(model\_simulation))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets   n var      median      2.5%        25%       75%    97.5%
## 1      50 100 0.1 -0.06195918 -1.963569 -0.7361336 0.5556715 1.806730
## 2      49 100 0.1 -0.09905061 -2.799025 -1.0670018 0.8836605 2.693583
## 3      48 100 0.1 -0.06215828 -3.594213 -1.3070097 1.1349712 3.272569
## 4      47 100 0.1 -0.10602238 -3.949521 -1.4363010 1.2234625 3.931000
## 5      46 100 0.1 -0.09016928 -4.277897 -1.5791755 1.3889584 4.507491
## 6      45 100 0.1 -0.13183180 -5.115647 -1.7791878 1.6270527 5.144023
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Plotting the simulations}
\FunctionTok{plot}\NormalTok{(model\_simulation)}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{dispRity_manual_files/figure-latex/plot7-1} 

}

\caption{A simulated Brownian motion}\label{fig:plot7}
\end{figure}

Note that these functions can take all the arguments that can be passed to \texttt{plot}, \texttt{summary}, \texttt{plot.dispRity} and \texttt{summary.dispRity}.

\hypertarget{simulating-tested-models}{%
\subsubsection{Simulating tested models}\label{simulating-tested-models}}

Maybe more interestingly though, it is possible to pass the output of \texttt{model.test} directly to \texttt{model.test.sim} to simulate the models that fits the data the best and calculate the Rank Envelope test \emph{p} value.
Let's see that using the simple example from the start:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Fitting multiple models on the data set}
\NormalTok{disp\_time }\OtherTok{\textless{}{-}} \FunctionTok{model.test}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_disparity,}
                    \AttributeTok{model =} \FunctionTok{c}\NormalTok{(}\StringTok{"Stasis"}\NormalTok{, }\StringTok{"BM"}\NormalTok{, }\StringTok{"OU"}\NormalTok{, }\StringTok{"Trend"}\NormalTok{, }\StringTok{"EB"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Evidence of equal variance (Bartlett's test of equal variances p = 0).
## Variance is not pooled.
## Running Stasis model...Done. Log-likelihood = -15.562
## Running BM model...Done. Log-likelihood = 151.637
## Running OU model...Done. Log-likelihood = 154.512
## Running Trend model...Done. Log-likelihood = 154.508
## Running EB model...Done. Log-likelihood = 128.008
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(disp\_time)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        aicc delta_aicc weight_aicc log.lik param theta.1 omega ancestral state
## Stasis   35      338.0       0.000   -15.6     2   3.486  0.07              NA
## BM     -299        3.6       0.108   151.6     2      NA    NA           3.132
## OU     -301        2.1       0.229   154.5     4      NA    NA           3.118
## Trend  -303        0.0       0.664   154.5     3      NA    NA           3.119
## EB     -250       53.0       0.000   128.0     3      NA    NA           3.934
##        sigma squared alpha optima.1 trend     eb
## Stasis            NA    NA       NA    NA     NA
## BM             0.001    NA       NA    NA     NA
## OU             0.001 0.001    10.18    NA     NA
## Trend          0.001    NA       NA 0.007     NA
## EB             0.000    NA       NA    NA -0.034
\end{verbatim}

As seen before, the Trend model fitted this dataset the best.
To simulate what 1000 Trend models would look like using the same parameters as the ones estimated with \texttt{model.test} (here the ancestral state being 3.119, the sigma squared being 0.001 and the trend of 0.007), we can simply pass this model to \texttt{model.test.sim}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Simulating 1000 Trend model with the observed parameters}
\NormalTok{sim\_trend }\OtherTok{\textless{}{-}} \FunctionTok{model.test.sim}\NormalTok{(}\AttributeTok{sim =} \DecValTok{1000}\NormalTok{, }\AttributeTok{model =}\NormalTok{ disp\_time)}
\NormalTok{sim\_trend}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Disparity evolution model simulation:
## Call: model.test.sim(sim = 1000, model = disp_time) 
## 
## Model simulated (1000 times):
##       aicc log.lik param ancestral state sigma squared trend
## Trend -303   154.5     3           3.119         0.001 0.007
## 
## Rank envelope test:
##  p-value of the global test: 0.992008 (ties method: erl)
##  p-interval                : (0.991009, 0.992008)
\end{verbatim}

By default, the model simulated is the one with the lowest AICc (\texttt{model.rank\ =\ 1}) but it is possible to choose any ranked model, for example, the OU (second one):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Simulating 1000 OU model with the observed parameters}
\NormalTok{sim\_OU }\OtherTok{\textless{}{-}} \FunctionTok{model.test.sim}\NormalTok{(}\AttributeTok{sim =} \DecValTok{1000}\NormalTok{, }\AttributeTok{model =}\NormalTok{ disp\_time,}
                         \AttributeTok{model.rank =} \DecValTok{2}\NormalTok{)}
\NormalTok{sim\_OU}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Disparity evolution model simulation:
## Call: model.test.sim(sim = 1000, model = disp_time, model.rank = 2) 
## 
## Model simulated (1000 times):
##    aicc log.lik param ancestral state sigma squared alpha optima.1
## OU -301   154.5     4           3.118         0.001 0.001    10.18
## 
## Rank envelope test:
##  p-value of the global test: 0.991009 (ties method: erl)
##  p-interval                : (0.989011, 0.991009)
\end{verbatim}

And as the example above, the simulated data can be plotted or summarised:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(}\FunctionTok{summary}\NormalTok{(sim\_trend))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n        var   median     2.5%      25%      75%    97.5%
## 1     120 5 0.01791717 3.119216 2.996786 3.082536 3.158256 3.241577
## 2     119 5 0.03522253 3.129400 2.958681 3.064908 3.186889 3.303168
## 3     118 6 0.03783622 3.133125 2.957150 3.076447 3.192556 3.304469
## 4     117 7 0.03214472 3.143511 2.978352 3.089036 3.199075 3.307842
## 5     116 7 0.03214472 3.147732 2.981253 3.087695 3.210136 3.321990
## 6     115 7 0.03214472 3.157588 2.969189 3.094733 3.216221 3.335341
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(}\FunctionTok{summary}\NormalTok{(sim\_OU))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets n        var   median     2.5%      25%      75%    97.5%
## 1     120 5 0.01791717 3.116975 3.002874 3.074977 3.158164 3.237559
## 2     119 5 0.03522253 3.126662 2.948491 3.061492 3.187414 3.302442
## 3     118 6 0.03783622 3.126408 2.966988 3.068517 3.195251 3.301177
## 4     117 7 0.03214472 3.136145 2.970973 3.079345 3.192427 3.301722
## 5     116 7 0.03214472 3.144302 2.967779 3.083789 3.205035 3.336560
## 6     115 7 0.03214472 3.151057 2.961801 3.086444 3.216077 3.336897
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The trend model with some graphical options}
\FunctionTok{plot}\NormalTok{(sim\_trend, }\AttributeTok{xlab =} \StringTok{"Time (Mya)"}\NormalTok{, }\AttributeTok{ylab =} \StringTok{"sum of variances"}\NormalTok{,}
    \AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{"\#F65205"}\NormalTok{, }\StringTok{"\#F38336"}\NormalTok{, }\StringTok{"\#F7B27E"}\NormalTok{))}

\DocumentationTok{\#\# Adding the observed disparity through time}
\FunctionTok{plot}\NormalTok{(BeckLee\_disparity, }\AttributeTok{add =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{"\#3E9CBA"}\NormalTok{, }\StringTok{"\#98D4CF90"}\NormalTok{, }\StringTok{"\#BFE4E390"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{figure}

{\centering \includegraphics{dispRity_manual_files/figure-latex/plot8-1} 

}

\caption{The best fitted model (Trend) and the observed disparity through time}\label{fig:plot8}
\end{figure}

\hypertarget{disparity-distribution}{%
\section{Disparity as a distribution}\label{disparity-distribution}}

Disparity is often regarded as a summary value of the position of the all elements in the ordinated space.
For example, the sum of variances, the product of ranges or the median distance between the elements and their centroid will summarise disparity as a single value.
This value can be pseudo-replicated (bootstrapped) to obtain a distribution of the summary metric with estimated error.
However, another way to perform disparity analysis is to use the \emph{whole distribution} rather than just a summary metric (e.g.~the variances or the ranges).

This is possible in the \texttt{dispRity} package by calculating disparity as a dimension-level 2 metric only!
Let's have a look using our \protect\hyperlink{summarising-dispRity-data-plots}{previous example} of bootstrapped time slices but by measuring the distances between each taxon and their centroid as disparity.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring disparity as a whole distribution}
\NormalTok{disparity\_centroids }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(boot\_time\_slices, }
                                \AttributeTok{metric =}\NormalTok{ centroids)}
\end{Highlighting}
\end{Shaded}

The resulting disparity object is of dimension-level 2, so it can easily be transformed into a dimension-level 1 object by, for example, measuring the median distance of all these distributions:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring median disparity in each time slice}
\NormalTok{disparity\_centroids\_median }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(disparity\_centroids,}
                                       \AttributeTok{metric =}\NormalTok{ median)}
\end{Highlighting}
\end{Shaded}

And we can now compare the differences between these methods:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Summarising both disparity measurements:}
\DocumentationTok{\#\# The distributions:}
\FunctionTok{summary}\NormalTok{(disparity\_centroids)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median bs.median  2.5%   25%   75% 97.5%
## 1     120  5      1.569     1.338 0.834 1.230 1.650 1.894
## 2      80 19      1.796     1.739 1.498 1.652 1.812 1.928
## 3      40 15      1.767     1.764 1.427 1.654 1.859 2.052
## 4       0 10      1.873     1.779 1.361 1.685 1.934 2.058
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The summary of the distributions (as median)}
\FunctionTok{summary}\NormalTok{(disparity\_centroids\_median)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs bs.median  2.5%   25%   75% 97.5%
## 1     120  5 1.569     1.351 0.648 1.282 1.596 1.641
## 2      80 19 1.796     1.739 1.655 1.721 1.756 1.787
## 3      40 15 1.767     1.757 1.623 1.721 1.793 1.837
## 4       0 10 1.873     1.781 1.564 1.756 1.834 1.900
\end{verbatim}

We can see that the summary message for the distribution is slightly different than before.
Here \texttt{summary} also displays the observed central tendency (i.e.~the central tendency of the measured distributions).
Note that, as expected, this central tendency is the same in both metrics!

Another, maybe more intuitive way, to compare both approaches for measuring disparity is to plot the distributions:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Graphical parameters}
\NormalTok{op }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{bty =} \StringTok{"n"}\NormalTok{, }\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{))}

\DocumentationTok{\#\# Plotting both disparity measurements}
\FunctionTok{plot}\NormalTok{(disparity\_centroids,}
     \AttributeTok{ylab =} \StringTok{"Distribution of all the distances"}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(disparity\_centroids\_median,}
     \AttributeTok{ylab =} \StringTok{"Distribution of the medians of all the distances"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-117-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(op)}
\end{Highlighting}
\end{Shaded}

We can then test for differences in the resulting distributions using \texttt{test.dispRity} and the \texttt{bhatt.coeff} test as described above.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Probability of overlap in the distribution of medians}
\FunctionTok{test.dispRity}\NormalTok{(disparity\_centroids\_median, }\AttributeTok{test =}\NormalTok{ bhatt.coeff)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          bhatt.coeff
## 120 : 80  0.08831761
## 120 : 40  0.10583005
## 120 : 0   0.15297059
## 80 : 40   0.83840952
## 80 : 0    0.63913150
## 40 : 0    0.78405839
\end{verbatim}

In this case, we are looking at the probability of overlap of the distribution of median distances from centroids among each pair of time slices.
In other words, we are measuring whether the medians from each bootstrap pseudo-replicate for each time slice overlap.
But of course, we might be interested in the actual distribution of the distances from the centroid rather than simply their central tendencies.
This can be problematic depending on the research question asked since we are effectively comparing non-independent medians distributions (because of the pseudo-replication).

One solution, therefore, is to look at the full distribution:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Probability of overlap for the full distributions}
\FunctionTok{test.dispRity}\NormalTok{(disparity\_centroids, }\AttributeTok{test =}\NormalTok{ bhatt.coeff)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          bhatt.coeff
## 120 : 80   0.6163631
## 120 : 40   0.6351473
## 120 : 0    0.6315225
## 80 : 40    0.9416508
## 80 : 0     0.8551990
## 40 : 0     0.9568684
\end{verbatim}

These results show the actual overlap among all the measured distances from centroids concatenated across all the bootstraps.
For example, when comparing the slices 120 and 80, we are effectively comparing the 5 \(\times\) 100 distances (the distances of the five elements in slice 120 bootstrapped 100 times) to the 19 \(\times\) 100 distances from slice 80.
However, this can also be problematic for some specific tests since the \emph{n} \(\times\) 100 distances are also pseudo-replicates and thus are still not independent.

A second solution is to compare the distributions to each other \emph{for each replicate}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Boostrapped probability of overlap for the full distributions}
\FunctionTok{test.dispRity}\NormalTok{(disparity\_centroids, }\AttributeTok{test =}\NormalTok{ bhatt.coeff,}
              \AttributeTok{concatenate =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          bhatt.coeff       2.5%       25%       75%     97.5%
## 120 : 80   0.2671081 0.00000000 0.1450953 0.3964076 0.6084459
## 120 : 40   0.2864771 0.00000000 0.1632993 0.4238587 0.6444474
## 120 : 0    0.2864716 0.00000000 0.2000000 0.4000000 0.5837006
## 80 : 40    0.6187295 0.24391229 0.5284793 0.7440196 0.8961621
## 80 : 0     0.4790692 0.04873397 0.3754429 0.5946595 0.7797225
## 40 : 0     0.5513580 0.19542869 0.4207790 0.6870177 0.9066824
\end{verbatim}

These results show the median overlap among pairs of distributions in the first column (\texttt{bhatt.coeff}) and then the distribution of these overlaps among each pair of bootstraps.
In other words, when two distributions are compared, they are now compared for each bootstrap pseudo-replicate, thus effectively creating a distribution of probabilities of overlap.
For example, when comparing the slices 120 and 80, we have a mean probability of overlap of 0.28 and a probability between 0.18 and 0.43 in 50\% of the pseudo-replicates.
Note that the quantiles and central tendencies can be modified via the \texttt{conc.quantiles} option.

\hypertarget{other-matrices}{%
\section{Disparity from other matrices}\label{other-matrices}}

In the example so far, disparity was measured from an ordinated multidimensional space (i.e.~a PCO of the distances between taxa based on discrete morphological characters).
This is a common approach in palaeobiology, morphometrics or ecology but ordinated matrices are not mandatory for the \texttt{dispRity} package!
It is totally possible to perform the same analysis detailed above using other types of matrices as long as your elements are rows in your matrix.

For example, we can use the data set \texttt{eurodist}, an \texttt{R} inbuilt dataset that contains the distances (in km) between European cities.
We can check for example, if Northern European cities are closer to each other than Southern ones:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Making the eurodist data set into a matrix (rather than "dist" object)}
\NormalTok{eurodist }\OtherTok{\textless{}{-}} \FunctionTok{as.matrix}\NormalTok{(eurodist)}
\NormalTok{eurodist[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           Athens Barcelona Brussels Calais Cherbourg
## Athens         0      3313     2963   3175      3339
## Barcelona   3313         0     1318   1326      1294
## Brussels    2963      1318        0    204       583
## Calais      3175      1326      204      0       460
## Cherbourg   3339      1294      583    460         0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The two groups of cities}
\NormalTok{Northern }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Brussels"}\NormalTok{, }\StringTok{"Calais"}\NormalTok{, }\StringTok{"Cherbourg"}\NormalTok{, }\StringTok{"Cologne"}\NormalTok{, }\StringTok{"Copenhagen"}\NormalTok{,}
              \StringTok{"Hamburg"}\NormalTok{, }\StringTok{"Hook of Holland"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"Stockholm"}\NormalTok{)}
\NormalTok{Southern }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"Athens"}\NormalTok{, }\StringTok{"Barcelona"}\NormalTok{, }\StringTok{"Geneva"}\NormalTok{, }\StringTok{"Gibraltar"}\NormalTok{, }\StringTok{"Lisbon"}\NormalTok{, }\StringTok{"Lyons"}\NormalTok{,}
              \StringTok{"Madrid"}\NormalTok{, }\StringTok{"Marseilles"}\NormalTok{, }\StringTok{"Milan"}\NormalTok{, }\StringTok{"Munich"}\NormalTok{, }\StringTok{"Rome"}\NormalTok{, }\StringTok{"Vienna"}\NormalTok{)}

\DocumentationTok{\#\# Creating the subset dispRity object}
\NormalTok{eurodist\_subsets }\OtherTok{\textless{}{-}} \FunctionTok{custom.subsets}\NormalTok{(eurodist, }\AttributeTok{group =} \FunctionTok{list}\NormalTok{(}\StringTok{"Northern"} \OtherTok{=}\NormalTok{ Northern,}
                                                        \StringTok{"Southern"} \OtherTok{=}\NormalTok{ Southern))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: custom.subsets is applied on what seems to be a distance matrix.
## The resulting matrices won't be distance matrices anymore!
## You can use dist.data = TRUE, if you want to keep the data as a distance matrix.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Bootstrapping and rarefying to 9 elements (the number of Northern cities)}
\NormalTok{eurodist\_bs }\OtherTok{\textless{}{-}} \FunctionTok{boot.matrix}\NormalTok{(eurodist\_subsets, }\AttributeTok{rarefaction =} \DecValTok{9}\NormalTok{)}

\DocumentationTok{\#\# Measuring disparity as the median distance from group\textquotesingle{}s centroid}
\NormalTok{euro\_disp }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(eurodist\_bs, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(median, centroids))}

\DocumentationTok{\#\# Testing the differences using a simple wilcox.test}
\NormalTok{euro\_diff }\OtherTok{\textless{}{-}} \FunctionTok{test.dispRity}\NormalTok{(euro\_disp, }\AttributeTok{test =}\NormalTok{ wilcox.test)}
\NormalTok{euro\_diff\_rar }\OtherTok{\textless{}{-}} \FunctionTok{test.dispRity}\NormalTok{(euro\_disp, }\AttributeTok{test =}\NormalTok{ wilcox.test, }\AttributeTok{rarefaction =} \DecValTok{9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can compare this approach to an ordination one:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Ordinating the eurodist matrix (with 11 dimensions)}
\NormalTok{euro\_ord }\OtherTok{\textless{}{-}} \FunctionTok{cmdscale}\NormalTok{(eurodist, }\AttributeTok{k =} \DecValTok{11}\NormalTok{)}

\DocumentationTok{\#\# Calculating disparity on the bootstrapped and rarefied subset data}
\NormalTok{euro\_ord\_disp }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(}\FunctionTok{boot.matrix}\NormalTok{(}\FunctionTok{custom.subsets}\NormalTok{(euro\_ord, }\AttributeTok{group =}
        \FunctionTok{list}\NormalTok{(}\StringTok{"Northern"} \OtherTok{=}\NormalTok{ Northern, }\StringTok{"Southern"} \OtherTok{=}\NormalTok{ Southern)), }\AttributeTok{rarefaction =} \DecValTok{9}\NormalTok{),}
        \AttributeTok{metric =} \FunctionTok{c}\NormalTok{(median, centroids))}

\DocumentationTok{\#\# Testing the differences using a simple wilcox.test}
\NormalTok{euro\_ord\_diff }\OtherTok{\textless{}{-}} \FunctionTok{test.dispRity}\NormalTok{(euro\_ord\_disp, }\AttributeTok{test =}\NormalTok{ wilcox.test)}
\NormalTok{euro\_ord\_diff\_rar }\OtherTok{\textless{}{-}} \FunctionTok{test.dispRity}\NormalTok{(euro\_ord\_disp, }\AttributeTok{test =}\NormalTok{ wilcox.test, }\AttributeTok{rarefaction =} \DecValTok{9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

And visualise the differences:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Plotting the differences}
\FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{), }\AttributeTok{bty =} \StringTok{"n"}\NormalTok{)}
\DocumentationTok{\#\# Plotting the normal disparity}
\FunctionTok{plot}\NormalTok{(euro\_disp, }\AttributeTok{main =} \StringTok{"Distance differences"}\NormalTok{)}
\DocumentationTok{\#\# Adding the p{-}value}
\FunctionTok{text}\NormalTok{(}\FloatTok{1.5}\NormalTok{, }\DecValTok{4000}\NormalTok{, }\FunctionTok{paste0}\NormalTok{(}\StringTok{"p="}\NormalTok{,}\FunctionTok{round}\NormalTok{(euro\_diff[[}\DecValTok{2}\NormalTok{]][[}\DecValTok{1}\NormalTok{]], }\AttributeTok{digit =} \DecValTok{5}\NormalTok{)))}
\DocumentationTok{\#\# Plotting the rarefied disparity}
\FunctionTok{plot}\NormalTok{(euro\_disp, }\AttributeTok{rarefaction =} \DecValTok{9}\NormalTok{, }\AttributeTok{main =} \StringTok{"Distance differences (rarefied)"}\NormalTok{)}
\DocumentationTok{\#\# Adding the p{-}value}
\FunctionTok{text}\NormalTok{(}\FloatTok{1.5}\NormalTok{, }\DecValTok{4000}\NormalTok{, }\FunctionTok{paste0}\NormalTok{(}\StringTok{"p="}\NormalTok{,}\FunctionTok{round}\NormalTok{(euro\_diff\_rar[[}\DecValTok{2}\NormalTok{]][[}\DecValTok{1}\NormalTok{]], }\AttributeTok{digit =} \DecValTok{5}\NormalTok{)))}

\DocumentationTok{\#\# Plotting the ordinated disparity}
\FunctionTok{plot}\NormalTok{(euro\_ord\_disp, }\AttributeTok{main =} \StringTok{"Ordinated differences"}\NormalTok{)}
\DocumentationTok{\#\# Adding the p{-}value}
\FunctionTok{text}\NormalTok{(}\FloatTok{1.5}\NormalTok{, }\DecValTok{1400}\NormalTok{, }\FunctionTok{paste0}\NormalTok{(}\StringTok{"p="}\NormalTok{,}\FunctionTok{round}\NormalTok{(euro\_ord\_diff[[}\DecValTok{2}\NormalTok{]][[}\DecValTok{1}\NormalTok{]], }\AttributeTok{digit =} \DecValTok{5}\NormalTok{) ))}
\DocumentationTok{\#\# Plotting the rarefied disparity}
\FunctionTok{plot}\NormalTok{(euro\_ord\_disp, }\AttributeTok{rarefaction =} \DecValTok{9}\NormalTok{, }\AttributeTok{main =} \StringTok{"Ordinated differences (rarefied)"}\NormalTok{)}
\DocumentationTok{\#\# Adding the p{-}value}
\FunctionTok{text}\NormalTok{(}\FloatTok{1.5}\NormalTok{, }\DecValTok{1400}\NormalTok{, }\FunctionTok{paste0}\NormalTok{(}\StringTok{"p="}\NormalTok{,}\FunctionTok{round}\NormalTok{(euro\_ord\_diff\_rar[[}\DecValTok{2}\NormalTok{]][[}\DecValTok{1}\NormalTok{]], }\AttributeTok{digit =} \DecValTok{5}\NormalTok{) ))}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-123-1.pdf}

As expected, the results are pretty similar in pattern but different in terms of scale.
The median centroids distance is expressed in km in the ``Distance differences'' plots and in Euclidean units of variation in the ``Ordinated differences'' plots.

\hypertarget{multi.input}{%
\section{Disparity from multiple matrices (and multiple trees!)}\label{multi.input}}

Since the version \texttt{1.4} of this package, it is possible to use multiple trees and multiple matrices in \texttt{dispRity} objects.
To use multiple matrices, this is rather easy: just supply a list of matrices to any of the \texttt{dispRity} functions and, as long as they have the same size and the same rownames they will be handled as a distribution of matrices.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# Creating 3 matrices with 4 dimensions and 10 elements each (called t1, t2, t3, etc...)}
\NormalTok{matrix\_list }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(}\DecValTok{3}\NormalTok{, }\FunctionTok{matrix}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{40}\NormalTok{), }\DecValTok{10}\NormalTok{, }\DecValTok{4}\NormalTok{, }\AttributeTok{dimnames =} \FunctionTok{list}\NormalTok{(}\FunctionTok{paste0}\NormalTok{(}\StringTok{"t"}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{))),}
                         \AttributeTok{simplify =} \ConstantTok{FALSE}\NormalTok{)}
\FunctionTok{class}\NormalTok{(matrix\_list) }\CommentTok{\# This is a list of matrices}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring some disparity metric on one of the matrices}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(matrix\_list[[}\DecValTok{1}\NormalTok{]], }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, variances)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n  obs
## 1       1 10 3.32
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring the same disparity metric on the three matrices}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(matrix\_list, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, variances)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1       1 10       3.32 3.044 3.175 3.381 3.435
\end{verbatim}

As you can see, when measuring the sum of variances on multiple matrices, we now have a distribution of sum of variances rather than a single observed value.

Similarly as running disparity analysis using multiple matrices, you can run the \texttt{chrono.subsets} function using multiple trees.
This can be useful if you want to use a tree posterior distribution rather than a single consensus tree.
These trees can be passed to \texttt{chrono.subsets} as a \texttt{"multiPhylo"} object (with the same node and tip labels in each tree).
First let's define a function to generate multiple trees with the same labels and root ages:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# Matches the trees and the matrices}
\DocumentationTok{\#\# A bunch of trees}
\NormalTok{make.tree }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(n, }\AttributeTok{fun =}\NormalTok{ rtree) \{}
    \DocumentationTok{\#\# Make the tree}
\NormalTok{    tree }\OtherTok{\textless{}{-}} \FunctionTok{fun}\NormalTok{(n)}
\NormalTok{    tree }\OtherTok{\textless{}{-}} \FunctionTok{chronos}\NormalTok{(tree, }\AttributeTok{quiet =} \ConstantTok{TRUE}\NormalTok{,}
                    \AttributeTok{calibration =} \FunctionTok{makeChronosCalib}\NormalTok{(tree, }\AttributeTok{age.min =} \DecValTok{10}\NormalTok{, }\AttributeTok{age.max =} \DecValTok{10}\NormalTok{))}
    \FunctionTok{class}\NormalTok{(tree) }\OtherTok{\textless{}{-}} \StringTok{"phylo"}
    \DocumentationTok{\#\# Add the node labels}
\NormalTok{    tree}\SpecialCharTok{$}\NormalTok{node.label }\OtherTok{\textless{}{-}} \FunctionTok{paste0}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\FunctionTok{Nnode}\NormalTok{(tree))}
    \DocumentationTok{\#\# Add the root time}
\NormalTok{    tree}\SpecialCharTok{$}\NormalTok{root.time }\OtherTok{\textless{}{-}} \FunctionTok{max}\NormalTok{(}\FunctionTok{tree.age}\NormalTok{(tree)}\SpecialCharTok{$}\NormalTok{ages)}
    \FunctionTok{return}\NormalTok{(tree)}
\NormalTok{\}}
\NormalTok{trees }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(}\DecValTok{3}\NormalTok{, }\FunctionTok{make.tree}\NormalTok{(}\DecValTok{10}\NormalTok{), }\AttributeTok{simplify =} \ConstantTok{FALSE}\NormalTok{)}
\FunctionTok{class}\NormalTok{(trees) }\OtherTok{\textless{}{-}} \StringTok{"multiPhylo"}
\NormalTok{trees}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 3 phylogenetic trees
\end{verbatim}

We can now simulate some ancestral states for the matrices in the example above to have multiple matrices associated with the multiple trees.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A function for running the ancestral states estimations}
\NormalTok{do.ace }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(tree, matrix) \{}
    \DocumentationTok{\#\# Run one ace}
\NormalTok{    fun.ace }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(character, tree) \{}
\NormalTok{        results }\OtherTok{\textless{}{-}} \FunctionTok{ace}\NormalTok{(character, }\AttributeTok{phy =}\NormalTok{ tree)}\SpecialCharTok{$}\NormalTok{ace}
        \FunctionTok{names}\NormalTok{(results) }\OtherTok{\textless{}{-}} \FunctionTok{paste0}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\FunctionTok{Nnode}\NormalTok{(tree))}
        \FunctionTok{return}\NormalTok{(results)}
\NormalTok{    \}}
    \DocumentationTok{\#\# Run all ace}
    \FunctionTok{return}\NormalTok{(}\FunctionTok{rbind}\NormalTok{(matrix, }\FunctionTok{apply}\NormalTok{(matrix, }\DecValTok{2}\NormalTok{, fun.ace, }\AttributeTok{tree =}\NormalTok{ tree)))}
\NormalTok{\}}

\DocumentationTok{\#\# All matrices}
\NormalTok{matrices }\OtherTok{\textless{}{-}} \FunctionTok{mapply}\NormalTok{(do.ace, trees, matrix\_list, }\AttributeTok{SIMPLIFY =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Let's first see an example of time-slicing with one matrix and multiple trees.
This assumes that your tip values (observed) and node values (estimated) are fixed with no error on them.
It also assumes that the nodes in the matrix always corresponds to the node in the trees (in other words, the tree topologies are fixed):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Making three "proximity" time slices across one tree}
\NormalTok{one\_tree }\OtherTok{\textless{}{-}} \FunctionTok{chrono.subsets}\NormalTok{(matrices[[}\DecValTok{1}\NormalTok{]], trees[[}\DecValTok{1}\NormalTok{]],}
                           \AttributeTok{method =} \StringTok{"continuous"}\NormalTok{,}
                           \AttributeTok{model =} \StringTok{"proximity"}\NormalTok{, }\AttributeTok{time =} \DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\# Making three "proximity" time slices across the three trees}
\NormalTok{three\_tree }\OtherTok{\textless{}{-}} \FunctionTok{chrono.subsets}\NormalTok{(matrices[[}\DecValTok{1}\NormalTok{]], trees,}
                             \AttributeTok{method =} \StringTok{"continuous"}\NormalTok{,}
                             \AttributeTok{model =} \StringTok{"proximity"}\NormalTok{, }\AttributeTok{time =} \DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\# Measuring disparity as the sum of variances and summarising it}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(one\_tree, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, variances)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n   obs
## 1     8.3  3 0.079
## 2    4.15  5 2.905
## 3       0 10 3.320
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(three\_tree, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, variances)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1     7.9  3      0.253 0.088 0.166 0.309 0.360
## 2    3.95  5      0.257 0.133 0.192 1.581 2.773
## 3       0 10      3.320 3.320 3.320 3.320 3.320
\end{verbatim}

This results show the effect of considering a tree distribution: in the first case (\texttt{one\_tree}) the time slice at 3.95 Mya has a sum of variances of 2.9 but this values goes down to 0.256 in the second case (\texttt{three\_tree}) which is due to the differences in branch lengths distributions:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\NormalTok{slices }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FloatTok{7.9}\NormalTok{, }\FloatTok{3.95}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\NormalTok{fun.plot }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(tree) \{}
  \FunctionTok{plot}\NormalTok{(tree)}
  \FunctionTok{nodelabels}\NormalTok{(tree}\SpecialCharTok{$}\NormalTok{node.label, }\AttributeTok{cex =} \FloatTok{0.8}\NormalTok{)}
  \FunctionTok{axisPhylo}\NormalTok{()}
  \FunctionTok{abline}\NormalTok{(}\AttributeTok{v =}\NormalTok{ tree}\SpecialCharTok{$}\NormalTok{root.time }\SpecialCharTok{{-}}\NormalTok{ slices)}
\NormalTok{\}}
\NormalTok{silent }\OtherTok{\textless{}{-}} \FunctionTok{lapply}\NormalTok{(trees, fun.plot)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-128-1.pdf}

Note that in this example, the nodes are actually even different in each tree! The node \texttt{n4} for example, is not direct descendent of \texttt{t4} and \texttt{t6} in all trees!
To fix that, it is possible to input a list of trees and a list of matrices that correspond to each tree in \texttt{chrono.subsets} by using the \texttt{bind.data\ =\ TRUE} option.
In this case, the matrices need to all have the same row names and the trees all need the same labels as before:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Making three "proximity" time slices across three trees and three bound matrices}
\NormalTok{bound\_data }\OtherTok{\textless{}{-}} \FunctionTok{chrono.subsets}\NormalTok{(matrices, trees,}
                             \AttributeTok{method =} \StringTok{"continuous"}\NormalTok{,}
                             \AttributeTok{model =} \StringTok{"proximity"}\NormalTok{,}
                             \AttributeTok{time =} \DecValTok{3}\NormalTok{,}
                             \AttributeTok{bind.data =} \ConstantTok{TRUE}\NormalTok{)}
\DocumentationTok{\#\# Making three "proximity" time slices across three trees and three matrices}
\NormalTok{unbound\_data }\OtherTok{\textless{}{-}} \FunctionTok{chrono.subsets}\NormalTok{(matrices, trees,}
                               \AttributeTok{method =} \StringTok{"continuous"}\NormalTok{,}
                               \AttributeTok{model =} \StringTok{"proximity"}\NormalTok{,}
                               \AttributeTok{time =} \DecValTok{3}\NormalTok{,}
                               \AttributeTok{bind.data =} \ConstantTok{FALSE}\NormalTok{)}

\DocumentationTok{\#\# Measuring disparity as the sum of variances and summarising it}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(bound\_data, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, variances)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median  2.5%   25%   75% 97.5%
## 1     7.9  3      0.079 0.076 0.077 0.273 0.447
## 2    3.95  5      1.790 0.354 1.034 2.348 2.850
## 3       0 10      3.320 3.044 3.175 3.381 3.435
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(unbound\_data, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, variances)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   subsets  n obs.median 2.5%  25%  75% 97.5%
## 1     7.9  3       0.79 0.48 0.63 0.83  0.85
## 2    3.95  5       3.25 1.36 2.25 3.94  4.56
## 3       0 10       9.79 9.79 9.79 9.79  9.79
\end{verbatim}

Note here that the results are again rather different: with the bound data, the slices are done across the three trees and each of their corresponding matrix (resulting in three observation) which is more accurate than the previous results from \texttt{three\_trees} above.
With the unbound data, the slices are done across the three trees and applied to the three matrices (resulting in 9 observations).
As we've seen before, this is incorrect in this case since the trees don't have the same topology (so the nodes selected by a slice through the second tree are not equivalent to the nodes in the first matrix) but it can be useful if the topology is fixed to integrate both uncertainty in branch length (slicing through different trees) and uncertainty from, say, ancestral states estimations (applying the slices on different matrices).

Note that since the version \texttt{1.8} the trees and the matrices don't have to match allowing to run disparity analyses with variable matrices and trees.
This can be useful when running ancestral states estimations from a tree distribution where not all trees have the same topology.

\hypertarget{dispRitree}{%
\section{\texorpdfstring{Disparity with trees: \emph{dispRitree!}}{Disparity with trees: dispRitree!}}\label{dispRitree}}

Since the package's version 1.5.10, trees can be directly attached to \texttt{dispRity} objects.
This allows any function in the package that has an input argument called ``\texttt{tree}'' to automatically intake the tree from the \texttt{dispRity} object.
This is especially useful for disparity metrics that requires calculations based on a phylogenetic tree (e.g.~\texttt{ancestral.dist} or \texttt{projections.tree}) and if phylogeny (or phylogenie*s*) are going to be an important part of your analyses.

Trees are attached to \texttt{dispRity} object as soon as they are called in any function of the package (e.g.~as an argument in \texttt{chrono.subsets} or in \texttt{dispRity}) and are stored in \texttt{my\_dispRity\_object\$tree}.
You can always manually attach, detach or modify the tree parts of a \texttt{dispRity} object using the utility functions \texttt{get.tree} (to access the trees), \texttt{remove.tree} (to remove it) and \texttt{add.tree} (to\ldots{} add trees!).
The only requirement for this to work is that the labels in the tree must match the ones in the data.
If the tree has node labels, their node labels must also match the data.
Similarly if the data has entries for node labels, they must be present in the tree.

Here is a quick demo on how attaching trees to \texttt{dispRity} objects can work and make your life easy: for example here we will measure how the sum of branch length changes through time when time slicing through some demo data with a acctran split time slice model (see more info \protect\hyperlink{chrono-subsets}{here}).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading some demo data:}
\DocumentationTok{\#\# An ordinated matrix with node and tip labels}
\FunctionTok{data}\NormalTok{(BeckLee\_mat99)}
\DocumentationTok{\#\# The corresponding tree with tip and node labels}
\FunctionTok{data}\NormalTok{(BeckLee\_tree)}
\DocumentationTok{\#\# A list of tips ages for the fossil data}
\FunctionTok{data}\NormalTok{(BeckLee\_ages)}

\DocumentationTok{\#\# Time slicing through the tree using the equal split algorithm}
\NormalTok{time\_slices }\OtherTok{\textless{}{-}} \FunctionTok{chrono.subsets}\NormalTok{(}\AttributeTok{data   =}\NormalTok{ BeckLee\_mat99,}
                              \AttributeTok{tree   =}\NormalTok{ BeckLee\_tree,}
                              \AttributeTok{FADLAD =}\NormalTok{ BeckLee\_ages,}
                              \AttributeTok{method =} \StringTok{"continuous"}\NormalTok{,}
                              \AttributeTok{model  =} \StringTok{"acctran"}\NormalTok{,}
                              \AttributeTok{time   =} \DecValTok{15}\NormalTok{)}

\DocumentationTok{\#\# We can visualise the resulting trait space with the phylogeny}
\DocumentationTok{\#\# (using the specific argument as follows)}
\FunctionTok{plot}\NormalTok{(time\_slices, }\AttributeTok{type =} \StringTok{"preview"}\NormalTok{,}
     \AttributeTok{specific.args =} \FunctionTok{list}\NormalTok{(}\AttributeTok{tree =} \ConstantTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-130-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Note that some nodes are never selected thus explaining the branches not reaching them.}
\end{Highlighting}
\end{Shaded}

And we can then measure disparity as the sum of the edge length at each time slice on the bootstrapped data:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring the sum of the edge length per slice}
\NormalTok{sum\_edge\_length }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(}\FunctionTok{boot.matrix}\NormalTok{(time\_slices), }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, edge.length.tree))}
\DocumentationTok{\#\# Summarising and plotting}
\FunctionTok{summary}\NormalTok{(sum\_edge\_length)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    subsets  n  obs bs.median 2.5%  25%  75% 97.5%
## 1   133.51  3   51        51   36   40   61    69
## 2   123.97  6  163       166  141  158  172   188
## 3   114.44  9  332       331  287  317  354   383
## 4    104.9 12  558       565  489  540  587   620
## 5    95.37 15  762       763  723  745  782   815
## 6    85.83 20 1303      1305 1218 1271 1342  1415
## 7    76.29 19 1565      1559 1408 1491 1620  1802
## 8    66.76 23 2055      2040 1865 1965 2095  2262
## 9    57.22 20 2029      2031 1842 1949 2091  2190
## 10   47.68 16 1908      1892 1727 1840 1945  2057
## 11   38.15 16 2017      2016 1910 1975 2081  2152
## 12   28.61 10 1391      1391 1391 1391 1391  1391
## 13   19.07 10 1391      1391 1391 1391 1391  1391
## 14    9.54 10 1391      1391 1391 1391 1391  1391
## 15       0 10 1391      1391 1391 1391 1391  1391
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(sum\_edge\_length)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-131-1.pdf}

Of course this can be done with multiple trees and be combined with an approach using multiple matrices (see \protect\hyperlink{multi.input}{here})!

\hypertarget{covar}{%
\section{Disparity of variance-covariance matrices (covar)}\label{covar}}

Variance-covariance matrices are sometimes a useful way to summarise multidimensional data.
In fact, you can express the variation in your multidimensional dataset directly in terms of how your trait covary rather than simply the positions of your elements in the trait space.
Furthermore, variance-covariance matrices can be estimated from multidimensional in sometimes more useful ways that simply looking at the the data in your trait space.
This can be done by describing your data as hierarchical models like generalised linear mixed effect models (glmm).
For example, you might have a multidimensional dataset where your observations have a nested structure (e.g.~they are part of the same phylogeny).
You can then analyse this data using a glmm with something like \texttt{my\_data\ \textasciitilde{}\ observations\ +\ phylogeny\ +\ redisduals}.
For more info on these models \href{https://en.wikipedia.org/wiki/Generalized_linear_mixed_model}{start here}.
For more details on running these models, I suggest using the \texttt{MCMCglmm} package (\citet{MCMCglmm}) from \citet{hadfield2010} (but see also \citet{mulTree}).
For an example use of this code, see \citet{guillerme2023innovation}.

\hypertarget{creating-a-disprity-object-with-a-covar-component}{%
\subsection{\texorpdfstring{Creating a \texttt{dispRity} object with a \texttt{\$covar} component}{Creating a dispRity object with a \$covar component}}\label{creating-a-disprity-object-with-a-covar-component}}

Once you have a trait space and variance-covariance matrices output from the \texttt{MCMCglmm} model, you can use the function \texttt{MCMCglmm.subsets} to create a \texttt{"dispRity"} object that contains the classic \texttt{"dispRity"} data (the matrix, the subsets, etc\ldots) but also a the new \texttt{\$covar} element:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading the charadriiformes data}
\FunctionTok{data}\NormalTok{(charadriiformes)}
\end{Highlighting}
\end{Shaded}

Here we using precaculated variance-covariance matrices from the charadriiformes dataset that contains a set of posteriors from a \texttt{MCMCglmm} model.
The model here was \texttt{data\ \textasciitilde{}\ traits\ +\ clade\ specific\ phylogenetic\ effect\ +\ global\ phylogenetic\ effect\ +\ residuals}.
We can retrieve the model information using the \protect\hyperlink{MCMCglmm-utilities}{\texttt{MCMCglmm} utilities} tools, namely the \texttt{MCMCglmm.levels} function to directly extract the terms names as used in the model and then build our \texttt{"dispRity"} object with the correct data, the posteriors and the correct term names:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The term names}
\NormalTok{model\_terms }\OtherTok{\textless{}{-}} \FunctionTok{MCMCglmm.levels}\NormalTok{(charadriiformes}\SpecialCharTok{$}\NormalTok{posteriors)[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{]}
\DocumentationTok{\#\# Note that we\textquotesingle{}re ignoring the 5th term of the model that\textquotesingle{}s just the normal residuals}

\DocumentationTok{\#\# The dispRity object}
\FunctionTok{MCMCglmm.subsets}\NormalTok{(}\AttributeTok{data =}\NormalTok{ charadriiformes}\SpecialCharTok{$}\NormalTok{data,}
                 \AttributeTok{posteriors =}\NormalTok{ charadriiformes}\SpecialCharTok{$}\NormalTok{posteriors,}
                 \AttributeTok{group =}\NormalTok{ model\_terms)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 4 covar subsets for 359 elements in one matrix with 3 dimensions:
##     animal:clade_1, animal:clade_2, animal:clade_3, animal.
## Data is based on 1000 posterior samples.
\end{verbatim}

As you can see this creates a normal dispRity object with the information you are now familiar with.
However, we can be more fancy and provide more understandable names for the groups and provide the underlying phylogenetic structure used:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A fancier dispRity object}
\NormalTok{my\_covar }\OtherTok{\textless{}{-}} \FunctionTok{MCMCglmm.subsets}\NormalTok{(}\AttributeTok{data =}\NormalTok{ charadriiformes}\SpecialCharTok{$}\NormalTok{data,}
                             \AttributeTok{posteriors =}\NormalTok{ charadriiformes}\SpecialCharTok{$}\NormalTok{posteriors,}
                             \AttributeTok{group =}\NormalTok{ model\_terms,}
                             \AttributeTok{tree =}\NormalTok{ charadriiformes}\SpecialCharTok{$}\NormalTok{tree,}
                             \AttributeTok{rename.groups =} \FunctionTok{c}\NormalTok{(}\FunctionTok{levels}\NormalTok{(charadriiformes}\SpecialCharTok{$}\NormalTok{data}\SpecialCharTok{$}\NormalTok{clade), }\StringTok{"phylogeny"}\NormalTok{))}
\DocumentationTok{\#\# Note that the group names is contained in the clade column of the charadriiformes dataset as factors}
\end{Highlighting}
\end{Shaded}

\hypertarget{visualising-covar-objects}{%
\subsection{Visualising covar objects}\label{visualising-covar-objects}}

One useful thing to do with these objects is then to visualise them in 2D.
Here we can use the \texttt{covar.plot} function (that has many different options that just \texttt{plot.dispRity} for plotting covar objects) to plot the trait space, the 95\% confidence interval ellipses of the variance-covariance matrices and the major axes from these ellipses.
See the \texttt{?covar.plot} help page for all the options available:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\DocumentationTok{\#\# The traitspace}
\FunctionTok{covar.plot}\NormalTok{(my\_covar, }\AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{"orange"}\NormalTok{, }\StringTok{"darkgreen"}\NormalTok{, }\StringTok{"blue"}\NormalTok{), }\AttributeTok{main =} \StringTok{"Trait space"}\NormalTok{)}
\DocumentationTok{\#\# The traitspace\textquotesingle{}s variance{-}covariance mean ellipses}
\FunctionTok{covar.plot}\NormalTok{(my\_covar, }\AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{"orange"}\NormalTok{, }\StringTok{"darkgreen"}\NormalTok{, }\StringTok{"blue"}\NormalTok{, }\StringTok{"grey"}\NormalTok{), }\AttributeTok{main =} \StringTok{"Mean VCV ellipses"}\NormalTok{,}
           \AttributeTok{points =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{ellipses =}\NormalTok{ mean) }
\DocumentationTok{\#\# The traitspace\textquotesingle{}s variance{-}covariance mean ellipses}
\FunctionTok{covar.plot}\NormalTok{(my\_covar, }\AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{"orange"}\NormalTok{, }\StringTok{"darkgreen"}\NormalTok{, }\StringTok{"blue"}\NormalTok{, }\StringTok{"grey"}\NormalTok{), }\AttributeTok{main =} \StringTok{"Mean major axes"}\NormalTok{,}
           \AttributeTok{points =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{major.axes =}\NormalTok{ mean)}
\DocumentationTok{\#\# A bit of everything}
\FunctionTok{covar.plot}\NormalTok{(my\_covar, }\AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{"orange"}\NormalTok{, }\StringTok{"darkgreen"}\NormalTok{, }\StringTok{"blue"}\NormalTok{, }\StringTok{"grey"}\NormalTok{), }\AttributeTok{main =} \StringTok{"Ten random VCV matrices"}\NormalTok{,}
           \AttributeTok{points =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{major.axes =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{points.cex =} \DecValTok{1}\SpecialCharTok{/}\DecValTok{3}\NormalTok{, }\AttributeTok{n =} \DecValTok{10}\NormalTok{, }\AttributeTok{ellipses =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{legend =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-135-1.pdf}

\hypertarget{disparity-analyses-with-a-covar-component}{%
\subsection{\texorpdfstring{Disparity analyses with a \texttt{\$covar} component}{Disparity analyses with a \$covar component}}\label{disparity-analyses-with-a-covar-component}}

You can then calculate disparity on the \texttt{"dispRity"} object like shown previously.
For example, you can get the variances of the groups that where used in the model by using the normal \texttt{dispRity} function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(my\_covar, }\AttributeTok{metric =}\NormalTok{ variances))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      subsets   n obs.median  2.5%   25%   75% 97.5%
## 1      gulls 159      0.009 0.009 0.009 0.129 0.238
## 2    plovers  98      0.008 0.003 0.005 0.173 0.321
## 3 sandpipers 102      0.007 0.003 0.005 0.177 0.331
## 4  phylogeny 359      0.023 0.007 0.015 0.166 0.294
\end{verbatim}

However this is not applied on the variance-covariance matrices from the posteriors of the \texttt{MCMCglmm}.
To do that, you need to modify the metric to be recognised as a ``covar'' metric using the \texttt{as.covar} function.
This function transforms any disparity metric (or disparity metric style function) to be applied to the \texttt{\$covar} part of a \texttt{"dispRity"} object.
Basically this \texttt{\$covar} part is a list containing, for each posterior sample \texttt{\$VCV}, the variance-covariance matrix and \texttt{\$loc}, it's optional location in the traitspace.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The first variance covariance matrix for the "gulls" group}
\NormalTok{my\_covar}\SpecialCharTok{$}\NormalTok{covar[[}\StringTok{"gulls"}\NormalTok{]][[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $VCV
##             [,1]          [,2]          [,3]
## [1,]  0.23258067 -2.180519e-02 -2.837630e-02
## [2,] -0.02180519  3.137106e-02 -8.711996e-05
## [3,] -0.02837630 -8.711996e-05  1.943929e-02
## 
## $loc
## [1]  0.0007118691  0.1338917465 -0.0145412698
\end{verbatim}

And this is how \texttt{as.covar} modifies the disparity metric:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Using the variances function on a VCV matrix}
\FunctionTok{variances}\NormalTok{(my\_covar}\SpecialCharTok{$}\NormalTok{covar[[}\StringTok{"gulls"}\NormalTok{]][[}\DecValTok{1}\NormalTok{]]}\SpecialCharTok{$}\NormalTok{VCV)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.0221423147 0.0007148342 0.0005779815
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The same but using it as a covar metric}
\FunctionTok{as.covar}\NormalTok{(variances)(my\_covar}\SpecialCharTok{$}\NormalTok{covar[[}\StringTok{"gulls"}\NormalTok{]][[}\DecValTok{1}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.0221423147 0.0007148342 0.0005779815
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The same but applied to the dispRity function}
\FunctionTok{summary}\NormalTok{(}\FunctionTok{dispRity}\NormalTok{(my\_covar, }\AttributeTok{metric =} \FunctionTok{as.covar}\NormalTok{(variances)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      subsets   n obs.median 2.5% 25%   75% 97.5%
## 1      gulls 159      0.001    0   0 0.012 0.068
## 2    plovers  98      0.000    0   0 0.000 0.002
## 3 sandpipers 102      0.000    0   0 0.000 0.016
## 4  phylogeny 359      0.000    0   0 0.006 0.020
\end{verbatim}

\hypertarget{disparity-and-distances}{%
\section{Disparity and distances}\label{disparity-and-distances}}

There are two ways to use distances in \texttt{dispRity}, either with your input data being directly a distance matrix or with your disparity metric involving some kind of distance calculations.

\hypertarget{disparity-data-is-a-distance}{%
\subsection{Disparity data is a distance}\label{disparity-data-is-a-distance}}

If your disparity data is a distance matrix, you can use the option \texttt{dist.data\ =\ TRUE} in \texttt{dispRity} to make sure that all the operations done on your data take into account the fact that your disparity data has distance properties.
For example, if you bootstrap the data, this will automatically bootstrap both rows AND columns (i.e.~so that the bootstrapped matrices are still distances).
This also improves speed on some calculations if you use \protect\hyperlink{disparity-metrics}{disparity metrics} directly implemented in the package by avoiding recalculating distances (the full list can be seen in \texttt{?dispRity.metric} - they are usually the metrics with \texttt{dist} in their name).

\hypertarget{subsets}{%
\subsubsection{Subsets}\label{subsets}}

By default, the \texttt{dispRity} package does not treat any matrix as a distance matrix.
It will however try to guess whether your input data is a distance matrix or not.
This means that if you input a distance matrix, you might get a warning letting you know the input matrix might not be treated correctly (e.g.~when bootstrapping or subsetting).
For the functions \texttt{dispRity}, \texttt{custom.subsets} and \texttt{chrono.subsets} you can simply toggle the option \texttt{dist.data\ =\ TRUE} to make sure you treat your input data as a distance matrix throughout your analysis.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating a distance matrix}
\NormalTok{distance\_data }\OtherTok{\textless{}{-}} \FunctionTok{as.matrix}\NormalTok{(}\FunctionTok{dist}\NormalTok{(BeckLee\_mat50))}

\DocumentationTok{\#\# Measuring the diagonal of the distance matrix}
\FunctionTok{dispRity}\NormalTok{(distance\_data, }\AttributeTok{metric =}\NormalTok{ diag, }\AttributeTok{dist.data =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 50 elements in one matrix with 50 dimensions.
## Disparity was calculated as: diag.
\end{verbatim}

If you use a pipeline of any of these functions, you only need to specify it once and the data will be treated as a distance matrix throughout.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating a distance matrix}
\NormalTok{distance\_data }\OtherTok{\textless{}{-}} \FunctionTok{as.matrix}\NormalTok{(}\FunctionTok{dist}\NormalTok{(BeckLee\_mat50))}

\DocumentationTok{\#\# Creating two subsets specifying that the data is a distance matrix}
\NormalTok{subsets }\OtherTok{\textless{}{-}} \FunctionTok{custom.subsets}\NormalTok{(distance\_data, }\AttributeTok{group =} \FunctionTok{list}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{), }\FunctionTok{c}\NormalTok{(}\DecValTok{6}\SpecialCharTok{:}\DecValTok{10}\NormalTok{)), }\AttributeTok{dist.data =} \ConstantTok{TRUE}\NormalTok{)}
\DocumentationTok{\#\# Measuring disparity treating the data as distance matrices}
\FunctionTok{dispRity}\NormalTok{(subsets, }\AttributeTok{metric =}\NormalTok{ diag)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 2 customised subsets for 50 elements in one matrix with 50 dimensions:
##     1, 2.
## Disparity was calculated as: diag.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring disparity treating the data as a normal matrix (toggling the option to FALSE)}
\FunctionTok{dispRity}\NormalTok{(subsets, }\AttributeTok{metric =}\NormalTok{ diag, }\AttributeTok{dist.data =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in dispRity(subsets, metric = diag, dist.data = FALSE): data.dist is
## set to FALSE (the data will not be treated as a distance matrix) even though
## subsets contains distance treated data.
\end{verbatim}

\begin{verbatim}
##  ---- dispRity object ---- 
## 2 customised subsets for 50 elements in one matrix with 50 dimensions:
##     1, 2.
## Disparity was calculated as: diag.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Note that a warning appears but the function still runs}
\end{Highlighting}
\end{Shaded}

\hypertarget{bootstrapping}{%
\subsubsection{Bootstrapping}\label{bootstrapping}}

The function \texttt{boot.matrix} also can deal with distance matrices by bootstrapping both rows and columns in a linked way (e.g.~if a bootstrap pseudo-replicate draws the values 1, 2, and 5, it will select both columns 1, 2, and 5 and rows 1, 2, and 5 - keeping the distance structure of the data).
You can do that by using the \texttt{boot.by\ =\ "dist"} function that will bootstrap the data in a distance matrix fashion:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring the diagonal of a bootstrapped matrix}
\FunctionTok{boot.matrix}\NormalTok{(distance\_data, }\AttributeTok{boot.by =} \StringTok{"dist"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 50 elements in one matrix with 50 dimensions.
## Rows and columns were bootstrapped 100 times (method:"full").
\end{verbatim}

Similarly to the \texttt{dispRity}, \texttt{custom.subsets} and \texttt{chrono.subsets} function above, the option to treat the input data as a distance matrix is recorded and recycled so there is no need to specify it each time.

\hypertarget{disparity-metric-is-a-distance}{%
\subsection{Disparity metric is a distance}\label{disparity-metric-is-a-distance}}

On the other hand if your data is not a distance matrix but you are using a metric that uses some kind of distance calculations, you can use the option \texttt{dist.helper} to greatly speed up calculations.
\texttt{dist.helper} can be either a pre-calculated distance matrix (or a list of distance matrices) or, better yet, a function to calculate distance matrices, like \texttt{stats::dist} or \texttt{vegan::vegdist}.
This option directly stores the distance matrix separately in the RAM and allows the disparity metric to directly access it at every disparity calculation iteration, making it much faster.
Note that if you provide a function for \texttt{dist.helper}, you can also provide any un-ambiguous optional argument to that function, for example \texttt{method\ =\ "euclidean"}.

If you use a disparity metric implemented in \texttt{dispRity}, the \texttt{dist.helper} option is correctly loaded onto the RAM regardless of the argument you provide (a matrix, a list of matrix or any function to calculate a distance matrix).
On the other hand, if you use your own function for the disparity metric, make sure that \texttt{dist.helper} exactly matches the internal distance calculation function.
For example if you use the already implemented \texttt{pairwise.dist} metric all the following options will be using \texttt{dist.helper} optimally:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Using the dist function from stats (specifying it comes from stats)}
\FunctionTok{dispRity}\NormalTok{(my\_data, }\AttributeTok{metric =}\NormalTok{ pairwise.dist, }\AttributeTok{dist.helper =}\NormalTok{ stats}\SpecialCharTok{::}\NormalTok{dist)}

\DocumentationTok{\#\# Using the dist function from vegdist function (without specifying its origin)}
\FunctionTok{dispRity}\NormalTok{(my\_data, }\AttributeTok{metric =}\NormalTok{ pairwise.dist, }\AttributeTok{dist.helper =}\NormalTok{ vegdist)}

\DocumentationTok{\#\# Using some pre{-}calculated distance with a generic function}
\NormalTok{my\_distance\_matrix }\OtherTok{\textless{}{-}} \FunctionTok{dist}\NormalTok{(my\_distance\_data)}
\FunctionTok{dispRity}\NormalTok{(my\_data, }\AttributeTok{metric =}\NormalTok{ pairwise.dist, }\AttributeTok{dist.helper =}\NormalTok{ my\_distance\_matrix)}

\DocumentationTok{\#\# Using some pre{-}calculated distance with a user function defined elsewhere}
\NormalTok{my\_distance\_matrix }\OtherTok{\textless{}{-}} \FunctionTok{my.personalised.function}\NormalTok{(my\_distance\_data)}
\FunctionTok{dispRity}\NormalTok{(my\_data, }\AttributeTok{metric =}\NormalTok{ pairwise.dist, }\AttributeTok{dist.helper =}\NormalTok{ my\_distance\_matrix)}
\end{Highlighting}
\end{Shaded}

However, if you use a homemade metric for calculating distances like this:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# a personalised distance function}
\NormalTok{my.sum.of.dist }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(matrix) \{}
  \FunctionTok{return}\NormalTok{(}\FunctionTok{sum}\NormalTok{(}\FunctionTok{dist}\NormalTok{(matrix)))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{dist.helper} will only work if you specify the function using the same syntax as in the user function:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The following uses the helper correctly (as in saves a lot of calculation time)}
\FunctionTok{dispRity}\NormalTok{(my\_data, }\AttributeTok{metric =}\NormalTok{ my.sum.of.dist, }\AttributeTok{dist.helper =}\NormalTok{ dist)}

\DocumentationTok{\#\# These ones however, work but don\textquotesingle{}t use the dist.helper (don\textquotesingle{}t save time)}
\DocumentationTok{\#\# The dist.helper is not a function}
\FunctionTok{dispRity}\NormalTok{(my\_data, }\AttributeTok{metric =}\NormalTok{ my.sum.of.dist, }\AttributeTok{dist.helper =} \FunctionTok{dist}\NormalTok{(my\_data))}
\DocumentationTok{\#\# The dist.helper is not the correct function (should be dist)}
\FunctionTok{dispRity}\NormalTok{(my\_data, }\AttributeTok{metric =}\NormalTok{ my.sum.of.dist, }\AttributeTok{dist.helper =}\NormalTok{ vegdist)}
\DocumentationTok{\#\# The dist.helper is not the correct function (should be just dist)}
\FunctionTok{dispRity}\NormalTok{(my\_data, }\AttributeTok{metric =}\NormalTok{ my.sum.of.dist, }\AttributeTok{dist.helper =}\NormalTok{ stats}\SpecialCharTok{::}\NormalTok{dist)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
    \FunctionTok{expect\_equal}\NormalTok{(}\FunctionTok{summary}\NormalTok{(test)}\SpecialCharTok{$}\NormalTok{obs.median, }\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

--\textgreater{}

\hypertarget{making-stuff-up}{%
\chapter{Making stuff up!}\label{making-stuff-up}}

The \texttt{dispRity} package also offers some advanced data simulation features to allow to test hypothesis, explore ordinate-spaces or metrics properties or simply playing around with data!
All the following functions are based on the same modular architecture of the package and therefore can be used with most of the functions of the package.

\hypertarget{simulating-discrete-morphological-data}{%
\section{Simulating discrete morphological data}\label{simulating-discrete-morphological-data}}

The function \texttt{sim.morpho} allows to simulate discrete morphological data matrices (sometimes referred to as ``cladistic'' matrices).
It allows to evolve multiple discrete characters on a given phylogenetic trees, given different models, rates, and states.
It even allows to include ``proper'' inapplicable data to make datasets as messy as in real life!

In brief, the function \texttt{sim.morpho} takes a phylogenetic tree, the number of required characters, the evolutionary model, and a function from which to draw the rates.
The package also contains a function for quickly checking the matrix's phylogenetic signal (as defined in systematics not phylogenetic comparative methods) using parsimony.
The methods are described in details below

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\DocumentationTok{\#\# Simulating a starting tree with 15 taxa as a random coalescent tree}
\NormalTok{my\_tree }\OtherTok{\textless{}{-}} \FunctionTok{rcoal}\NormalTok{(}\DecValTok{15}\NormalTok{)}

\DocumentationTok{\#\# Generating a matrix with 100 characters (85\% binary and 15\% three state) and}
\DocumentationTok{\#\# an equal rates model with a gamma rate distribution (0.5, 1) with no }
\DocumentationTok{\#\# invariant characters.}
\NormalTok{my\_matrix }\OtherTok{\textless{}{-}} \FunctionTok{sim.morpho}\NormalTok{(}\AttributeTok{tree =}\NormalTok{ my\_tree, }\AttributeTok{characters =} \DecValTok{100}\NormalTok{, }\AttributeTok{states =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.85}\NormalTok{,}
    \FloatTok{0.15}\NormalTok{), }\AttributeTok{rates =} \FunctionTok{c}\NormalTok{(rgamma, }\FloatTok{0.5}\NormalTok{, }\DecValTok{1}\NormalTok{), }\AttributeTok{invariant =} \ConstantTok{FALSE}\NormalTok{)}

\DocumentationTok{\#\# The first few lines of the matrix}
\NormalTok{my\_matrix[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## t10 "1"  "0"  "1"  "0"  "1"  "0"  "0"  "1"  "0"  "0"  
## t1  "0"  "0"  "1"  "0"  "0"  "0"  "0"  "1"  "0"  "0"  
## t9  "0"  "0"  "1"  "0"  "0"  "0"  "0"  "1"  "0"  "0"  
## t14 "1"  "0"  "1"  "0"  "0"  "0"  "0"  "1"  "0"  "0"  
## t13 "1"  "0"  "1"  "0"  "0"  "0"  "0"  "1"  "0"  "0"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Checking the matrix properties with a quick Maximum Parsimony tree search}
\FunctionTok{check.morpho}\NormalTok{(my\_matrix, my\_tree)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                                     
## Maximum parsimony        144.0000000
## Consistency index          0.7430556
## Retention index            0.9160998
## Robinson-Foulds distance   2.0000000
\end{verbatim}

Note that this example produces a tree with a great consistency index and an identical topology to the random coalescent tree!
Nearly too good to be true\ldots{}

\hypertarget{a-more-detailed-description}{%
\subsection{A more detailed description}\label{a-more-detailed-description}}

The protocol implemented here to generate discrete morphological matrices is based on the ones developed in \citep{GuillermeCooper, OReilly2016, puttick2017uncertain, OReilly2017}.

\begin{itemize}
\tightlist
\item
  The first \texttt{tree} argument will be the tree on which to ``evolve'' the characters and therefore requires branch length.
  You can generate quick and easy random Yule trees using \texttt{ape::rtree(number\_of\_taxa)} but I would advise to use more realistic trees for more realistic simulations based on more realistic models (really realistic then) using the function \texttt{tree.bd} from the \href{http://www.zoology.ubc.ca/prog/diversitree/}{\texttt{diversitree}} package \citep{fitzjohndiversitree2012}.
\item
  The second argument, \texttt{character} is the number of characters. Pretty straight forward.
\item
  The third, \texttt{states} is the proportion of characters states above two (yes, the minimum number of states is two). This argument intakes the proportion of \emph{n}-states characters, for example \texttt{states\ =\ c(0.5,0.3,0.2)} will generate 50\% of binary-state characters, 30\% of three-state characters and 20\% of four-state characters. There is no limit in the number of state characters proportion as long as the total makes up 100\%.
\item
  The forth, \texttt{model} is the evolutionary model for generating the character(s). More about this below.
\item
  The fifth and sixth, \texttt{rates} and \texttt{substitution} are the model parameters described below as well.
\item
  Finally, the two logical arguments, are self explanatory: \texttt{invariant} whether to allow invariant characters (i.e.~characters that don't change) and \texttt{verbose} whether to print the simulation progress on your console.
\end{itemize}

\hypertarget{available-evolutionary-models}{%
\subsubsection{Available evolutionary models}\label{available-evolutionary-models}}

There are currently three evolutionary models implemented in \texttt{sim.morpho} but more will come in the future.
Note also that they allow fine tuning parameters making them pretty plastic!

\begin{itemize}
\tightlist
\item
  \texttt{"ER"}: this model allows any number of character states and is based on the Mk model \citep{lewisa2001}. It assumes a unique overall evolutionary rate equal substitution rate between character states. This model is based on the \texttt{ape::rTraitDisc} function.
\item
  \texttt{"HKY"}: this is binary state character model based on the molecular HKY model \citep{HKY85}. It uses the four molecular states (A,C,G,T) with a unique overall evolutionary rate and a biased substitution rate towards transitions (A \textless-\textgreater{} G or C \textless-\textgreater{} T) against transvertions (A \textless-\textgreater{} C and G \textless-\textgreater{} T). After evolving the nucleotide, this model transforms them into binary states by converting the purines (A and G) into state 0 and the pyrimidines (C and T) into state 1. This method is based on the \texttt{phyclust::seq.gen.HKY} function and was first proposed by \citet{OReilly2016}.
\item
  \texttt{"MIXED"}: this model uses a random (uniform) mix between both the \texttt{"ER"} and the \texttt{"HKY"} models.
\end{itemize}

The models can take the following parameters:
(1) \texttt{rates} is the evolutionary rate (i.e.~the rate of changes along a branch: the evolutionary speed) and (2) \texttt{substitution} is the frequency of changes between one state or another.
For example if a character can have high probability of changing (the \emph{evolutionary} rate) with, each time a change occurs a probability of changing from state \emph{X} to state \emph{Y} (the \emph{substitution} rate).
Note that in the \texttt{"ER"} model, the substitution rate is ignore because\ldots{} by definition this (substitution) rate is equal!

The parameters arguments \texttt{rates} and \texttt{substitution} takes a distributions from which to draw the parameters values for each character.
For example, if you want an \texttt{"HKY"} model with an evolutionary rate (i.e.~speed) drawn from a uniform distribution bounded between 0.001 and 0.005, you can define it as \texttt{rates\ =\ c(runif,\ min\ =\ 0.001,\ max\ =\ 0.005)}, \texttt{runif} being the function for random draws from a uniform distribution and \texttt{max} and \texttt{min} being the distribution parameters.
These distributions should always be passed in the format \texttt{c(random\_distribution\_function,\ distribution\_parameters)} with the names of the distribution parameters arguments.

\hypertarget{checking-the-results}{%
\subsubsection{Checking the results}\label{checking-the-results}}

An additional function, \texttt{check.morpho} runs a quick Maximum Parsimony tree search using the \texttt{phangorn} parsimony algorithm.
It quickly calculates the parsimony score, the consistency and retention indices and, if a tree is provided (e.g.~the tree used to generate the matrix) it calculates the Robinson-Foulds distance between the most parsimonious tree and the provided tree to determine how different they are.

\hypertarget{adding-inapplicable-characters}{%
\subsubsection{Adding inapplicable characters}\label{adding-inapplicable-characters}}

Once a matrix is generated, it is possible to apply inapplicable characters to it for increasing realism!
Inapplicable characters are commonly designated as \texttt{NA} or simply \texttt{-}.
They differ from missing characters \texttt{?} in their nature by being inapplicable rather than unknown\citep[see][ for more details]{brazeau2018}.
For example, considering a binary character defined as ``colour of the tail'' with the following states ``blue'' and ``red''; on a taxa with no tail, the character should be coded as inapplicable (``\texttt{-}'') since the state of the character ``colour of tail'' is \emph{known}: it's neither ``blue'' or ``red'', it's just not there!
It contrasts with coding it as missing (``\texttt{?}'' - also called as ambiguous) where the state is \emph{unknown}, for example, the taxon of interest is a fossil where the tail has no colour preserved or is not present at all due to bad conservation!

This type of characters can be added to the simulated matrices using the \texttt{apply.NA} function/
It takes, as arguments, the \texttt{matrix}, the source of inapplicability (\texttt{NAs} - more below), the \texttt{tree} used to generate the matrix and the two same \texttt{invariant} and \texttt{verbose} arguments as defined above.
The \texttt{NAs} argument allows two types of sources of inapplicability:

\begin{itemize}
\tightlist
\item
  \texttt{"character"} where the inapplicability is due to the character (e.g.~coding a character tail for species with no tail).
  In practice, the algorithm chooses a character \emph{X} as the underlying character (e.g.~``presence and absence of tail''), arbitrarily chooses one of the states as ``absent'' (e.g.~0 = absent) and changes in the next character \emph{Y} any state next to character \emph{X} state 0 into an inapplicable token (``\texttt{-}'').
  This simulates the inapplicability induced by coding the characters (i.e.~not always biological).
\item
  \texttt{"clade"} where the inapplicability is due to evolutionary history (e.g.~a clade loosing its tail).
  In practice, the algorithm chooses a random clade in the tree and a random character \emph{Z} and replaces the state of the taxa present in the clade by the inapplicable token (``\texttt{-}'').
  This simulates the inapplicability induced by evolutionary biology (e.g.~the lose of a feature in a clade).
\end{itemize}

To apply these sources of inapplicability, simply repeat the number of inapplicable sources for the desired number of characters with inapplicable data.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Generating 5 "character" NAs and 10 "clade" NAs}
\NormalTok{my\_matrix\_NA }\OtherTok{\textless{}{-}} \FunctionTok{apply.NA}\NormalTok{(my\_matrix, }\AttributeTok{tree =}\NormalTok{ my\_tree,}
                         \AttributeTok{NAs =} \FunctionTok{c}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\StringTok{"character"}\NormalTok{, }\DecValTok{5}\NormalTok{),}
                                 \FunctionTok{rep}\NormalTok{(}\StringTok{"clade"}\NormalTok{, }\DecValTok{10}\NormalTok{)))}

\DocumentationTok{\#\# The first few lines of the resulting matrix}
\NormalTok{my\_matrix\_NA[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{90}\SpecialCharTok{:}\DecValTok{100}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]
## t10 "-"  "1"  "1"  "2"  "1"  "0"  "0"  "0"  "1"  "0"   "0"  
## t1  "-"  "1"  "0"  "0"  "1"  "0"  "0"  "0"  "-"  "0"   "0"  
## t9  "-"  "1"  "1"  "0"  "1"  "0"  "0"  "0"  "-"  "0"   "0"  
## t14 "-"  "1"  "0"  "0"  "1"  "0"  "0"  "0"  "-"  "0"   "0"  
## t13 "-"  "1"  "0"  "0"  "1"  "0"  "0"  "0"  "-"  "0"   "0"  
## t5  "-"  "1"  "0"  "0"  "1"  "0"  "0"  "0"  "-"  "0"   "0"  
## t2  "1"  "1"  "0"  "0"  "1"  "0"  "0"  "0"  "0"  "0"   "0"  
## t8  "2"  "1"  "0"  "0"  "1"  "0"  "0"  "0"  "0"  "0"   "0"  
## t6  "-"  "1"  "1"  "0"  "0"  "1"  "1"  "2"  "0"  "1"   "1"  
## t15 "-"  "1"  "1"  "0"  "0"  "1"  "1"  "2"  "0"  "1"   "1"
\end{verbatim}

\hypertarget{parameters-for-a-realisticish-matrix}{%
\subsection{Parameters for a realistic(ish) matrix}\label{parameters-for-a-realisticish-matrix}}

There are many parameters that can create a ``realistic'' matrix (i.e.~not too different from the input tree with a consistency and retention index close to what is seen in the literature) but because of the randomness of the matrix generation not all parameters combination end up creating ``good'' matrices.
The following parameters however, seem to generate fairly ``realist'' matrices with a starting coalescent tree, equal rates model with 0.85 binary characters and 0.15 three state characters, a gamma distribution with a shape parameter (\(\alpha\)) of 5 and no scaling (\(\beta\) = 1) with a rate of 100.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{0}\NormalTok{)}
\DocumentationTok{\#\# tree}
\NormalTok{my\_tree }\OtherTok{\textless{}{-}} \FunctionTok{rcoal}\NormalTok{(}\DecValTok{15}\NormalTok{)}
\DocumentationTok{\#\# matrix}
\NormalTok{morpho\_mat }\OtherTok{\textless{}{-}} \FunctionTok{sim.morpho}\NormalTok{(my\_tree,}
                         \AttributeTok{characters =} \DecValTok{100}\NormalTok{,}
                         \AttributeTok{model =} \StringTok{"ER"}\NormalTok{,}
                         \AttributeTok{rates =} \FunctionTok{c}\NormalTok{(rgamma, }\AttributeTok{rate =} \DecValTok{100}\NormalTok{, }\AttributeTok{shape =} \DecValTok{5}\NormalTok{),}
                         \AttributeTok{invariant =} \ConstantTok{FALSE}\NormalTok{)}
\FunctionTok{check.morpho}\NormalTok{(morpho\_mat, my\_tree)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                                     
## Maximum parsimony        103.0000000
## Consistency index          0.9708738
## Retention index            0.9919571
## Robinson-Foulds distance   4.0000000
\end{verbatim}

\hypertarget{simulating-multidimensional-spaces}{%
\section{Simulating multidimensional spaces}\label{simulating-multidimensional-spaces}}

Another way to simulate data is to directly simulate an ordinated space with the \texttt{space.maker} function.
This function allows users to simulate multidimensional spaces with a certain number of properties.
For example, it is possible to design a multidimensional space with a specific distribution on each axis, a correlation between the axes and a specific cumulative variance per axis.
This can be useful for creating ordinated spaces for null hypothesis, for example if you're using the function \texttt{null.test} \citep{diaz2016global}.

This function takes as arguments the number of elements (data points - \texttt{elements} argument) and dimensions (\texttt{dimensions} argument) to create the space and the distribution functions to be used for each axis.
The distributions are passed through the \texttt{distribution} argument as\ldots{} modular functions!
You can either pass a single distribution function for all the axes (for example \texttt{distribution\ =\ runif} for all the axis being uniform) or a specific distribution function for each specific axis (for example \texttt{distribution\ =\ c(runif,\ rnorm,\ rgamma))} for the first axis being uniform, the second normal and the third gamma).
You can of course use your very own functions or use the ones implemented in \texttt{dispRity} for more complex ones (see below).
Specific optional arguments for each of these distributions can be passed as a list via the \texttt{arguments} argument.

Furthermore, it is possible to add a correlation matrix to add a correlation between the axis via the \texttt{cor.matrix} argument or even a vector of proportion of variance to be bear by each axis via the \texttt{scree} argument to simulate realistic ordinated spaces.

Here is a simple two dimensional example:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Graphical options}
\NormalTok{op }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{bty =} \StringTok{"n"}\NormalTok{)}

\DocumentationTok{\#\# A square space}
\NormalTok{square\_space }\OtherTok{\textless{}{-}} \FunctionTok{space.maker}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{2}\NormalTok{, runif)}

\DocumentationTok{\#\# The resulting 2D matrix}
\FunctionTok{head}\NormalTok{(square\_space)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           [,1]       [,2]
## [1,] 0.2878797 0.82110157
## [2,] 0.5989886 0.72890558
## [3,] 0.8401571 0.53042419
## [4,] 0.3663870 0.75545936
## [5,] 0.2122375 0.98768804
## [6,] 0.9612441 0.07285561
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Visualising the space}
\FunctionTok{plot}\NormalTok{(square\_space, }\AttributeTok{pch =} \DecValTok{20}\NormalTok{, }\AttributeTok{xlab =} \StringTok{""}\NormalTok{, }\AttributeTok{ylab =} \StringTok{""}\NormalTok{,}
     \AttributeTok{main =} \StringTok{"Uniform 2D space"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-149-1.pdf}

Of course, more complex spaces can be created by changing the distributions, their arguments or adding a correlation matrix or a cumulative variance vector:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A plane space: uniform with one dimensions equal to 0}
\NormalTok{plane\_space }\OtherTok{\textless{}{-}} \FunctionTok{space.maker}\NormalTok{(}\DecValTok{2500}\NormalTok{, }\DecValTok{3}\NormalTok{, }\FunctionTok{c}\NormalTok{(runif, runif, runif),}
                           \AttributeTok{arguments =} \FunctionTok{list}\NormalTok{(}\FunctionTok{list}\NormalTok{(}\AttributeTok{min =} \DecValTok{0}\NormalTok{, }\AttributeTok{max =} \DecValTok{0}\NormalTok{),}
                           \ConstantTok{NULL}\NormalTok{, }\ConstantTok{NULL}\NormalTok{))}

\DocumentationTok{\#\# Correlation matrix for a 3D space}
\NormalTok{(cor\_matrix }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{cbind}\NormalTok{(}\DecValTok{1}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.8}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.7}\NormalTok{, }\DecValTok{1}\NormalTok{), }\AttributeTok{nrow =} \DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]  1.0  0.8  0.2
## [2,]  0.8  1.0  0.7
## [3,]  0.2  0.7  1.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# An ellipsoid space (normal space with correlation)}
\NormalTok{ellipse\_space }\OtherTok{\textless{}{-}} \FunctionTok{space.maker}\NormalTok{(}\DecValTok{2500}\NormalTok{, }\DecValTok{3}\NormalTok{, rnorm,}
                             \AttributeTok{cor.matrix =}\NormalTok{ cor\_matrix)}

\DocumentationTok{\#\# A cylindrical space with decreasing axes variance}
\NormalTok{cylindrical\_space }\OtherTok{\textless{}{-}} \FunctionTok{space.maker}\NormalTok{(}\DecValTok{2500}\NormalTok{, }\DecValTok{3}\NormalTok{, }\FunctionTok{c}\NormalTok{(rnorm, rnorm, runif),}
                                 \AttributeTok{scree =} \FunctionTok{c}\NormalTok{(}\FloatTok{0.7}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{personalised-dimensions-distributions}{%
\subsection{Personalised dimensions distributions}\label{personalised-dimensions-distributions}}

Following the modular architecture of the package, it is of course possible to pass home made distribution functions to the \texttt{distribution} argument.
For example, the \texttt{random.circle} function is a personalised one implemented in \texttt{dispRity}.
This function allows to create circles based on basic trigonometry allowing to axis to covary to produce circle coordinates.
By default, this function generates two sets of coordinates with a \texttt{distribution} argument and a minimum and maximum boundary (\texttt{inner} and \texttt{outer} respectively) to create nice sharp edges to the circle.
The maximum boundary is equivalent to the radius of the circle (it removes coordinates beyond the circle radius) and the minimum is equivalent to the radius of a smaller circle with no data (it removes coordinates below this inner circle radius).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Graphical options}
\NormalTok{op }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{bty =} \StringTok{"n"}\NormalTok{)}

\DocumentationTok{\#\# Generating coordinates for a normal circle with a upper boundary of 1}
\NormalTok{circle }\OtherTok{\textless{}{-}} \FunctionTok{random.circle}\NormalTok{(}\DecValTok{1000}\NormalTok{, rnorm, }\AttributeTok{inner =} \DecValTok{0}\NormalTok{, }\AttributeTok{outer =} \DecValTok{1}\NormalTok{)}

\DocumentationTok{\#\# Plotting the circle}
\FunctionTok{plot}\NormalTok{(circle, }\AttributeTok{xlab =} \StringTok{"x"}\NormalTok{, }\AttributeTok{ylab =} \StringTok{"y"}\NormalTok{, }\AttributeTok{main =} \StringTok{"A normal circle"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-151-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating doughnut space (a spherical space with a hole)}
\NormalTok{doughnut\_space }\OtherTok{\textless{}{-}} \FunctionTok{space.maker}\NormalTok{(}\DecValTok{5000}\NormalTok{, }\DecValTok{3}\NormalTok{, }\FunctionTok{c}\NormalTok{(rnorm, random.circle),}
     \AttributeTok{arguments =} \FunctionTok{list}\NormalTok{(}\FunctionTok{list}\NormalTok{(}\AttributeTok{mean =} \DecValTok{0}\NormalTok{),}
                      \FunctionTok{list}\NormalTok{(runif, }\AttributeTok{inner =} \FloatTok{0.5}\NormalTok{, }\AttributeTok{outer =} \DecValTok{1}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\hypertarget{visualising-the-space}{%
\subsection{Visualising the space}\label{visualising-the-space}}

I suggest using the excellent \texttt{scatterplot3d} package to play around and visualise the simulated spaces:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Graphical options}
\NormalTok{op }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =}\NormalTok{ (}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)), }\AttributeTok{bty =} \StringTok{"n"}\NormalTok{)}
\DocumentationTok{\#\# Visualising 3D spaces}
\FunctionTok{require}\NormalTok{(scatterplot3d)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Loading required package: scatterplot3d
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The plane space}
\FunctionTok{scatterplot3d}\NormalTok{(plane\_space, }\AttributeTok{pch =} \DecValTok{20}\NormalTok{, }\AttributeTok{xlab =} \StringTok{""}\NormalTok{, }\AttributeTok{ylab =} \StringTok{""}\NormalTok{, }\AttributeTok{zlab =} \StringTok{""}\NormalTok{,}
              \AttributeTok{xlim =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\FloatTok{0.5}\NormalTok{, }\FloatTok{0.5}\NormalTok{), }\AttributeTok{main =} \StringTok{"Plane space"}\NormalTok{)}

\DocumentationTok{\#\# The ellipsoid space}
\FunctionTok{scatterplot3d}\NormalTok{(ellipse\_space, }\AttributeTok{pch =} \DecValTok{20}\NormalTok{, }\AttributeTok{xlab =} \StringTok{""}\NormalTok{, }\AttributeTok{ylab =} \StringTok{""}\NormalTok{, }\AttributeTok{zlab =} \StringTok{""}\NormalTok{,}
              \AttributeTok{main =} \StringTok{"Normal ellipsoid space"}\NormalTok{)}

\DocumentationTok{\#\# A cylindrical space with a decreasing variance per axis}
\FunctionTok{scatterplot3d}\NormalTok{(cylindrical\_space, }\AttributeTok{pch =} \DecValTok{20}\NormalTok{, }\AttributeTok{xlab =} \StringTok{""}\NormalTok{, }\AttributeTok{ylab =} \StringTok{""}\NormalTok{, }\AttributeTok{zlab =} \StringTok{""}\NormalTok{,}
              \AttributeTok{main =} \StringTok{"Normal cylindrical space"}\NormalTok{)}
\DocumentationTok{\#\# Axes have different orders of magnitude}

\DocumentationTok{\#\# Plotting the doughnut space}
\FunctionTok{scatterplot3d}\NormalTok{(doughnut\_space[,}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{)], }\AttributeTok{pch =} \DecValTok{20}\NormalTok{, }\AttributeTok{xlab =} \StringTok{""}\NormalTok{, }\AttributeTok{ylab =} \StringTok{""}\NormalTok{,}
              \AttributeTok{zlab =} \StringTok{""}\NormalTok{, }\AttributeTok{main =} \StringTok{"Doughnut space"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-152-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(op)}
\end{Highlighting}
\end{Shaded}

\hypertarget{generating-realistic-spaces}{%
\subsection{Generating realistic spaces}\label{generating-realistic-spaces}}

It is possible to generate ``realistic'' spaces by simply extracting the parameters of an existing space and scaling it up to the simulated space.
For example, we can extract the parameters of the \texttt{BeckLee\_mat50} ordinated space and simulate a similar space.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading the data}
\FunctionTok{data}\NormalTok{(BeckLee\_mat50)}

\DocumentationTok{\#\# Number of dimensions}
\NormalTok{obs\_dim }\OtherTok{\textless{}{-}} \FunctionTok{ncol}\NormalTok{(BeckLee\_mat50)}

\DocumentationTok{\#\# Observed correlation between the dimensions}
\NormalTok{obs\_correlations }\OtherTok{\textless{}{-}} \FunctionTok{cor}\NormalTok{(BeckLee\_mat50)}

\DocumentationTok{\#\# Observed mean and standard deviation per axis}
\NormalTok{obs\_mu\_sd\_axis }\OtherTok{\textless{}{-}} \FunctionTok{mapply}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x,y) }\FunctionTok{list}\NormalTok{(}\StringTok{"mean"} \OtherTok{=}\NormalTok{ x, }\StringTok{"sd"} \OtherTok{=}\NormalTok{ y),}
                         \FunctionTok{as.list}\NormalTok{(}\FunctionTok{apply}\NormalTok{(BeckLee\_mat50, }\DecValTok{2}\NormalTok{, mean)),}
                         \FunctionTok{as.list}\NormalTok{(}\FunctionTok{apply}\NormalTok{(BeckLee\_mat50, }\DecValTok{2}\NormalTok{, sd)), }\AttributeTok{SIMPLIFY =} \ConstantTok{FALSE}\NormalTok{)}

\DocumentationTok{\#\# Observed overall mean and standard deviation}
\NormalTok{obs\_mu\_sd\_glob }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\StringTok{"mean"} \OtherTok{=} \FunctionTok{mean}\NormalTok{(BeckLee\_mat50), }\StringTok{"sd"} \OtherTok{=} \FunctionTok{sd}\NormalTok{(BeckLee\_mat50))}

\DocumentationTok{\#\# Scaled observed variance per axis (scree plot)}
\NormalTok{obs\_scree }\OtherTok{\textless{}{-}} \FunctionTok{variances}\NormalTok{(BeckLee\_mat50)}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(}\FunctionTok{variances}\NormalTok{(BeckLee\_mat50))}

\DocumentationTok{\#\# Generating our simulated space}
\NormalTok{simulated\_space }\OtherTok{\textless{}{-}} \FunctionTok{space.maker}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\AttributeTok{dimensions =}\NormalTok{ obs\_dim, }
                               \AttributeTok{distribution =} \FunctionTok{rep}\NormalTok{(}\FunctionTok{list}\NormalTok{(rnorm), obs\_dim),}
                               \AttributeTok{arguments =}\NormalTok{ obs\_mu\_sd\_axis,}
                               \AttributeTok{cor.matrix =}\NormalTok{ obs\_correlations)}

\DocumentationTok{\#\# Visualising the fit of our data in the space (in the two first dimensions)}
\FunctionTok{plot}\NormalTok{(simulated\_space[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{], }\AttributeTok{xlab =} \StringTok{"PC1"}\NormalTok{, }\AttributeTok{ylab =} \StringTok{"PC2"}\NormalTok{)}
\FunctionTok{points}\NormalTok{(BeckLee\_mat50[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{], }\AttributeTok{col =} \StringTok{"red"}\NormalTok{, }\AttributeTok{pch =} \DecValTok{20}\NormalTok{)}
\FunctionTok{legend}\NormalTok{(}\StringTok{"topleft"}\NormalTok{, }\AttributeTok{legend =} \FunctionTok{c}\NormalTok{(}\StringTok{"observed"}\NormalTok{, }\StringTok{"simulated"}\NormalTok{),}
        \AttributeTok{pch =} \FunctionTok{c}\NormalTok{(}\DecValTok{20}\NormalTok{,}\DecValTok{21}\NormalTok{), }\AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{"red"}\NormalTok{, }\StringTok{"black"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-153-1.pdf}

It is now possible to simulate a space using these observed arguments to test several hypothesis:

\begin{itemize}
\tightlist
\item
  Is the space uniform or normal?
\item
  If the space is normal, is the mean and variance global or specific for each axis?
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring disparity as the sum of variance}
\NormalTok{observed\_disp }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(BeckLee\_mat50, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(median, centroids))}

\DocumentationTok{\#\# Is the space uniform?}
\NormalTok{test\_unif }\OtherTok{\textless{}{-}} \FunctionTok{null.test}\NormalTok{(observed\_disp, }\AttributeTok{null.distrib =}\NormalTok{ runif)}

\DocumentationTok{\#\# Is the space normal with a mean of 0 and a sd of 1?}
\NormalTok{test\_norm1 }\OtherTok{\textless{}{-}} \FunctionTok{null.test}\NormalTok{(observed\_disp, }\AttributeTok{null.distrib =}\NormalTok{ rnorm)}

\DocumentationTok{\#\# Is the space normal with the observed mean and sd and cumulative variance}
\NormalTok{test\_norm2 }\OtherTok{\textless{}{-}} \FunctionTok{null.test}\NormalTok{(observed\_disp, }\AttributeTok{null.distrib =} \FunctionTok{rep}\NormalTok{(}\FunctionTok{list}\NormalTok{(rnorm), obs\_dim),}
                        \AttributeTok{null.args =} \FunctionTok{rep}\NormalTok{(}\FunctionTok{list}\NormalTok{(obs\_mu\_sd\_glob), obs\_dim),}
                        \AttributeTok{null.scree =}\NormalTok{ obs\_scree)}

\DocumentationTok{\#\# Is the space multiple normal with multiple means and sds and a correlation?}
\NormalTok{test\_norm3 }\OtherTok{\textless{}{-}} \FunctionTok{null.test}\NormalTok{(observed\_disp, }\AttributeTok{null.distrib =} \FunctionTok{rep}\NormalTok{(}\FunctionTok{list}\NormalTok{(rnorm), obs\_dim),}
                        \AttributeTok{null.args =}\NormalTok{ obs\_mu\_sd\_axis, }\AttributeTok{null.cor =}\NormalTok{ obs\_correlations)}

\DocumentationTok{\#\# Graphical options}
\NormalTok{op }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =}\NormalTok{ (}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)), }\AttributeTok{bty =} \StringTok{"n"}\NormalTok{)}
\DocumentationTok{\#\# Plotting the results}
\FunctionTok{plot}\NormalTok{(test\_unif, }\AttributeTok{main =} \StringTok{"Uniform (0,1)"}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(test\_norm1, }\AttributeTok{main =} \StringTok{"Normal (0,1)"}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(test\_norm2, }\AttributeTok{main =} \FunctionTok{paste0}\NormalTok{(}\StringTok{"Normal ("}\NormalTok{, }\FunctionTok{round}\NormalTok{(obs\_mu\_sd\_glob[[}\DecValTok{1}\NormalTok{]], }\AttributeTok{digit =} \DecValTok{3}\NormalTok{),}
                              \StringTok{","}\NormalTok{, }\FunctionTok{round}\NormalTok{(obs\_mu\_sd\_glob[[}\DecValTok{2}\NormalTok{]], }\AttributeTok{digit =} \DecValTok{3}\NormalTok{), }\StringTok{")"}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(test\_norm3, }\AttributeTok{main =} \StringTok{"Normal (variable + correlation)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-154-1.pdf}

If we measure disparity as the median distance from the morphospace centroid, we can explain the distribution of the data as normal with the variable observed mean and standard deviation and with a correlation between the dimensions.

\hypertarget{other-functionalities}{%
\chapter{Other functionalities}\label{other-functionalities}}

The \texttt{dispRity} package also contains several other functions that are not specific to multidimensional analysis but that are often used by \texttt{dispRity} internal functions.
However, we decided to make these functions also available at a user level since they can be handy for certain specific operations!
You'll find a brief description of each of them (alphabetically) here:

\hypertarget{char.diff}{%
\section{\texorpdfstring{\texttt{char.diff}}{char.diff}}\label{char.diff}}

This is yet another function for calculating distance matrices.
There are many functions for calculating pairwise distance matrices in \texttt{R} (\texttt{stats::dist}, \texttt{vegan::vegdist}, \texttt{cluster::daisy} or \texttt{Claddis::calculate\_morphological\_distances}) but this one is the \texttt{dispRity} one.
It is slightly different to the ones mentioned above (though not that dissimilar from \texttt{Claddis::calculate\_morphological\_distances}) in the fact that it focuses on comparing discrete morphological characters and tries to solve all the problems linked to these kind of matrices (especially dealing with special tokens).

The function intakes a matrix with either \texttt{numeric} or \texttt{integer} (\texttt{NA} included) or matrices with \texttt{character} that are indeed \texttt{integers} (e.g.\texttt{"0"} and \texttt{"1"}).
It then uses a \href{https://en.wikipedia.org/wiki/Bitwise_operations_in_C}{bitwise operations} architecture implemented in \texttt{C} that renders the function pretty fast and pretty modular.
This bitwise operations translates the character states into binary values.
This way, \texttt{0} becomes \texttt{1}, \texttt{1} becomes \texttt{2}, \texttt{2} becomes \texttt{4}, \texttt{3} becomes \texttt{8}, etc\ldots{}
Specifically it can handle any rules specific to special tokens (i.e.~symbols) for discrete morphological characters. For example, should you treat missing values \texttt{"?"} as \texttt{NA} (ignoring them) or as any possible character state (e.g.~\texttt{c("0",\ "1")}?)? And how to treat characters with a ampersand (\texttt{"\&"})? \texttt{char.diff} can answer to all these questions!

Let's start by a basic binary matrix 4*3 with random \texttt{integer}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A random binary matrix}
\NormalTok{matrix\_binary }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{), }\DecValTok{12}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{), }\AttributeTok{ncol =} \DecValTok{4}\NormalTok{,}
                        \AttributeTok{dimnames =} \FunctionTok{list}\NormalTok{(letters[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{], LETTERS[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

By default, \texttt{char.diff} measures the hamming distance between characters:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The hamming distance between characters}
\NormalTok{(differences }\OtherTok{\textless{}{-}} \FunctionTok{char.diff}\NormalTok{(matrix\_binary))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   A B C D
## A 0 0 1 1
## B 0 0 1 1
## C 1 1 0 0
## D 1 1 0 0
## attr(,"class")
## [1] "matrix"    "char.diff"
\end{verbatim}

Note that the results is just a pairwise distance (dissimilarity) matrix with some special dual class \texttt{matrix} and \texttt{char.diff}.
This means it can easily be plotted via the disparity package:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Visualising the matrix}
\FunctionTok{plot}\NormalTok{(differences)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-157-1.pdf}

You can check all the numerous plotting options in the \texttt{?plot.char.diff} manual (it won't be developed here).

The \texttt{char.diff} function has much more options however (see all of them in the \texttt{?char.diff} manual) for example to measure different differences (via \texttt{method}) or making the comparison work per row (for a distance matrix between the rows):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Euclidean distance between rows}
\FunctionTok{char.diff}\NormalTok{(matrix\_binary, }\AttributeTok{by.col =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{method =} \StringTok{"euclidean"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          a        b        c
## a 0.000000 1.414214 1.414214
## b 1.414214 0.000000 0.000000
## c 1.414214 0.000000 0.000000
## attr(,"class")
## [1] "matrix"    "char.diff"
\end{verbatim}

We can however make it more interesting by playing with the different rules to play with different tokens.
First let's create a matrix with morphological characters as numeric \texttt{character}s:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A random character matrix}
\NormalTok{(matrix\_character }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{sample}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"0"}\NormalTok{,}\StringTok{"1"}\NormalTok{,}\StringTok{"2"}\NormalTok{), }\DecValTok{30}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{), }\AttributeTok{ncol =} \DecValTok{5}\NormalTok{,}
                           \AttributeTok{dimnames =} \FunctionTok{list}\NormalTok{(letters[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{], LETTERS[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{])))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   A   B   C   D   E  
## a "1" "1" "1" "1" "0"
## b "0" "2" "0" "2" "0"
## c "2" "2" "1" "2" "0"
## d "1" "2" "0" "0" "1"
## e "2" "2" "1" "1" "2"
## f "0" "2" "0" "2" "0"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The hamming difference between columns}
\FunctionTok{char.diff}\NormalTok{(matrix\_character)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     A   B   C   D   E
## A 0.0 0.6 0.6 0.6 0.8
## B 0.6 0.0 0.4 0.4 0.8
## C 0.6 0.4 0.0 0.4 0.6
## D 0.6 0.4 0.4 0.0 1.0
## E 0.8 0.8 0.6 1.0 0.0
## attr(,"class")
## [1] "matrix"    "char.diff"
\end{verbatim}

Here the characters are automatically converted into bitwise integers to be compared efficiently. We can now add some more special tokens like \texttt{"?"} or \texttt{"0/1"} for uncertainties between state \texttt{"0"} and \texttt{"1"} but not \texttt{"2"}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Adding uncertain characters}
\NormalTok{matrix\_character[}\FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{30}\NormalTok{, }\DecValTok{8}\NormalTok{)] }\OtherTok{\textless{}{-}} \StringTok{"0/1"}

\DocumentationTok{\#\# Adding missing data}
\NormalTok{matrix\_character[}\FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{30}\NormalTok{, }\DecValTok{5}\NormalTok{)] }\OtherTok{\textless{}{-}} \StringTok{"?"}

\DocumentationTok{\#\# This is what it looks like now}
\NormalTok{matrix\_character}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   A   B     C     D     E    
## a "?" "?"   "1"   "1"   "0"  
## b "0" "0/1" "0/1" "0/1" "0"  
## c "2" "2"   "?"   "0/1" "0"  
## d "1" "2"   "0"   "0/1" "1"  
## e "?" "2"   "1"   "1"   "2"  
## f "0" "2"   "0"   "?"   "0/1"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The hamming difference between columns including the special characters}
\FunctionTok{char.diff}\NormalTok{(matrix\_character)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           A         B    C    D         E
## A 0.0000000 0.6666667 1.00 0.50 0.6666667
## B 0.6666667 0.0000000 1.00 1.00 0.7500000
## C 1.0000000 1.0000000 0.00 0.00 0.2500000
## D 0.5000000 1.0000000 0.00 0.00 0.2500000
## E 0.6666667 0.7500000 0.25 0.25 0.0000000
## attr(,"class")
## [1] "matrix"    "char.diff"
\end{verbatim}

Note here that it detected the default behaviours for the special tokens \texttt{"?"} and \texttt{"/"}: \texttt{"?"} are treated as \texttt{NA} (not compared) and \texttt{"/"} are treated as both states (e.g.~\texttt{"0/1"} is treated as \texttt{"0"} and as \texttt{"1"}).
We can specify both the special tokens and the special behaviours to consider via \texttt{special.tokens} and \texttt{special.behaviours}.
The \texttt{special.tokens} are \texttt{missing\ =\ "?"}, \texttt{inapplicable\ =\ "-"}, \texttt{uncertainty\ =\ "\textbackslash{}"} and \texttt{polymorphism\ =\ "\&"} meaning we don't have to modify them for now.
However, say we want to change the behaviour for \texttt{"?"} and treat them as all possible characters and treat \texttt{"/"} as only the character \texttt{"0"} (as an integer) we can specify them giving a behaviour function:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Specifying some special behaviours}
\NormalTok{my\_special\_behaviours }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\AttributeTok{missing =} \ControlFlowTok{function}\NormalTok{(x,y) }\FunctionTok{return}\NormalTok{(y),}
                              \AttributeTok{uncertainty =} \ControlFlowTok{function}\NormalTok{(x,y) }\FunctionTok{return}\NormalTok{(}\FunctionTok{as.integer}\NormalTok{(}\DecValTok{0}\NormalTok{)))}

\DocumentationTok{\#\# Passing these special behaviours to the char.diff function}
\FunctionTok{char.diff}\NormalTok{(matrix\_character, }\AttributeTok{special.behaviour =}\NormalTok{ my\_special\_behaviours)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     A   B   C   D   E
## A 0.0 0.6 0.6 0.6 0.6
## B 0.6 0.0 0.8 0.8 0.8
## C 0.6 0.8 0.0 0.4 0.6
## D 0.6 0.8 0.4 0.0 1.0
## E 0.6 0.8 0.6 1.0 0.0
## attr(,"class")
## [1] "matrix"    "char.diff"
\end{verbatim}

The results are quiet different as before! Note that you can also specify some really specific behaviours for any type of special token.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Adding weird tokens to the matrix}
\NormalTok{matrix\_character[}\FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{30}\NormalTok{, }\DecValTok{8}\NormalTok{)] }\OtherTok{\textless{}{-}} \StringTok{"\%"}

\DocumentationTok{\#\# Specify the new token and the new behaviour}
\FunctionTok{char.diff}\NormalTok{(matrix\_character, }\AttributeTok{special.tokens =} \FunctionTok{c}\NormalTok{(}\AttributeTok{weird\_one =} \StringTok{"\%"}\NormalTok{),}
                            \AttributeTok{special.behaviours =} \FunctionTok{list}\NormalTok{(}
                                \AttributeTok{weird\_one =} \ControlFlowTok{function}\NormalTok{(x,y) }\FunctionTok{return}\NormalTok{(}\FunctionTok{as.integer}\NormalTok{(}\DecValTok{42}\NormalTok{)))}
\NormalTok{                            )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     A   B C D   E
## A   0   1 1 0 NaN
## B   1   0 1 1 NaN
## C   1   1 0 0   0
## D   0   1 0 0   0
## E NaN NaN 0 0   0
## attr(,"class")
## [1] "matrix"    "char.diff"
\end{verbatim}

Of course the results can be quiet surprising then\ldots{} But that's the essence of the modularity. You can see more options in the function manual \texttt{?char.diff}!

\hypertarget{clean.data}{%
\section{\texorpdfstring{\texttt{clean.data}}{clean.data}}\label{clean.data}}

This is a rather useful function that allows matching a \texttt{matrix} or a \texttt{data.frame} to a tree (\texttt{phylo}) or a distribution of trees (\texttt{multiPhylo}).
This function outputs the cleaned data and trees (if cleaning was needed) and a list of dropped rows and tips.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Generating a trees with labels from a to e}
\NormalTok{dummy\_tree }\OtherTok{\textless{}{-}} \FunctionTok{rtree}\NormalTok{(}\DecValTok{5}\NormalTok{, }\AttributeTok{tip.label =}\NormalTok{ LETTERS[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{])}

\DocumentationTok{\#\# Generating a matrix with rows from b to f}
\NormalTok{dummy\_data }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{, }\AttributeTok{dimnames =} \FunctionTok{list}\NormalTok{(LETTERS[}\DecValTok{2}\SpecialCharTok{:}\DecValTok{6}\NormalTok{], }\FunctionTok{c}\NormalTok{(}\StringTok{"var1"}\NormalTok{, }\StringTok{"var2"}\NormalTok{)))}

\DocumentationTok{\#\#Cleaning the trees and the data}
\NormalTok{(cleaned }\OtherTok{\textless{}{-}} \FunctionTok{clean.data}\NormalTok{(}\AttributeTok{data =}\NormalTok{ dummy\_data, }\AttributeTok{tree =}\NormalTok{ dummy\_tree))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $tree
## 
## Phylogenetic tree with 4 tips and 3 internal nodes.
## 
## Tip labels:
##   D, B, E, C
## 
## Rooted; includes branch lengths.
## 
## $data
##   var1 var2
## B    1    1
## C    1    1
## D    1    1
## E    1    1
## 
## $dropped_tips
## [1] "A"
## 
## $dropped_rows
## [1] "F"
\end{verbatim}

\hypertarget{crown.stem}{%
\section{\texorpdfstring{\texttt{crown.stem}}{crown.stem}}\label{crown.stem}}

This function quiet handily separates tips from a phylogeny between crown members (the living taxa and their descendants) and their stem members (the fossil taxa without any living relatives).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(BeckLee\_tree)}
\DocumentationTok{\#\# Diving both crow and stem species}
\NormalTok{(}\FunctionTok{crown.stem}\NormalTok{(BeckLee\_tree, }\AttributeTok{inc.nodes =} \ConstantTok{FALSE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $crown
##  [1] "Dasypodidae"     "Bradypus"        "Myrmecophagidae" "Todralestes"    
##  [5] "Potamogalinae"   "Dilambdogale"    "Widanelfarasia"  "Rhynchocyon"    
##  [9] "Procavia"        "Moeritherium"    "Pezosiren"       "Trichechus"     
## [13] "Tribosphenomys"  "Paramys"         "Rhombomylus"     "Gomphos"        
## [17] "Mimotona"        "Cynocephalus"    "Purgatorius"     "Plesiadapis"    
## [21] "Notharctus"      "Adapis"          "Patriomanis"     "Protictis"      
## [25] "Vulpavus"        "Miacis"          "Icaronycteris"   "Soricidae"      
## [29] "Solenodon"       "Eoryctes"       
## 
## $stem
##  [1] "Daulestes"              "Bulaklestes"            "Uchkudukodon"          
##  [4] "Kennalestes"            "Asioryctes"             "Ukhaatherium"          
##  [7] "Cimolestes"             "unnamed_cimolestid"     "Maelestes"             
## [10] "Batodon"                "Kulbeckia"              "Zhangolestes"          
## [13] "unnamed_zalambdalestid" "Zalambdalestes"         "Barunlestes"           
## [16] "Gypsonictops"           "Leptictis"              "Oxyclaenus"            
## [19] "Protungulatum"          "Oxyprimus"
\end{verbatim}

Note that it is possible to include or exclude nodes from the output.
To see a more applied example: this function is used in \protect\hyperlink{custom-subsets}{chapter 03: specific tutorials}.

\hypertarget{get.bin.ages}{%
\section{\texorpdfstring{\texttt{get.bin.ages}}{get.bin.ages}}\label{get.bin.ages}}

This function is similar than the \texttt{crown.stem} one as it is based on a tree but this one outputs the stratigraphic bins ages that the tree is covering.
This can be useful to generate precise bin ages for the \texttt{chrono.subsets} function:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{get.bin.ages}\NormalTok{(BeckLee\_tree)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 132.9000 129.4000 125.0000 113.0000 100.5000  93.9000  89.8000  86.3000
##  [9]  83.6000  72.1000  66.0000  61.6000  59.2000  56.0000  47.8000  41.2000
## [17]  37.8000  33.9000  28.1000  23.0300  20.4400  15.9700  13.8200  11.6300
## [25]   7.2460   5.3330   3.6000   2.5800   1.8000   0.7810   0.1260   0.0117
## [33]   0.0000
\end{verbatim}

Note that this function outputs the stratigraphic age limits by default but this can be customisable by specifying the \texttt{type} of data (e.g.~\texttt{type\ =\ "Eon"} for eons).
The function also intakes several optional arguments such as whether to output the startm end, range or midpoint of the stratigraphy or the year of reference of the International Commission of Stratigraphy.
To see a more applied example: this function is used in \protect\hyperlink{chrono-subsets}{chapter 03: specific tutorials}.

\hypertarget{match.tip.edge}{%
\section{\texorpdfstring{\texttt{match.tip.edge}}{match.tip.edge}}\label{match.tip.edge}}

This function matches a vector of discreet tip values with the edges connecting these tips in the \texttt{"phylo"} structure.
This can be used to pull the branches of interest for some specific trait of some group of species or for colouring tree tips based on clades.

For example, with the \texttt{charadriiformes} dataset, you can plot the tree with the branches coloured by clade.
To work properly, the function requires the characteristics of the tip labels (e.g.~the clade colour) to match the order of the tips in the tree:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading the charadriiformes data}
\FunctionTok{data}\NormalTok{(charadriiformes) }
\DocumentationTok{\#\# Extracting the tree}
\NormalTok{my\_tree }\OtherTok{\textless{}{-}}\NormalTok{ charadriiformes}\SpecialCharTok{$}\NormalTok{tree}
\DocumentationTok{\#\# Extracting the data column that contains the clade assignments}
\NormalTok{my\_data }\OtherTok{\textless{}{-}}\NormalTok{ charadriiformes}\SpecialCharTok{$}\NormalTok{data[, }\StringTok{"clade"}\NormalTok{]}
\DocumentationTok{\#\# Changing the levels names (the clade names) to colours}
\FunctionTok{levels}\NormalTok{(my\_data) }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"orange"}\NormalTok{, }\StringTok{"blue"}\NormalTok{, }\StringTok{"darkgreen"}\NormalTok{)}
\NormalTok{my\_data }\OtherTok{\textless{}{-}} \FunctionTok{as.character}\NormalTok{(my\_data)}
\DocumentationTok{\#\# Matching the data rownames to the tip order in the tree}
\NormalTok{my\_data }\OtherTok{\textless{}{-}}\NormalTok{ my\_data[}\FunctionTok{match}\NormalTok{(}\FunctionTok{ladderize}\NormalTok{(my\_tree)}\SpecialCharTok{$}\NormalTok{tip.label, }\FunctionTok{rownames}\NormalTok{(charadriiformes}\SpecialCharTok{$}\NormalTok{data))]}
\end{Highlighting}
\end{Shaded}

We can then match this tip data to their common descending edges.
We will also colour the edges that is not descendant directly from a common coloured tip in grey using \texttt{"replace.na\ =\ "grey"}.
Note that these edges are usually the edges at the root of the tree that are the descendant edges from multiple clades.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Matching the tip colours (labels) to their descending edges in the tree}
\DocumentationTok{\#\# (and making the non{-}match edges grey)}
\NormalTok{clade\_edges }\OtherTok{\textless{}{-}} \FunctionTok{match.tip.edge}\NormalTok{(my\_data, my\_tree, }\AttributeTok{replace.na =} \StringTok{"grey"}\NormalTok{)}

\DocumentationTok{\#\# Plotting the results}
\FunctionTok{plot}\NormalTok{(}\FunctionTok{ladderize}\NormalTok{(my\_tree), }\AttributeTok{show.tip.label =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{edge.color =}\NormalTok{ clade\_edges)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-167-1.pdf}

But you can also use this option to only select some specific edges and modify them (for example making them all equal to one):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Adding a fixed edge length to the green clade}
\NormalTok{my\_tree\_modif }\OtherTok{\textless{}{-}}\NormalTok{ my\_tree}
\NormalTok{green\_clade }\OtherTok{\textless{}{-}} \FunctionTok{which}\NormalTok{(clade\_edges }\SpecialCharTok{==} \StringTok{"darkgreen"}\NormalTok{)}
\NormalTok{my\_tree\_modif}\SpecialCharTok{$}\NormalTok{edge.length[green\_clade] }\OtherTok{\textless{}{-}} \DecValTok{1}
\FunctionTok{plot}\NormalTok{(}\FunctionTok{ladderize}\NormalTok{(my\_tree\_modif), }\AttributeTok{show.tip.label =} \ConstantTok{FALSE}\NormalTok{,}
     \AttributeTok{edge.color =}\NormalTok{ clade\_edges)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-168-1.pdf}

\hypertarget{MCMCglmm-utilities}{%
\section{\texorpdfstring{\texttt{MCMCglmm} utilities}{MCMCglmm utilities}}\label{MCMCglmm-utilities}}

Since version \texttt{1.7}, the \texttt{dispRity} package contains several utility functions for manipulating \texttt{"MCMCglmm"} (that is, objects returned by the function \texttt{MCMCglmm::MCMCglmm}).
These objects are a modification of the \texttt{mcmc} object (from the package \texttt{coda}) and can be sometimes cumbersome to manipulate because of the huge amount of data in it.
You can use the functions \texttt{MCMCglmm.traits} for extracting the number of traits, \texttt{MCMCglmm.levels} for extracting the level names, \texttt{MCMCglmm.sample} for sampling posterior IDs and \texttt{MCMCglmm.covars} for extracting variance-covariance matrices. You can also quickly calculate the variance (or relative variance) for each terms in the model using \texttt{MCMCglmm.variance} (the variance is calculated as the sum of the diagonal of each variance-covariance matrix for each term).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading the charadriiformes data that contains a MCMCglmm object}
\FunctionTok{data}\NormalTok{(charadriiformes)}
\NormalTok{my\_MCMCglmm }\OtherTok{\textless{}{-}}\NormalTok{ charadriiformes}\SpecialCharTok{$}\NormalTok{posteriors}

\DocumentationTok{\#\# Which traits where used in this model?}
\FunctionTok{MCMCglmm.traits}\NormalTok{(my\_MCMCglmm)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "PC1" "PC2" "PC3"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Which levels where used for the model\textquotesingle{}s random terms and/or residuals?}
\FunctionTok{MCMCglmm.levels}\NormalTok{(my\_MCMCglmm)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           random           random           random           random 
## "animal:clade_1" "animal:clade_2" "animal:clade_3"         "animal" 
##         residual 
##          "units"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The level names are converted for clarity but you can get them unconverted}
\DocumentationTok{\#\# (i.e. as they appear in the model)}
\FunctionTok{MCMCglmm.levels}\NormalTok{(my\_MCMCglmm, }\AttributeTok{convert =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                                random                                random 
## "us(at.level(clade, 1):trait):animal" "us(at.level(clade, 2):trait):animal" 
##                                random                                random 
## "us(at.level(clade, 3):trait):animal"                    "us(trait):animal" 
##                              residual 
##                     "us(trait):units"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Sampling 2 random posteriors samples IDs}
\NormalTok{(random\_samples }\OtherTok{\textless{}{-}} \FunctionTok{MCMCglmm.sample}\NormalTok{(my\_MCMCglmm, }\AttributeTok{n =} \DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 749 901
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Extracting these two random samples}
\NormalTok{my\_covars }\OtherTok{\textless{}{-}} \FunctionTok{MCMCglmm.covars}\NormalTok{(my\_MCMCglmm, }\AttributeTok{sample =}\NormalTok{ random\_samples)}

\DocumentationTok{\#\# Plotting the variance for each term in the model}
\FunctionTok{boxplot}\NormalTok{(}\FunctionTok{MCMCglmm.variance}\NormalTok{(my\_MCMCglmm), }\AttributeTok{horizontal =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{las =} \DecValTok{1}\NormalTok{,}
        \AttributeTok{xlab =} \StringTok{"Relative variance"}\NormalTok{,}
        \AttributeTok{main =} \StringTok{"Variance explained by each term"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-169-1.pdf}

See more in the \protect\hyperlink{covar}{\texttt{\$covar} section} on what to do with these \texttt{"MCMCglmm"} objects.

\hypertarget{pair.plot}{%
\section{\texorpdfstring{\texttt{pair.plot}}{pair.plot}}\label{pair.plot}}

This utility function allows to plot a matrix image of pairwise comparisons.
This can be useful when getting pairwise comparisons and if you'd like to see at a glance which pairs of comparisons have high or low values.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Random data}
\NormalTok{data }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\AttributeTok{data =} \FunctionTok{runif}\NormalTok{(}\DecValTok{42}\NormalTok{), }\AttributeTok{ncol =} \DecValTok{2}\NormalTok{)}

\DocumentationTok{\#\# Plotting the first column as a pairwise comparisons}
\FunctionTok{pair.plot}\NormalTok{(data, }\AttributeTok{what =} \DecValTok{1}\NormalTok{, }\AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{"orange"}\NormalTok{, }\StringTok{"blue"}\NormalTok{), }\AttributeTok{legend =} \ConstantTok{TRUE}\NormalTok{,}
          \AttributeTok{diag =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-170-1.pdf}

Here blue squares are ones that have a high value and orange ones the ones that have low values.
Note that the values plotted correspond the first column of the data as designated by \texttt{what\ =\ 1}.

It is also possible to add some tokens or symbols to quickly highlight to specific cells, for example which elements in the data are below a certain value:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The same plot as before without the diagonal being}
\DocumentationTok{\#\# the maximal observed value}
\FunctionTok{pair.plot}\NormalTok{(data, }\AttributeTok{what =} \DecValTok{1}\NormalTok{, }\AttributeTok{col =} \FunctionTok{c}\NormalTok{(}\StringTok{"orange"}\NormalTok{, }\StringTok{"blue"}\NormalTok{), }\AttributeTok{legend =} \ConstantTok{TRUE}\NormalTok{,}
          \AttributeTok{diag =} \StringTok{"max"}\NormalTok{)}
\DocumentationTok{\#\# Highlighting with an asterisk which squares have a value}
\DocumentationTok{\#\# below 0.2}
\FunctionTok{pair.plot}\NormalTok{(data, }\AttributeTok{what =} \DecValTok{1}\NormalTok{, }\AttributeTok{binary =} \FloatTok{0.2}\NormalTok{, }\AttributeTok{add =} \StringTok{"*"}\NormalTok{, }\AttributeTok{cex =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-171-1.pdf}

This function can also be used as a binary display when running a series of pairwise t-tests.
For example, the following script runs a wilcoxon test between the time-slices from the \texttt{disparity} example dataset and displays in black which pairs of slices have a p-value below 0.05:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading disparity data}
\FunctionTok{data}\NormalTok{(disparity)}

\DocumentationTok{\#\# Testing the pairwise difference between slices}
\NormalTok{tests }\OtherTok{\textless{}{-}} \FunctionTok{test.dispRity}\NormalTok{(disparity, }\AttributeTok{test =}\NormalTok{ wilcox.test, }\AttributeTok{correction =} \StringTok{"bonferroni"}\NormalTok{)}

\DocumentationTok{\#\# Plotting the significance}
\FunctionTok{pair.plot}\NormalTok{(}\FunctionTok{as.data.frame}\NormalTok{(tests), }\AttributeTok{what =} \StringTok{"p.value"}\NormalTok{, }\AttributeTok{binary =} \FloatTok{0.05}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-172-1.pdf}

\hypertarget{reduce.matrix}{%
\section{\texorpdfstring{\texttt{reduce.matrix}}{reduce.matrix}}\label{reduce.matrix}}

This function allows to reduce columns or rows of a matrix to make sure that there is enough overlap for further analysis.
This is particularly useful if you are going to use distance matrices since it uses the \texttt{vegan::vegdist} function to test whether distances can be calculated or not.

For example, if we have a patchy matrix like so (where the black squares represent available data):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# A 10*5 matrix}
\NormalTok{na\_matrix }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{50}\NormalTok{), }\DecValTok{10}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\DocumentationTok{\#\# Making sure some rows don\textquotesingle{}t overlap}
\NormalTok{na\_matrix[}\DecValTok{1}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{] }\OtherTok{\textless{}{-}} \ConstantTok{NA}
\NormalTok{na\_matrix[}\DecValTok{2}\NormalTok{, }\DecValTok{3}\SpecialCharTok{:}\DecValTok{5}\NormalTok{] }\OtherTok{\textless{}{-}} \ConstantTok{NA}
\DocumentationTok{\#\# Adding 50\% NAs}
\NormalTok{na\_matrix[}\FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{50}\NormalTok{, }\DecValTok{25}\NormalTok{)] }\OtherTok{\textless{}{-}} \ConstantTok{NA}
\DocumentationTok{\#\# Illustrating the gappy matrix}
\FunctionTok{image}\NormalTok{(}\FunctionTok{t}\NormalTok{(na\_matrix), }\AttributeTok{col =} \StringTok{"black"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-173-1.pdf}

We can use the \texttt{reduce.matrix} to double check whether any rows cannot be compared.
The functions needs as an input the type of distance that will be used, say a \texttt{"gower"} distance:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Reducing the matrix by row}
\NormalTok{(reduction }\OtherTok{\textless{}{-}} \FunctionTok{reduce.matrix}\NormalTok{(na\_matrix, }\AttributeTok{distance =} \StringTok{"gower"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $rows.to.remove
## [1] "9" "1"
## 
## $cols.to.remove
## NULL
\end{verbatim}

We can not remove the rows 1 and 9 and see if that improved the overlap:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{image}\NormalTok{(}\FunctionTok{t}\NormalTok{(na\_matrix[}\SpecialCharTok{{-}}\FunctionTok{as.numeric}\NormalTok{(reduction}\SpecialCharTok{$}\NormalTok{rows.to.remove), ]),}
      \AttributeTok{col =} \StringTok{"black"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-175-1.pdf}

\hypertarget{select.axes}{%
\section{\texorpdfstring{\texttt{select.axes}}{select.axes}}\label{select.axes}}

This function allows you to select which axes (or how many of them) are relevant in your trait space analyses.
Usually, when the trait space is an ordination, workers select a certain number of axes to reduce the dimensionality of the dataset by removing axes that contain relatively little information.
This is often done by selecting the axes from which the cumulative individual variance is lower than an arbitrary threshold.
For example, all the axes that contain together 0.95 of the variance:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The USArrest example in R}
\NormalTok{ordination }\OtherTok{\textless{}{-}} \FunctionTok{princomp}\NormalTok{(USArrests, }\AttributeTok{cor =} \ConstantTok{TRUE}\NormalTok{)}

\DocumentationTok{\#\# The loading of each variable}
\FunctionTok{loadings}\NormalTok{(ordination)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Loadings:
##          Comp.1 Comp.2 Comp.3 Comp.4
## Murder    0.536  0.418  0.341  0.649
## Assault   0.583  0.188  0.268 -0.743
## UrbanPop  0.278 -0.873  0.378  0.134
## Rape      0.543 -0.167 -0.818       
## 
##                Comp.1 Comp.2 Comp.3 Comp.4
## SS loadings      1.00   1.00   1.00   1.00
## Proportion Var   0.25   0.25   0.25   0.25
## Cumulative Var   0.25   0.50   0.75   1.00
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Or the same operation but manually}
\NormalTok{variances }\OtherTok{\textless{}{-}} \FunctionTok{apply}\NormalTok{(ordination}\SpecialCharTok{$}\NormalTok{scores, }\DecValTok{2}\NormalTok{, var)}
\NormalTok{scaled\_variances }\OtherTok{\textless{}{-}}\NormalTok{ variances}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(variances)}
\NormalTok{sumed\_variances }\OtherTok{\textless{}{-}} \FunctionTok{cumsum}\NormalTok{(scaled\_variances)}
\FunctionTok{round}\NormalTok{(}\FunctionTok{rbind}\NormalTok{(variances, scaled\_variances, sumed\_variances), }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                  Comp.1 Comp.2 Comp.3 Comp.4
## variances         2.531  1.010  0.364  0.177
## scaled_variances  0.620  0.247  0.089  0.043
## sumed_variances   0.620  0.868  0.957  1.000
\end{verbatim}

In this example, you can see that the three first axes are required to have at least 0.95 of the variance.
You can do that automatically in \texttt{dispRity} using the \texttt{select.axes} function.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Same operation automatised}
\NormalTok{(selected }\OtherTok{\textless{}{-}} \FunctionTok{select.axes}\NormalTok{(ordination))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## The first 3 dimensions are needed to express at least 95% of the variance in the whole trait space.
## You can use x$dimensions to select them or use plot(x) and summary(x) to summarise them.
\end{verbatim}

This function does basically what the script above does and allows the results to be plotted or summarised into a table.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Summarising this info}
\FunctionTok{summary}\NormalTok{(selected)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             Comp.1.var Comp.1.sum Comp.2.var Comp.2.sum Comp.3.var Comp.3.sum
## whole_space       0.62       0.62      0.247      0.868      0.089      0.957
##             Comp.4.var Comp.4.sum
## whole_space      0.043          1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Plotting it}
\FunctionTok{plot}\NormalTok{(selected)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-178-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Extracting the dimensions}
\DocumentationTok{\#\# (for the dispRity function for example)}
\NormalTok{selected}\SpecialCharTok{$}\NormalTok{dimensions}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3
\end{verbatim}

However, it might be interesting to not only consider the variance within the whole trait space but also among groups of specific interest.
E.g. if the 95\% of the variance is concentrated in the two first axes for the whole trait space, that does not automatically mean that it is the case for each subset in this space. Some subset might require more than the two first axes to express 95\% of their variance!
You can thus use the \texttt{select.axes} function to look at the results per group as well as through the whole trait space.

\begin{quote}
Note that you can always change the threshold value (default is 0.95). Here for example we set it to 0.9 (we arbitrarily decide that explain 90\% of the variance is enough).
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating some groups of stats}
\NormalTok{states\_groups }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\StringTok{"Group1"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"Mississippi"}\NormalTok{,}\StringTok{"North Carolina"}\NormalTok{,}
                                   \StringTok{"South Carolina"}\NormalTok{, }\StringTok{"Georgia"}\NormalTok{, }\StringTok{"Alabama"}\NormalTok{,}
                                   \StringTok{"Alaska"}\NormalTok{, }\StringTok{"Tennessee"}\NormalTok{, }\StringTok{"Louisiana"}\NormalTok{),}
                      \StringTok{"Group2"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"Florida"}\NormalTok{, }\StringTok{"New Mexico"}\NormalTok{, }\StringTok{"Michigan"}\NormalTok{,}
                                   \StringTok{"Indiana"}\NormalTok{, }\StringTok{"Virginia"}\NormalTok{, }\StringTok{"Wyoming"}\NormalTok{, }\StringTok{"Montana"}\NormalTok{,}
                                   \StringTok{"Maine"}\NormalTok{, }\StringTok{"Idaho"}\NormalTok{, }\StringTok{"New Hampshire"}\NormalTok{, }\StringTok{"Iowa"}\NormalTok{),}
                      \StringTok{"Group3"} \OtherTok{=} \FunctionTok{c}\NormalTok{(}\StringTok{"Rhode Island"}\NormalTok{, }\StringTok{"New Jersey"}\NormalTok{, }\StringTok{"Hawaii"}\NormalTok{, }\StringTok{"Massachusetts"}\NormalTok{))}
\DocumentationTok{\#\# Running the same analyses but per groups}
\NormalTok{selected }\OtherTok{\textless{}{-}} \FunctionTok{select.axes}\NormalTok{(ordination, }\AttributeTok{group =}\NormalTok{ states\_groups, }\AttributeTok{threshold =} \FloatTok{0.9}\NormalTok{)}
\DocumentationTok{\#\# Plotting the results}
\FunctionTok{plot}\NormalTok{(selected)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-179-1.pdf}

As you can see here, the whole space requires the three first axes to explain at least 90\% of the variance (in fact, 95\% as seen before).
However, different groups have a different story!
The Group 1 and 3 requires 4 dimensions whereas Group 2 requires only 1 dimensions (note how for Group 3, there is actually nearly no variance explained on the second axes)!
Using this method, you can safely use the four axes returned by the function (\texttt{selected\$dimensions}) so that every group has at least 90\% of their variance explained in the trait space.

If you've used the function if you've already done some grouping in your disparity analyses (e.g.~using the function \texttt{custom.subsets} or \texttt{chrono.subsets}), you can use the generated \texttt{dispRity} to automatise this analyses:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading the dispRity package demo data}
\FunctionTok{data}\NormalTok{(demo\_data)}
\DocumentationTok{\#\# A dispRity object with two groups}
\NormalTok{demo\_data}\SpecialCharTok{$}\NormalTok{hopkins}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 2 customised subsets for 46 elements in one matrix:
##     adult, juvenile.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Selecting axes on a dispRity object}
\NormalTok{selected }\OtherTok{\textless{}{-}} \FunctionTok{select.axes}\NormalTok{(demo\_data}\SpecialCharTok{$}\NormalTok{hopkins)}
\FunctionTok{plot}\NormalTok{(selected)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-180-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Displaying which axes are necessary for which group}
\NormalTok{selected}\SpecialCharTok{$}\NormalTok{dim.list}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $adult
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22
## 
## $juvenile
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
## 
## $whole_space
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Note how the whole space needs only 16 axes}
\DocumentationTok{\#\# but both groups need 22 and 23 axes}
\end{Highlighting}
\end{Shaded}

\hypertarget{set.root.time}{%
\section{\texorpdfstring{\texttt{set.root.time}}{set.root.time}}\label{set.root.time}}

This function can be used to easily add a \texttt{\$root.time} element to \texttt{"phylo"} or \texttt{"multiPhylo"} objects.
This \texttt{\$root.time} element is used by \texttt{dispRity} and several packages (e.g.~\texttt{Claddis} and \texttt{paleotree}) to scale the branch length units of a tree allowing them to be usually expressed in million of years (Mya).

For example, on a standard random tree, no \texttt{\$root.time} exist so the edge lengths are not expressed in any specific unit:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A random tree with no root.time}
\NormalTok{my\_tree }\OtherTok{\textless{}{-}} \FunctionTok{rtree}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{my\_tree}\SpecialCharTok{$}\NormalTok{root.time }\CommentTok{\# is NULL}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## NULL
\end{verbatim}

You can add a root time by either manually setting it:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Adding an arbitrary root time}
\NormalTok{my\_tree\_arbitrary }\OtherTok{\textless{}{-}}\NormalTok{ my\_tree}
\DocumentationTok{\#\# Setting the age of the root to 42}
\NormalTok{my\_tree\_arbitrary}\SpecialCharTok{$}\NormalTok{root.time }\OtherTok{\textless{}{-}} \DecValTok{42}
\end{Highlighting}
\end{Shaded}

Or by calculating it automatically from the cumulated branch length information (making the youngest tip age 0 and the oldest the total age/depth of the tree)

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating the root time from the present}
\NormalTok{my\_tree\_aged }\OtherTok{\textless{}{-}}\NormalTok{ my\_tree }
\NormalTok{my\_tree\_aged }\OtherTok{\textless{}{-}} \FunctionTok{set.root.time}\NormalTok{(my\_tree)}
\end{Highlighting}
\end{Shaded}

If you want the youngest tip to not be of age 0, you can define an arbitrary age for it and recalculate the age of the root from there using the \texttt{present} argument (say the youngest tip is 42 Mya old):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Caculating the root time from 42 Mya }
\NormalTok{my\_tree\_age }\OtherTok{\textless{}{-}} \FunctionTok{set.root.time}\NormalTok{(my\_tree, }\AttributeTok{present =} \DecValTok{42}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This function also works with a distribution of trees (\texttt{"multiPhylo"}).

\hypertarget{slice.tree}{%
\section{\texorpdfstring{\texttt{slice.tree}}{slice.tree}}\label{slice.tree}}

This function is a modification of the \texttt{paleotree::timeSliceTree} function that allows to make slices through a phylogenetic tree.
Compared to the \texttt{paleotree::timeSliceTree}, this function allows a model to decide which tip or node to use when slicing through a branch (whereas \texttt{paleotree::timeSliceTree} always choose the first available tip alphabetically).
The models for choosing which tip or node are the same as the ones used in the \texttt{chrono.subsets} and are described in \protect\hyperlink{chrono-subsets}{chapter 03: specific tutorials}.

The function works by using at least a tree, a slice age and a model:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# Generate a random ultrametric tree}
\NormalTok{tree }\OtherTok{\textless{}{-}} \FunctionTok{rcoal}\NormalTok{(}\DecValTok{20}\NormalTok{)}
\DocumentationTok{\#\# Add some node labels}
\NormalTok{tree}\SpecialCharTok{$}\NormalTok{node.label }\OtherTok{\textless{}{-}}\NormalTok{ letters[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{19}\NormalTok{]}
\DocumentationTok{\#\# Add its root time}
\NormalTok{tree}\SpecialCharTok{$}\NormalTok{root.time }\OtherTok{\textless{}{-}} \FunctionTok{max}\NormalTok{(}\FunctionTok{tree.age}\NormalTok{(tree)}\SpecialCharTok{$}\NormalTok{ages)}

\DocumentationTok{\#\# Slicing the tree at age 0.75}
\NormalTok{tree\_75 }\OtherTok{\textless{}{-}} \FunctionTok{slice.tree}\NormalTok{(tree, }\AttributeTok{age =} \FloatTok{0.75}\NormalTok{, }\StringTok{"acctran"}\NormalTok{)}

\DocumentationTok{\#\# Showing both trees}
\FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(tree, }\AttributeTok{main =} \StringTok{"original tree"}\NormalTok{)}
\FunctionTok{axisPhylo}\NormalTok{() ; }\FunctionTok{nodelabels}\NormalTok{(tree}\SpecialCharTok{$}\NormalTok{node.label, }\AttributeTok{cex =} \FloatTok{0.8}\NormalTok{)}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{v =}\NormalTok{ (}\FunctionTok{max}\NormalTok{(}\FunctionTok{tree.age}\NormalTok{(tree)}\SpecialCharTok{$}\NormalTok{ages) }\SpecialCharTok{{-}} \FloatTok{0.75}\NormalTok{), }\AttributeTok{col =} \StringTok{"red"}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(tree\_75, }\AttributeTok{main =} \StringTok{"sliced tree"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-185-1.pdf}

\hypertarget{slide.nodes-and-remove.zero.brlen}{%
\section{\texorpdfstring{\texttt{slide.nodes} and \texttt{remove.zero.brlen}}{slide.nodes and remove.zero.brlen}}\label{slide.nodes-and-remove.zero.brlen}}

This function allows to slide nodes along a tree!
In other words it allows to change the branch length leading to a node without modifying the overall tree shape.
This can be useful to add some value to 0 branch lengths for example.

The function works by taking a node (or a list of nodes), a tree and a sliding value.
The node will be moved ``up'' (towards the tips) for the given sliding value.
You can move the node ``down'' (towards the roots) using a negative value.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{42}\NormalTok{)}
\DocumentationTok{\#\# Generating simple coalescent tree}
\NormalTok{tree }\OtherTok{\textless{}{-}} \FunctionTok{rcoal}\NormalTok{(}\DecValTok{5}\NormalTok{)}

\DocumentationTok{\#\# Sliding node 8 up and down}
\NormalTok{tree\_slide\_up }\OtherTok{\textless{}{-}} \FunctionTok{slide.nodes}\NormalTok{(}\DecValTok{8}\NormalTok{, tree, }\AttributeTok{slide =} \FloatTok{0.075}\NormalTok{)}
\NormalTok{tree\_slide\_down }\OtherTok{\textless{}{-}} \FunctionTok{slide.nodes}\NormalTok{(}\DecValTok{8}\NormalTok{, tree, }\AttributeTok{slide =} \SpecialCharTok{{-}}\FloatTok{0.075}\NormalTok{)}

\DocumentationTok{\#\# Display the results}
\FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(tree, }\AttributeTok{main =} \StringTok{"original tree"}\NormalTok{) ; }\FunctionTok{axisPhylo}\NormalTok{() ; }\FunctionTok{nodelabels}\NormalTok{()}
\FunctionTok{plot}\NormalTok{(tree\_slide\_up, }\AttributeTok{main =} \StringTok{"slide up!"}\NormalTok{) ; }\FunctionTok{axisPhylo}\NormalTok{() ; }\FunctionTok{nodelabels}\NormalTok{()}
\FunctionTok{plot}\NormalTok{(tree\_slide\_down, }\AttributeTok{main =} \StringTok{"slide down!"}\NormalTok{) ; }\FunctionTok{axisPhylo}\NormalTok{() ; }\FunctionTok{nodelabels}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-186-1.pdf}

The \texttt{remove.zero.brlen} is a ``clever'' wrapping function that uses the \texttt{slide.nodes} function to stochastically remove zero branch lengths across a whole tree.
This function will slide nodes up or down in successive postorder traversals (i.e.~going down the tree clade by clade) in order to minimise the number of nodes to slide while making sure there are no silly negative branch lengths produced!
By default it is trying to slide the nodes using 1\% of the minimum branch length to avoid changing the topology too much.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{42}\NormalTok{)}
\DocumentationTok{\#\# Generating a tree}
\NormalTok{tree }\OtherTok{\textless{}{-}} \FunctionTok{rtree}\NormalTok{(}\DecValTok{20}\NormalTok{)}

\DocumentationTok{\#\# Adding some zero branch lengths (5)}
\NormalTok{tree}\SpecialCharTok{$}\NormalTok{edge.length[}\FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\FunctionTok{Nedge}\NormalTok{(tree), }\DecValTok{5}\NormalTok{)] }\OtherTok{\textless{}{-}} \DecValTok{0}

\DocumentationTok{\#\# And now removing these zero branch lengths!}
\NormalTok{tree\_no\_zero }\OtherTok{\textless{}{-}} \FunctionTok{remove.zero.brlen}\NormalTok{(tree)}

\DocumentationTok{\#\# Exaggerating the removal (to make it visible)}
\NormalTok{tree\_exaggerated }\OtherTok{\textless{}{-}} \FunctionTok{remove.zero.brlen}\NormalTok{(tree, }\AttributeTok{slide =} \DecValTok{1}\NormalTok{)}

\DocumentationTok{\#\# Check the differences}
\FunctionTok{any}\NormalTok{(tree}\SpecialCharTok{$}\NormalTok{edge.length }\SpecialCharTok{==} \DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{any}\NormalTok{(tree\_no\_zero}\SpecialCharTok{$}\NormalTok{edge.length }\SpecialCharTok{==} \DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{any}\NormalTok{(tree\_exaggerated}\SpecialCharTok{$}\NormalTok{edge.length }\SpecialCharTok{==} \DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Display the results}
\FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(tree, }\AttributeTok{main =} \StringTok{"with zero edges"}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(tree\_no\_zero, }\AttributeTok{main =} \StringTok{"without zero edges!"}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(tree\_exaggerated, }\AttributeTok{main =} \StringTok{"with longer edges"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-187-1.pdf}

\hypertarget{tree.age}{%
\section{\texorpdfstring{\texttt{tree.age}}{tree.age}}\label{tree.age}}

This function allows to quickly calculate the ages of each tips and nodes present in a tree.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{tree }\OtherTok{\textless{}{-}} \FunctionTok{rtree}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\DocumentationTok{\#\# The tree age from a 10 tip tree}
\FunctionTok{tree.age}\NormalTok{(tree)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      ages elements
## 1  0.7068       t7
## 2  0.1417       t2
## 3  0.0000       t3
## 4  1.4675       t8
## 5  1.3656       t1
## 6  1.8949       t5
## 7  1.5360       t6
## 8  1.4558       t9
## 9  0.8147      t10
## 10 2.3426       t4
## 11 3.0111       11
## 12 2.6310       12
## 13 1.8536       13
## 14 0.9189       14
## 15 0.2672       15
## 16 2.6177       16
## 17 2.2353       17
## 18 2.1356       18
## 19 1.6420       19
\end{verbatim}

It also allows to set the age of the root of the tree:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The ages starting from {-}100 units}
\FunctionTok{tree.age}\NormalTok{(tree, }\AttributeTok{age =} \DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ages elements
## 1   23.4717       t7
## 2    4.7048       t2
## 3    0.0000       t3
## 4   48.7362       t8
## 5   45.3517       t1
## 6   62.9315       t5
## 7   51.0119       t6
## 8   48.3486       t9
## 9   27.0554      t10
## 10  77.7998       t4
## 11 100.0000       11
## 12  87.3788       12
## 13  61.5593       13
## 14  30.5171       14
## 15   8.8746       15
## 16  86.9341       16
## 17  74.2347       17
## 18  70.9239       18
## 19  54.5330       19
\end{verbatim}

Usually tree age is calculated from the present to the past (e.g.~in million years ago) but it is possible to reverse it using the \texttt{order\ =\ present} option:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The ages in terms of tip/node height}
\FunctionTok{tree.age}\NormalTok{(tree, }\AttributeTok{order =} \StringTok{"present"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      ages elements
## 1  2.3043       t7
## 2  2.8694       t2
## 3  3.0111       t3
## 4  1.5436       t8
## 5  1.6455       t1
## 6  1.1162       t5
## 7  1.4751       t6
## 8  1.5553       t9
## 9  2.1964      t10
## 10 0.6685       t4
## 11 0.0000       11
## 12 0.3800       12
## 13 1.1575       13
## 14 2.0922       14
## 15 2.7439       15
## 16 0.3934       16
## 17 0.7758       17
## 18 0.8755       18
## 19 1.3690       19
\end{verbatim}

\hypertarget{multi.ace}{%
\section{\texorpdfstring{\texttt{multi.ace}}{multi.ace}}\label{multi.ace}}

This function allows to run ancestral characters estimations on multiple trees.
In it's most basic structure (e.g.~using all default arguments) this function is using a mix of \texttt{ape::ace} and \texttt{castor::asr\_mk\_model} depending on the data and the situation and is generally faster than both functions when applied to a list of trees.
However, this function provides also some more complex and modular functionalities, especially appropriate when using discrete morphological character data.

\hypertarget{using-different-character-tokens-in-different-situations}{%
\subsection{Using different character tokens in different situations}\label{using-different-character-tokens-in-different-situations}}

This data can be often coded in non-standard way with different character tokens having different meanings.
For example, in some datasets the token \texttt{-} can mean ``the trait is inapplicable'' but this can be also coded by the more conventional \texttt{NA} or can mean ``this trait is missing'' (often coded \texttt{?}).
This makes the meaning of specific tokens idiosyncratic to different matrices.
For example we can have the following discrete morphological matrix with all the data encoded:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{42}\NormalTok{)}
\DocumentationTok{\#\# A random tree with 10 tips}
\NormalTok{tree }\OtherTok{\textless{}{-}} \FunctionTok{rcoal}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\DocumentationTok{\#\# Setting up the parameters}
\NormalTok{my\_rates }\OtherTok{=} \FunctionTok{c}\NormalTok{(rgamma, }\AttributeTok{rate =} \DecValTok{10}\NormalTok{, }\AttributeTok{shape =} \DecValTok{5}\NormalTok{)}

\DocumentationTok{\#\# Generating a bunch of trees}
\NormalTok{multiple\_trees }\OtherTok{\textless{}{-}} \FunctionTok{rmtree}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{)}

\DocumentationTok{\#\# A random Mk matrix (10*50)}
\NormalTok{matrix\_simple }\OtherTok{\textless{}{-}} \FunctionTok{sim.morpho}\NormalTok{(tree, }\AttributeTok{characters =} \DecValTok{50}\NormalTok{, }\AttributeTok{model =} \StringTok{"ER"}\NormalTok{, }\AttributeTok{rates =}\NormalTok{ my\_rates,}
                            \AttributeTok{invariant =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{matrix\_simple[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## t8  "1"  "1"  "1"  "1"  "0"  "0"  "0"  "0"  "0"  "1"  
## t3  "1"  "1"  "1"  "1"  "0"  "0"  "0"  "0"  "0"  "1"  
## t2  "1"  "1"  "1"  "1"  "0"  "1"  "1"  "1"  "0"  "1"  
## t1  "1"  "1"  "1"  "1"  "0"  "0"  "1"  "1"  "0"  "1"  
## t10 "1"  "1"  "1"  "1"  "0"  "0"  "1"  "0"  "1"  "1"  
## t9  "1"  "1"  "1"  "1"  "0"  "0"  "1"  "0"  "0"  "1"  
## t5  "0"  "0"  "0"  "0"  "1"  "1"  "1"  "0"  "0"  "0"  
## t6  "0"  "0"  "0"  "0"  "1"  "1"  "1"  "0"  "0"  "0"  
## t4  "0"  "0"  "0"  "0"  "1"  "0"  "0"  "0"  "1"  "0"  
## t7  "0"  "0"  "0"  "0"  "1"  "0"  "0"  "0"  "1"  "0"
\end{verbatim}

But of course, as mentioned above, in practice, such matrices have more nuance and can including missing characters, ambiguous characters, multi-state characters, inapplicable characters, etc\ldots{}
All these coded and defined by different authors using different tokens (or symbols).
Let's give it a go and transform this simple data to something more messy:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Modify the matrix to contain missing and special data}
\NormalTok{matrix\_complex }\OtherTok{\textless{}{-}}\NormalTok{ matrix\_simple}
\DocumentationTok{\#\# Adding 50 random "{-}" tokens}
\NormalTok{matrix\_complex[}\FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(matrix\_complex), }\DecValTok{50}\NormalTok{)] }\OtherTok{\textless{}{-}} \StringTok{"{-}"}
\DocumentationTok{\#\# Adding 50 random "?" tokens}
\NormalTok{matrix\_complex[}\FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(matrix\_complex), }\DecValTok{50}\NormalTok{)] }\OtherTok{\textless{}{-}} \StringTok{"?"}
\DocumentationTok{\#\# Adding 50 random "0\%2" tokens}
\NormalTok{matrix\_complex[}\FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(matrix\_complex), }\DecValTok{50}\NormalTok{)] }\OtherTok{\textless{}{-}} \StringTok{"0\%2"}
\NormalTok{matrix\_complex[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     [,1] [,2]  [,3] [,4]  [,5]  [,6]  [,7]  [,8]  [,9] [,10]
## t8  "1"  "1"   "1"  "1"   "?"   "0"   "0"   "0"   "0"  "0%2"
## t3  "1"  "-"   "1"  "1"   "?"   "0"   "0"   "0"   "0"  "1"  
## t2  "1"  "1"   "1"  "0%2" "0"   "0%2" "1"   "1"   "0"  "1"  
## t1  "1"  "1"   "1"  "1"   "0"   "0"   "1"   "?"   "0"  "1"  
## t10 "1"  "0%2" "1"  "1"   "-"   "?"   "0%2" "0%2" "1"  "1"  
## t9  "1"  "1"   "?"  "1"   "0%2" "0"   "1"   "0"   "0"  "1"  
## t5  "0"  "-"   "?"  "0"   "1"   "1"   "1"   "0"   "0"  "-"  
## t6  "0"  "-"   "0"  "0"   "1"   "1"   "-"   "-"   "?"  "0"  
## t4  "?"  "0"   "0"  "0"   "1"   "0"   "0"   "0"   "1"  "0"  
## t7  "0"  "0"   "0"  "0%2" "1"   "0"   "0"   "-"   "1"  "-"
\end{verbatim}

In \texttt{multi.ace} you can specify what all these tokens actually mean and how the code should interpret them.
For example, \texttt{-} often means inapplicable data (i.e.~the specimen does not have the coded feature, for example, the colour of the tail of a tailless bird); or \texttt{?} that often means missing data (i.e.~it is unknown if the specimen has a tail or not since only the head was available).
And more than the differences in meaning between these characters, different people treat these characters differently even if they have the same meaning for the token.
For example, one might want to treat \texttt{-} as meaning ``we don't know'' (which will be treated by the algorithm as ``any possible trait value'') or ``we know, and it's no possible'' (which will be treated by the algorithm as \texttt{NA}).
Because of this situation, \texttt{multi.ace} allows combining any special case marked with a special token to a special behaviour.
For example we might want to create a special case called \texttt{"missing"} (i.e.~the data is missing) that we want to denote using the token \texttt{"?"} and we can specify the algorithm to treat this \texttt{"missing"} cases (\texttt{"?"}) as treating the character token value as ``any possible values''.
This behaviour can be hard coded by providing a function with the name of the behaviour.
For example:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The specific token for the missing cases (note the "\textbackslash{}\textbackslash{}" for protecting the value)}
\NormalTok{special.tokens }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"missing"} \OtherTok{=} \StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{?"}\NormalTok{)}

\DocumentationTok{\#\# The behaviour for the missing cases (?)}
\NormalTok{special.behaviour }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(missing }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y) }\FunctionTok{return}\NormalTok{(y))}
\DocumentationTok{\#\# Where x is the input value (here "?") and y is all the possible normal values for the character}
\end{Highlighting}
\end{Shaded}

This example shows a very common case (and is actually used by default, more on that below) but this architecture allows for very modular combination of tokens and behaviours.
For example, in our code above we introduced the token \texttt{"\%"} which is very odd (to my knowledge) and might mean something very specific in our case.
Say we want to call this case \texttt{"weirdtoken"} and mean that whenever this token is encountered in a character, it should be interpreted by the algorithm as the values 1 and 2, no matter what:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Set a list of extra special tokens}
\NormalTok{my\_spec\_tokens }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"weirdtoken"} \OtherTok{=} \StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{\%"}\NormalTok{)}

\DocumentationTok{\#\# Weird tokens are considered as state 0 and 3}
\NormalTok{my\_spec\_behaviours }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{()}
\NormalTok{my\_spec\_behaviours}\SpecialCharTok{$}\NormalTok{weirdtoken }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x,y) }\FunctionTok{return}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

If you don't need/don't have any of this specific tokens, don't worry, most special but common tokens are handled by default as such:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The token for missing values:}
\NormalTok{default\_tokens }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"missing"}      \OtherTok{=} \StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{?"}\NormalTok{,}
\DocumentationTok{\#\# The token for inapplicable values:                    }
                    \StringTok{"inapplicable"} \OtherTok{=} \StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{{-}"}\NormalTok{,}
\DocumentationTok{\#\# The token for polymorphisms:}
                    \StringTok{"polymorphism"} \OtherTok{=} \StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{\&"}\NormalTok{,}
\DocumentationTok{\#\# The token for uncertainties:}
                    \StringTok{"uncertanity"}  \OtherTok{=} \StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{/"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

With the following associated default behaviours

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Treating missing data as all data values}
\NormalTok{default\_behaviour }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(missing      }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x,y) y,}
\DocumentationTok{\#\# Treating inapplicable data as all data values (like missing)    }
\NormalTok{                          inapplicable }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x, y) y,}
\DocumentationTok{\#\# Treating polymorphisms as all values present:}
\NormalTok{                          polymorphism }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x,y) }\FunctionTok{strsplit}\NormalTok{(x, }\AttributeTok{split =} \StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{\&"}\NormalTok{)[[}\DecValTok{1}\NormalTok{]],}
\DocumentationTok{\#\# Treating uncertainties as all values present (like polymorphisms):}
\NormalTok{                          uncertanity  }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x,y) }\FunctionTok{strsplit}\NormalTok{(x, }\AttributeTok{split =} \StringTok{"}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{/"}\NormalTok{)[[}\DecValTok{1}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

We can then use these token description along with our complex matrix and our list of trees to run the ancestral states estimations as follows:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Running ancestral states}
\NormalTok{ancestral\_states }\OtherTok{\textless{}{-}} \FunctionTok{multi.ace}\NormalTok{(matrix\_complex, multiple\_trees,}
                              \AttributeTok{special.tokens =}\NormalTok{ my\_spec\_tokens,}
                              \AttributeTok{special.behaviours =}\NormalTok{ my\_spec\_behaviours,}
                              \AttributeTok{verbose =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Preparing the data:...
\end{verbatim}

\begin{verbatim}
## Warning: The character 39 is invariant (using the current special behaviours
## for special characters) and is simply duplicated for each node.
\end{verbatim}

\begin{verbatim}
## ..Done.
## Running ancestral states estimations:.....................................................................................................................................................................................................................................................Done.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# This outputs a list of ancestral parts of the matrices for each tree}
\DocumentationTok{\#\# For example, here\textquotesingle{}s the first one:}
\NormalTok{ancestral\_states[[}\DecValTok{1}\NormalTok{]][}\DecValTok{1}\SpecialCharTok{:}\DecValTok{9}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    [,1] [,2]  [,3]  [,4] [,5]  [,6]    [,7]  [,8] [,9] [,10]
## n1 "1"  "1"   "1"   "1"  "1"   "0/1/2" "1"   "0"  "0"  "1"  
## n2 "1"  "1"   "1"   "1"  "0/1" "0/1/2" "0/1" "0"  "0"  "1"  
## n3 "1"  "1"   "1"   "1"  "0/1" "0/1/2" "0"   "0"  "0"  "1"  
## n4 "1"  "1"   "1"   "1"  "0"   "0/1/2" "1"   "1"  "0"  "1"  
## n5 "1"  "1"   "1"   "1"  "1"   "0/1/2" "1"   "0"  "0"  "1"  
## n6 "1"  "1"   "1"   "1"  "1"   "0/1/2" "1"   "0"  "0"  "1"  
## n7 "0"  "0/1" "0/1" "0"  "1"   "1"     "1"   "0"  "0"  "0/1"
## n8 "0"  "0"   "0"   "0"  "1"   "0/1/2" "0"   "0"  "1"  "0"  
## n9 "0"  "0"   "0"   "0"  "1"   "1"     "0"   "0"  "1"  "0"
\end{verbatim}

Note that there are many different options that are not covered here.
For example, you can use different models for each character via the \texttt{models} argument, you can specify how to handle uncertainties via the \texttt{threshold} argument, use a branch length modifier (\texttt{brlen.multiplier}), specify the type of output, etc\ldots{}

\hypertarget{feeding-the-results-to-char.diff-to-get-distance-matrices}{%
\subsection{\texorpdfstring{Feeding the results to \texttt{char.diff} to get distance matrices}{Feeding the results to char.diff to get distance matrices}}\label{feeding-the-results-to-char.diff-to-get-distance-matrices}}

After running your ancestral states estimations, it is not uncommon to then use these resulting data to calculate the distances between taxa and then ordinate the results to measure disparity.
You can do that using the \texttt{char.diff} function \protect\hyperlink{char.diff}{described above} but instead of measuring the distances between characters (columns) you can measure the distances between species (rows).
You might notice that this function uses the same modular token and behaviour descriptions.
That makes sense because they're using the same core C functions implemented in dispRity that greatly speed up distance calculations.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Running ancestral states}
\DocumentationTok{\#\# and outputing a list of combined matrices (tips and nodes)}
\NormalTok{ancestral\_states }\OtherTok{\textless{}{-}} \FunctionTok{multi.ace}\NormalTok{(matrix\_complex, multiple\_trees,}
                              \AttributeTok{special.tokens =}\NormalTok{ my\_spec\_tokens,}
                              \AttributeTok{special.behaviours =}\NormalTok{ my\_spec\_behaviours,}
                              \AttributeTok{output =} \StringTok{"combined.matrix"}\NormalTok{,}
                              \AttributeTok{verbose =} \ConstantTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Preparing the data:...
\end{verbatim}

\begin{verbatim}
## Warning: The character 39 is invariant (using the current special behaviours
## for special characters) and is simply duplicated for each node.
\end{verbatim}

\begin{verbatim}
## ..Done.
## Running ancestral states estimations:.....................................................................................................................................................................................................................................................Done.
\end{verbatim}

We can then feed these matrices directly to \texttt{char.diff}, say for calculating the ``MORD'' distance:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring the distances between rows using the MORD distance}
\NormalTok{distances }\OtherTok{\textless{}{-}} \FunctionTok{lapply}\NormalTok{(ancestral\_states, char.diff, }\AttributeTok{method =} \StringTok{"mord"}\NormalTok{, }\AttributeTok{by.col =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

And we now have a list of distances matrices with ancestral states estimated!

\hypertarget{running-ancestral-states-estimations-for-continuous-characters}{%
\subsection{Running ancestral states estimations for continuous characters}\label{running-ancestral-states-estimations-for-continuous-characters}}

You can also run \texttt{multi.ace} on continuous characters.
The function detects any continuous characters as being of class \texttt{"numeric"} and runs them using the \texttt{ape::ace} function.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\DocumentationTok{\#\# Creating three coalescent trees}
\NormalTok{my\_trees }\OtherTok{\textless{}{-}} \FunctionTok{replicate}\NormalTok{(}\DecValTok{3}\NormalTok{, }\FunctionTok{rcoal}\NormalTok{(}\DecValTok{15}\NormalTok{), }\AttributeTok{simplify =} \ConstantTok{FALSE}\NormalTok{)}
\DocumentationTok{\#\# Adding node labels}
\NormalTok{my\_trees }\OtherTok{\textless{}{-}} \FunctionTok{lapply}\NormalTok{(my\_trees, makeNodeLabel)}
\DocumentationTok{\#\# Making into a multiPhylo object}
\FunctionTok{class}\NormalTok{(my\_trees) }\OtherTok{\textless{}{-}} \StringTok{"multiPhylo"}

\DocumentationTok{\#\# Creating a matrix of continuous characters}
\NormalTok{data }\OtherTok{\textless{}{-}} \FunctionTok{space.maker}\NormalTok{(}\AttributeTok{elements =} \DecValTok{15}\NormalTok{, }\AttributeTok{dimensions =} \DecValTok{5}\NormalTok{, }\AttributeTok{distribution =}\NormalTok{ rnorm,}
                    \AttributeTok{elements.name =}\NormalTok{ my\_trees[[}\DecValTok{1}\NormalTok{]]}\SpecialCharTok{$}\NormalTok{tip.label)}
\end{Highlighting}
\end{Shaded}

With such data and trees you can easily run the \texttt{multi.ace} estimations.
By default, the estimations use the default arguments from \texttt{ape::ace}, knowingly a Brownian Motion (\texttt{model\ =\ "BM"}) with the REML method (\texttt{method\ =\ "REML"}; this method ``first estimates the ancestral value at the root (aka, the phylogenetic mean), then the variance of the Brownian motion process is estimated by optimizing the residual log-likelihood'' - from \texttt{?ape::ace}).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Running multi.ace on continuous data}
\NormalTok{my\_ancestral\_states }\OtherTok{\textless{}{-}} \FunctionTok{multi.ace}\NormalTok{(data, my\_trees)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# We end up with three matrices of node states estimates}
\FunctionTok{str}\NormalTok{(my\_ancestral\_states)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 3
##  $ : num [1:14, 1:5] -0.191 -0.155 -0.227 -0.17 0.138 ...
##   ..- attr(*, "dimnames")=List of 2
##   .. ..$ : chr [1:14] "Node1" "Node2" "Node3" "Node4" ...
##   .. ..$ : NULL
##  $ : num [1:14, 1:5] -0.385 -0.552 -0.445 -0.435 -0.478 ...
##   ..- attr(*, "dimnames")=List of 2
##   .. ..$ : chr [1:14] "Node1" "Node2" "Node3" "Node4" ...
##   .. ..$ : NULL
##  $ : num [1:14, 1:5] -0.3866 -0.2232 -0.0592 -0.7246 -0.2253 ...
##   ..- attr(*, "dimnames")=List of 2
##   .. ..$ : chr [1:14] "Node1" "Node2" "Node3" "Node4" ...
##   .. ..$ : NULL
\end{verbatim}

This results in three matrices with ancestral states for the nodes.
When using continuous characters, however, you can output the results directly as a \texttt{dispRity} object that allows visualisation and other normal dispRity pipeline:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Running multi.ace on continuous data}
\NormalTok{my\_ancestral\_states }\OtherTok{\textless{}{-}} \FunctionTok{multi.ace}\NormalTok{(data, my\_trees, }\AttributeTok{output =} \StringTok{"dispRity"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# We end up with three matrices of node states estimates}
\FunctionTok{plot}\NormalTok{(my\_ancestral\_states)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-202-1.pdf}

You can also mix continuous and discrete characters together.
By default the \texttt{multi.ace} detects which character is of which type and applies the correct estimations based on that.
However you can always specify models or other details character per characters.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Adding two discrete characters}
\NormalTok{data }\OtherTok{\textless{}{-}} \FunctionTok{as.data.frame}\NormalTok{(data)}
\NormalTok{data }\OtherTok{\textless{}{-}} \FunctionTok{cbind}\NormalTok{(data, }\StringTok{"new\_char"} \OtherTok{=} \FunctionTok{as.character}\NormalTok{(}\FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{15}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)))}
\NormalTok{data }\OtherTok{\textless{}{-}} \FunctionTok{cbind}\NormalTok{(data, }\StringTok{"new\_char2"} \OtherTok{=} \FunctionTok{as.character}\NormalTok{(}\FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{15}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)))}

\DocumentationTok{\#\# Setting up different models for each characters}
\DocumentationTok{\#\# BM for all 5 continuous characters}
\DocumentationTok{\#\# and ER and ARD for the two discrete ones}
\NormalTok{my\_models }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\StringTok{"BM"}\NormalTok{, }\DecValTok{5}\NormalTok{), }\StringTok{"ER"}\NormalTok{, }\StringTok{"ARD"}\NormalTok{)}

\DocumentationTok{\#\# Running the estimation with the specified models}
\NormalTok{my\_ancestral\_states }\OtherTok{\textless{}{-}} \FunctionTok{multi.ace}\NormalTok{(data, my\_trees, }\AttributeTok{models =}\NormalTok{ my\_models)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
## Warning in sqrt(1/out$hessian): NaNs produced
\end{verbatim}

Of course all the options discussed in the first part above also can apply here!

\hypertarget{the-guts-of-the-disprity-package}{%
\chapter{\texorpdfstring{The guts of the \texttt{dispRity} package}{The guts of the dispRity package}}\label{the-guts-of-the-disprity-package}}

\hypertarget{manipulating-disprity-objects}{%
\section{\texorpdfstring{Manipulating \texttt{dispRity} objects}{Manipulating dispRity objects}}\label{manipulating-disprity-objects}}

Disparity analysis involves a lot of manipulation of many matrices (especially when bootstrapping) which can be impractical to visualise and will quickly overwhelm your \texttt{R} console.
Even the simple Beck and Lee 2014 example above produces an object with \textgreater{} 72 lines of lists of lists of matrices!

Therefore \texttt{dispRity} uses a specific class of object called a \texttt{dispRity} object.
These objects allow users to use S3 method functions such as \texttt{summary.dispRity}, \texttt{plot.dispRity} and \texttt{print.dispRity}.
\texttt{dispRity} also contains various utility functions that manipulate the \texttt{dispRity} object (e.g.~\texttt{sort.dispRity}, \texttt{extract.dispRity} see the full list in the next section).
These functions modify the \texttt{dispRity} object without having to delve into its complex structure!
The full structure of a \texttt{dispRity} object is detailed \href{https://github.com/TGuillerme/dispRity/blob/master/disparity_object.md}{here}.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading the example data}
\FunctionTok{data}\NormalTok{(disparity)}

\DocumentationTok{\#\# What is the class of the median\_centroids object?}
\FunctionTok{class}\NormalTok{(disparity)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "dispRity"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# What does the object contain?}
\FunctionTok{names}\NormalTok{(disparity)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "matrix"    "tree"      "call"      "subsets"   "disparity"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Summarising it using the S3 method print.dispRity}
\NormalTok{disparity}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 7 continuous (acctran) time subsets for 99 elements in one matrix with 97 dimensions with 1 phylogenetic tree
##      90, 80, 70, 60, 50 ...
## Rows were bootstrapped 100 times (method:"full") and rarefied to 20, 15, 10, 5 elements.
## Disparity was calculated as: c(median, centroids).
\end{verbatim}

Note that it is always possible to recall the full object using the argument \texttt{all\ =\ TRUE} in \texttt{print.dispRity}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Display the full object}
\FunctionTok{print}\NormalTok{(disparity, }\AttributeTok{all =} \ConstantTok{TRUE}\NormalTok{)}
\DocumentationTok{\#\# This is more nearly \textasciitilde{} 5000 lines on my 13 inch laptop screen!}
\end{Highlighting}
\end{Shaded}

\hypertarget{utilities}{%
\section{\texorpdfstring{\texttt{dispRity} utilities}{dispRity utilities}}\label{utilities}}

The package also provides some utility functions to facilitate multidimensional analysis.

\hypertarget{disprity-object-utilities}{%
\subsection{\texorpdfstring{\texttt{dispRity} object utilities }{dispRity object utilities }}\label{disprity-object-utilities}}

The first set of utilities are functions for manipulating \texttt{dispRity} objects:

\hypertarget{make.disprity}{%
\subsubsection{\texorpdfstring{\texttt{make.dispRity}}{make.dispRity}}\label{make.disprity}}

This function creates empty \texttt{dispRity} objects.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating an empty dispRity object}
\FunctionTok{make.dispRity}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Empty dispRity object.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating an "empty" dispRity object with a matrix}
\NormalTok{(disparity\_obj }\OtherTok{\textless{}{-}} \FunctionTok{make.dispRity}\NormalTok{(}\FunctionTok{matrix}\NormalTok{(}\FunctionTok{rnorm}\NormalTok{(}\DecValTok{20}\NormalTok{), }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## Contains a matrix 5x4.
\end{verbatim}

\hypertarget{fill.disprity}{%
\subsubsection{\texorpdfstring{\texttt{fill.dispRity}}{fill.dispRity}}\label{fill.disprity}}

This function initialises a \texttt{dispRity} object and generates its call properties.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The dispRity object\textquotesingle{}s call is indeed empty}
\NormalTok{disparity\_obj}\SpecialCharTok{$}\NormalTok{call}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## list()
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Filling an empty disparity object (that needs to contain at least a matrix)}
\NormalTok{(disparity\_obj }\OtherTok{\textless{}{-}} \FunctionTok{fill.dispRity}\NormalTok{(disparity\_obj))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in check.data(data, match_call): Row names have been automatically
## added to data$matrix.
\end{verbatim}

\begin{verbatim}
##  ---- dispRity object ---- 
## 5 elements in one matrix with 4 dimensions.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The dipRity object has now the correct minimal attributes}
\NormalTok{disparity\_obj}\SpecialCharTok{$}\NormalTok{call}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $dimensions
## [1] 1 2 3 4
\end{verbatim}

\hypertarget{get.matrix}{%
\subsubsection{\texorpdfstring{\texttt{get.matrix}}{get.matrix}}\label{get.matrix}}

This function extracts a specific matrix from a disparity object.
The matrix can be one of the bootstrapped matrices or/and a rarefied matrix.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Extracting the matrix containing the coordinates of the elements at time 50}
\FunctionTok{str}\NormalTok{(}\FunctionTok{get.matrix}\NormalTok{(disparity, }\StringTok{"50"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  num [1:18, 1:97] -0.1 0.427 0.333 0.054 0.674 ...
##  - attr(*, "dimnames")=List of 2
##   ..$ : chr [1:18] "Leptictis" "Dasypodidae" "n24" "Potamogalinae" ...
##   ..$ : NULL
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Extracting the 3rd bootstrapped matrix with the 2nd rarefaction level}
\DocumentationTok{\#\# (15 elements) from the second group (80 Mya)}
\FunctionTok{str}\NormalTok{(}\FunctionTok{get.matrix}\NormalTok{(disparity, }\AttributeTok{subsets =} \DecValTok{1}\NormalTok{, }\AttributeTok{bootstrap =} \DecValTok{3}\NormalTok{, }\AttributeTok{rarefaction =} \DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  num [1:15, 1:97] -0.134942 -0.571937 0.000589 0.266188 0.266188 ...
##  - attr(*, "dimnames")=List of 2
##   ..$ : chr [1:15] "n15" "Maelestes" "n20" "n34" ...
##   ..$ : NULL
\end{verbatim}

\hypertarget{n.subsets}{%
\subsubsection{\texorpdfstring{\texttt{n.subsets}}{n.subsets}}\label{n.subsets}}

This function simply counts the number of subsets in a \texttt{dispRity} object.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# How many subsets are in this object?}
\FunctionTok{n.subsets}\NormalTok{(disparity)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7
\end{verbatim}

\hypertarget{name.subsets}{%
\subsubsection{\texorpdfstring{\texttt{name.subsets}}{name.subsets}}\label{name.subsets}}

This function gets you the names of the subsets in a \texttt{dispRity} object as a vector.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# What are they called?}
\FunctionTok{name.subsets}\NormalTok{(disparity)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "90" "80" "70" "60" "50" "40" "30"
\end{verbatim}

\hypertarget{size.subsets}{%
\subsubsection{\texorpdfstring{\texttt{size.subsets}}{size.subsets}}\label{size.subsets}}

This function tells the number of elements in each subsets of a \texttt{dispRity} object.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# How many elements are there in each subset?}
\FunctionTok{size.subsets}\NormalTok{(disparity)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 90 80 70 60 50 40 30 
## 18 22 23 21 18 15 10
\end{verbatim}

\hypertarget{get.subsets}{%
\subsubsection{\texorpdfstring{\texttt{get.subsets}}{get.subsets}}\label{get.subsets}}

This function creates a dispRity object that contains only elements from one specific subsets.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Extracting all the data for the crown mammals}
\NormalTok{(crown\_mammals }\OtherTok{\textless{}{-}} \FunctionTok{get.subsets}\NormalTok{(disp\_crown\_stemBS, }\StringTok{"Group.crown"}\NormalTok{))}

\DocumentationTok{\#\# The object keeps the properties of the parent object but is composed of only one subsets}
\FunctionTok{length}\NormalTok{(crown\_mammals}\SpecialCharTok{$}\NormalTok{subsets)}
\end{Highlighting}
\end{Shaded}

\hypertarget{combine.subsets}{%
\subsubsection{\texorpdfstring{\texttt{combine.subsets}}{combine.subsets}}\label{combine.subsets}}

This function allows to merge different subsets.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Combine the two first subsets in the dispRity data example}
\FunctionTok{combine.subsets}\NormalTok{(disparity, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Note that the computed values (bootstrapped data + disparity metric) are not merge.

\hypertarget{get.disparity}{%
\subsubsection{\texorpdfstring{\texttt{get.disparity}}{get.disparity}}\label{get.disparity}}

This function extracts the calculated disparity values of a specific matrix.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Extracting the observed disparity (default)}
\FunctionTok{get.disparity}\NormalTok{(disparity)}

\DocumentationTok{\#\# Extracting the disparity from the bootstrapped values from the}
\DocumentationTok{\#\# 10th rarefaction level from the second subsets (80 Mya)}
\FunctionTok{get.disparity}\NormalTok{(disparity, }\AttributeTok{observed =} \ConstantTok{FALSE}\NormalTok{, }\AttributeTok{subsets =} \DecValTok{2}\NormalTok{, }\AttributeTok{rarefaction =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{scale.disprity}{%
\subsubsection{\texorpdfstring{\texttt{scale.dispRity}}{scale.dispRity}}\label{scale.disprity}}

This is the modified S3 method for \texttt{scale} (scaling and/or centring) that can be applied to the disparity data of a \texttt{dispRity} object and can take optional arguments (for example the rescaling by dividing by a maximum value).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Getting the disparity values of the time subsets}
\FunctionTok{head}\NormalTok{(}\FunctionTok{summary}\NormalTok{(disparity))}

\DocumentationTok{\#\# Scaling the same disparity values}
\FunctionTok{head}\NormalTok{(}\FunctionTok{summary}\NormalTok{(}\FunctionTok{scale.dispRity}\NormalTok{(disparity, }\AttributeTok{scale =} \ConstantTok{TRUE}\NormalTok{)))}

\DocumentationTok{\#\# Scaling and centering:}
\FunctionTok{head}\NormalTok{(}\FunctionTok{summary}\NormalTok{(}\FunctionTok{scale.dispRity}\NormalTok{(disparity, }\AttributeTok{scale =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{center =} \ConstantTok{TRUE}\NormalTok{)))}

\DocumentationTok{\#\# Rescaling the value by dividing by a maximum value}
\FunctionTok{head}\NormalTok{(}\FunctionTok{summary}\NormalTok{(}\FunctionTok{scale.dispRity}\NormalTok{(disparity, }\AttributeTok{max =} \DecValTok{10}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\hypertarget{sort.disprity}{%
\subsubsection{\texorpdfstring{\texttt{sort.dispRity}}{sort.dispRity}}\label{sort.disprity}}

This is the S3 method of \texttt{sort} for sorting the subsets alphabetically (default) or following a specific pattern.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Sorting the disparity subsets in inverse alphabetic order}
\FunctionTok{head}\NormalTok{(}\FunctionTok{summary}\NormalTok{(}\FunctionTok{sort}\NormalTok{(disparity, }\AttributeTok{decreasing =} \ConstantTok{TRUE}\NormalTok{)))}

\DocumentationTok{\#\# Customised sorting}
\FunctionTok{head}\NormalTok{(}\FunctionTok{summary}\NormalTok{(}\FunctionTok{sort}\NormalTok{(disparity, }\AttributeTok{sort =} \FunctionTok{c}\NormalTok{(}\DecValTok{7}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{6}\NormalTok{))))}
\end{Highlighting}
\end{Shaded}

\hypertarget{get.tree-add.tree-and-remove.tree}{%
\subsubsection{\texorpdfstring{\texttt{get.tree} \texttt{add.tree} and \texttt{remove.tree}}{get.tree add.tree and remove.tree}}\label{get.tree-add.tree-and-remove.tree}}

These functions allow to manipulate the potential tree components of \texttt{dispRity} objects.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Getting the tree component of a dispRity object}
\FunctionTok{get.tree}\NormalTok{(disparity)}

\DocumentationTok{\#\# Removing the tree}
\FunctionTok{remove.tree}\NormalTok{(disparity)}

\DocumentationTok{\#\# Adding a tree}
\FunctionTok{add.tree}\NormalTok{(disparity, }\AttributeTok{tree =}\NormalTok{ BeckLee\_tree)}
\end{Highlighting}
\end{Shaded}

Note that \texttt{get.tree} can also be used to extract trees from different subsets (custom or continuous/discrete subsets).

For example, if we have three time bins like in the example below we have three time bins and we can extract the subtrees for these three time bins in different ways using the option \texttt{subsets} and \texttt{to.root}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Load the Beck \& Lee 2014 data}
\FunctionTok{data}\NormalTok{(BeckLee\_tree) ; }\FunctionTok{data}\NormalTok{(BeckLee\_mat99) ; }\FunctionTok{data}\NormalTok{(BeckLee\_ages)}

\DocumentationTok{\#\# Time binning (discrete method)}
\DocumentationTok{\#\# Generate two discrete time bins from 120 to 40 Ma every 20 Ma}
\NormalTok{time\_bins }\OtherTok{\textless{}{-}} \FunctionTok{chrono.subsets}\NormalTok{(}\AttributeTok{data =}\NormalTok{ BeckLee\_mat99, }\AttributeTok{tree =}\NormalTok{ BeckLee\_tree,}
                            \AttributeTok{method =} \StringTok{"discrete"}\NormalTok{, }\AttributeTok{time =} \FunctionTok{c}\NormalTok{(}\DecValTok{120}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{60}\NormalTok{),}
                            \AttributeTok{inc.nodes =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{FADLAD =}\NormalTok{ BeckLee\_ages)}

\DocumentationTok{\#\# Getting the subtrees all the way to the root}
\NormalTok{root\_subsets }\OtherTok{\textless{}{-}} \FunctionTok{get.tree}\NormalTok{(time\_bins, }\AttributeTok{subsets =} \ConstantTok{TRUE}\NormalTok{)}

\DocumentationTok{\#\# Plotting the bin contents}
\NormalTok{old\_par }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(BeckLee\_tree, }\AttributeTok{main =} \StringTok{"original tree"}\NormalTok{, }\AttributeTok{show.tip.label =} \ConstantTok{FALSE}\NormalTok{)}
\FunctionTok{axisPhylo}\NormalTok{()}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{v =}\NormalTok{ BeckLee\_tree}\SpecialCharTok{$}\NormalTok{root.time }\SpecialCharTok{{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{120}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{60}\NormalTok{))}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{) \{}
     \FunctionTok{plot}\NormalTok{(root\_subsets[[i]], }\AttributeTok{main =} \FunctionTok{names}\NormalTok{(root\_subsets)[i],}
          \AttributeTok{show.tip.label =} \ConstantTok{FALSE}\NormalTok{)}
     \FunctionTok{axisPhylo}\NormalTok{()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-218-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(old\_par)}
\end{Highlighting}
\end{Shaded}

But we can also extract the subtrees containing only branch lengths for the actual bins using \texttt{to.root\ =\ FALSE}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Getting the subtrees all the way to the root}
\NormalTok{bin\_subsets }\OtherTok{\textless{}{-}} \FunctionTok{get.tree}\NormalTok{(time\_bins, }\AttributeTok{subsets =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{to.root =} \ConstantTok{FALSE}\NormalTok{)}

\DocumentationTok{\#\# Plotting the bin contents}
\NormalTok{old\_par }\OtherTok{\textless{}{-}} \FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(BeckLee\_tree, }\AttributeTok{main =} \StringTok{"original tree"}\NormalTok{, }\AttributeTok{show.tip.label =} \ConstantTok{FALSE}\NormalTok{)}
\FunctionTok{axisPhylo}\NormalTok{()}
\FunctionTok{abline}\NormalTok{(}\AttributeTok{v =}\NormalTok{ BeckLee\_tree}\SpecialCharTok{$}\NormalTok{root.time }\SpecialCharTok{{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{120}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{60}\NormalTok{))}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{) \{}
     \FunctionTok{plot}\NormalTok{(bin\_subsets[[i]], }\AttributeTok{main =} \FunctionTok{names}\NormalTok{(bin\_subsets)[i],}
          \AttributeTok{show.tip.label =} \ConstantTok{FALSE}\NormalTok{)}
     \FunctionTok{axisPhylo}\NormalTok{()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-219-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{par}\NormalTok{(old\_par)}
\end{Highlighting}
\end{Shaded}

This can be useful for example for calculating the branch lengths in each bin:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# How many cumulated phylogenetic diversity in each bin?}
\FunctionTok{lapply}\NormalTok{(bin\_subsets, }\ControlFlowTok{function}\NormalTok{(tree) }\FunctionTok{sum}\NormalTok{(tree}\SpecialCharTok{$}\NormalTok{edge.length))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $`120 - 100`
## [1] 189.2829
## 
## $`100 - 80`
## [1] 341.7223
## 
## $`80 - 60`
## [1] 426.7486
\end{verbatim}

\hypertarget{disprity-object}{%
\section{\texorpdfstring{The \texttt{dispRity} object content}{The dispRity object content}}\label{disprity-object}}

The functions above are utilities to easily and safely access different elements in the \texttt{dispRity} object.
Alternatively, of course, each elements can be accessed manually.
Here is an explanation on how it works.
The \texttt{dispRity} object is a \texttt{list} of two to four elements, each of which are detailed below:

\begin{itemize}
\tightlist
\item
  \texttt{\$matrix}: an object of class \texttt{list} that contains at least one object of class \texttt{matrix}: the full multidimensional space.
\item
  \texttt{\$call}: an object of class \texttt{list} containing information on the \texttt{dispRity} object content.
\item
  \texttt{\$subsets}: an object of class \texttt{list} containing the subsets of the multidimensional space.
\item
  \texttt{\$disparity}: an object of class \texttt{list} containing the disparity values.
\end{itemize}

The \texttt{dispRity} object is loosely based on \texttt{C} structure objects.
In fact, it is composed of one unique instance of a matrix (the multidimensional space) upon which the metric function is called via ``pointers'' to only a certain number of elements and/or dimensions of this matrix.
This allows for: (1) faster and easily tractable execution time: the metric functions are called through apply family function and can be parallelised; and (2) a really low memory footprint: at any time, only one matrix (or list of matrices) is present in the \texttt{R} environment rather than multiple copies of it for each subset.

\hypertarget{matrix}{%
\subsection{\texorpdfstring{\texttt{\$matrix}}{\$matrix}}\label{matrix}}

This is the multidimensional space, stored in the \texttt{R} environment as a \texttt{list} object containing one or more \texttt{matrix} objects.
Each \texttt{matrix} requires row names but not column names (optional).
By default, if the row names are missing, \texttt{dispRity} function will arbitrarily generate them in numeric order (i.e.~\texttt{rownames(matrix)\ \textless{}-\ 1:nrow(matrix)}).
This element of the \texttt{dispRity} object is never modified.

\hypertarget{call}{%
\subsection{\texorpdfstring{\texttt{\$call}}{\$call}}\label{call}}

This element contains the information on the \texttt{dispRity} object content.
It is a \texttt{list} that can contain the following:

\begin{itemize}
\tightlist
\item
  \texttt{\$call\$subsets}: a vector of \texttt{character} with information on the subsets type (either \texttt{"continuous"}, \texttt{"discrete"} or \texttt{"custom"}), their eventual model (\texttt{"acctran"}, \texttt{"deltran"}, \texttt{"random"}, \texttt{"proximity"}, \texttt{"equal.split"}, \texttt{"gradual.split"}) and eventual information about the trees and matrices used through \texttt{chrono.subsets}. This element generated only once via \texttt{chrono.subsets()} and \texttt{custom.subsets()}.
\item
  \texttt{\$call\$dimensions}: either a single \texttt{numeric} value indicating how many dimensions to use or a vector of \texttt{numeric} values indicating which specific dimensions to use. This element is by default the number of columns in \texttt{\$matrix} but can be modified through \texttt{boot.matrix()} or \texttt{dispRity()}.
\item
  \texttt{\$call\$bootstrap}: this is a \texttt{list} containing three elements:

  \begin{itemize}
  \tightlist
  \item
    \texttt{{[}{[}1{]}{]}}: the number of bootstrap replicates (\texttt{numeric})
  \item
    \texttt{{[}{[}2{]}{]}}: the bootstrap method (\texttt{character})
  \item
    \texttt{{[}{[}3{]}{]}}: the rarefaction levels (\texttt{numeric} vector)
  \end{itemize}
\item
  \texttt{\$call\$disparity}: this is a \texttt{list} containing one element, \texttt{\$metric}, that is a \texttt{list} containing the different functions passed to the \texttt{metric} argument in \texttt{dispRity}. These are \texttt{call} elements and get modified each time the \texttt{dispRity} function is used (the first element is the first metric(s), the second, the second metric(s), etc.).
\end{itemize}

\hypertarget{subsets-1}{%
\subsection{\texorpdfstring{\texttt{\$subsets}}{\$subsets}}\label{subsets-1}}

This element contain the eventual subsets of the multidimensional space.
It is a \texttt{list} of subset names.
Each subset name is in turn a \texttt{list} of at least one element called \texttt{elements} which is in turn a \texttt{matrix}.
This \texttt{elements} matrix is the raw (observed) elements in the subsets.
The \texttt{elements} matrix is composed of \texttt{numeric} values in one column and \emph{n} rows (the number of elements in the subset).
Each of these values are a ``pointer'' (\texttt{C} inspired) to the element of the \texttt{\$matrix}.
For example, lets assume a \texttt{dispRity} object called \texttt{disparity}, composed of at least one subsets called \texttt{sub1}:

\begin{verbatim}
 disparity$subsets$sub1$elements
      [,1]
 [1,]    5
 [2,]    4
 [3,]    6
 [4,]    7
\end{verbatim}

The values in the matrix ``point'' to the elements in \texttt{\$matrix}: here, the multidimensional space with only the 4th, 5th, 6th and 7th elements.
The following elements in \texttt{diparity\$subsets\$sub1} will correspond to the same ``pointers'' but drawn from the bootstrap replicates.
The columns will correspond to different bootstrap replicates.
For example:

\begin{verbatim}
 disparity$subsets$sub1[[2]]
      [,1] [,2] [,3] [,4]
 [1,]   57   43   70    4
 [2,]   43   44    4    4
 [3,]   42   84   44    1
 [4,]   84    7    2   10
\end{verbatim}

This signifies that we have four bootstrap pseudo-replicates pointing each time to four elements in \texttt{\$matrix}.
The next element (\texttt{{[}{[}3{]}{]}}) will be the same for the eventual first rarefaction level (i.e.~the resulting bootstrap matrix will have \emph{m} rows where \emph{m} is the number of elements for this rarefaction level).
The next element after that (\texttt{{[}{[}4{]}{]}}) will be the same for with an other rarefaction level and so forth\ldots{}

When a probabilistic model was used to select the elements (models that have the \texttt{"split"} suffix, e.g.~\texttt{chrono.subsets(...,\ model\ =\ "gradual.split")}), the \texttt{\$elements} is a matrix containing a pair of elements of the matrix and a probability for sampling the first element in that list:

\begin{verbatim}
 disparity$subsets$sub1$elements
      [,1] [,2]       [,3]
 [1,]   73   36 0.01871893
 [2,]   74   37 0.02555876
 [3,]   33   38 0.85679821
\end{verbatim}

In this example, you can read the table row by row as: ``there is a probability of \texttt{0.018} for sampling element \texttt{73} and a probability of \texttt{0.82} (\texttt{1-0.018}) of sampling element \texttt{36}''.

\hypertarget{disparity}{%
\subsection{\texorpdfstring{\texttt{\$disparity}}{\$disparity}}\label{disparity}}

The \texttt{\$disparity} element is identical to the \texttt{\$subsets} element structure (a list of list(s) containing matrices) but the matrices don't contain ``pointers'' to \texttt{\$matrix} but the disparity result of the disparity metric applied to the ``pointers''.
For example, in our first example (\texttt{\$elements}) from above, if the disparity metric is of dimensions level 1, we would have:

\begin{verbatim}
 disparity$disparity$sub1$elements
      [,1]
 [1,]    1.82
\end{verbatim}

This is the observed disparity (1.82) for the subset called \texttt{sub1}.
If the disparity metric is of dimension level 2 (say the function \texttt{range} that outputs two values), we would have:

\begin{verbatim}
 disparity$disparity$sub1$elements
      [,1]
 [1,]    0.82
 [2,]    2.82
\end{verbatim}

The following elements in the list follow the same logic as before: rows are disparity values (one row for a dimension level 1 metric, multiple for a dimensions level 2 metric) and columns are the bootstrap replicates (the bootstrap with all elements followed by the eventual rarefaction levels).
For example for the bootstrap without rarefaction (second element of the list):

\begin{verbatim}
 disparity$disparity$sub1[[2]]
         [,1]     [,2]     [,3]     [,4]
[1,] 1.744668 1.777418 1.781624 1.739679 
\end{verbatim}

\hypertarget{disprity-ecology-demo}{%
\chapter{dispRity ecology demo}\label{disprity-ecology-demo}}

This is an example of typical disparity analysis that can be performed in ecology.

\hypertarget{data}{%
\section{Data}\label{data}}

For this example, we will use the famous \texttt{iris} inbuilt data set

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

This data contains petal and sepal length for 150 individual plants sorted into three species.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Separating the species}
\NormalTok{species }\OtherTok{\textless{}{-}}\NormalTok{ iris[,}\DecValTok{5}\NormalTok{]}
\DocumentationTok{\#\# Which species?}
\FunctionTok{unique}\NormalTok{(species)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] setosa     versicolor virginica 
## Levels: setosa versicolor virginica
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Separating the petal/sepal length}
\NormalTok{measurements }\OtherTok{\textless{}{-}}\NormalTok{ iris[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{]}
\FunctionTok{head}\NormalTok{(measurements)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   Sepal.Length Sepal.Width Petal.Length Petal.Width
## 1          5.1         3.5          1.4         0.2
## 2          4.9         3.0          1.4         0.2
## 3          4.7         3.2          1.3         0.2
## 4          4.6         3.1          1.5         0.2
## 5          5.0         3.6          1.4         0.2
## 6          5.4         3.9          1.7         0.4
\end{verbatim}

We can then ordinate the data using a PCA (\texttt{prcomp} function) thus defining our four dimensional space as the poetically named petal-space.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Ordinating the data}
\NormalTok{ordination }\OtherTok{\textless{}{-}} \FunctionTok{prcomp}\NormalTok{(measurements)}

\DocumentationTok{\#\# The petal{-}space}
\NormalTok{petal\_space }\OtherTok{\textless{}{-}}\NormalTok{ ordination}\SpecialCharTok{$}\NormalTok{x}

\DocumentationTok{\#\# Adding the elements names to the petal{-}space (the individuals IDs)}
\FunctionTok{rownames}\NormalTok{(petal\_space) }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{nrow}\NormalTok{(petal\_space)}
\end{Highlighting}
\end{Shaded}

\hypertarget{classic-analysis}{%
\section{Classic analysis}\label{classic-analysis}}

A classical way to represent this ordinated data would be to use two dimensional plots to look at how the different species are distributed in the petal-space.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Measuring the variance on each axis}
\NormalTok{axis\_variances }\OtherTok{\textless{}{-}} \FunctionTok{apply}\NormalTok{(petal\_space, }\DecValTok{2}\NormalTok{, var)}
\NormalTok{axis\_variances }\OtherTok{\textless{}{-}}\NormalTok{ axis\_variances}\SpecialCharTok{/}\FunctionTok{sum}\NormalTok{(axis\_variances)}

\DocumentationTok{\#\# Graphical option}
\FunctionTok{par}\NormalTok{(}\AttributeTok{bty =} \StringTok{"n"}\NormalTok{)}

\DocumentationTok{\#\# A classic 2D ordination plot}
\FunctionTok{plot}\NormalTok{(petal\_space[, }\DecValTok{1}\NormalTok{], petal\_space[, }\DecValTok{2}\NormalTok{], }\AttributeTok{col =}\NormalTok{ species,}
    \AttributeTok{xlab =} \FunctionTok{paste0}\NormalTok{(}\StringTok{"PC 1 ("}\NormalTok{, }\FunctionTok{round}\NormalTok{(axis\_variances[}\DecValTok{1}\NormalTok{], }\DecValTok{2}\NormalTok{), }\StringTok{")"}\NormalTok{),}
    \AttributeTok{ylab =} \FunctionTok{paste0}\NormalTok{(}\StringTok{"PC 2 ("}\NormalTok{, }\FunctionTok{round}\NormalTok{(axis\_variances[}\DecValTok{2}\NormalTok{], }\DecValTok{2}\NormalTok{), }\StringTok{")"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-224-1.pdf}

This shows the distribution of the different species in the petal-space along the two first axis of variation.
This is a pretty standard way to visualise the multidimensional space and further analysis might be necessary to test wether the groups are different such as a linear discriminant analysis (LDA).
However, in this case we are ignoring the two other dimensions of the ordination!
If we look at the two other axis we see a totally different result:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Plotting the two second axis of the petal{-}space}
\FunctionTok{plot}\NormalTok{(petal\_space[, }\DecValTok{3}\NormalTok{], petal\_space[, }\DecValTok{4}\NormalTok{], }\AttributeTok{col =}\NormalTok{ species,}
    \AttributeTok{xlab =} \FunctionTok{paste0}\NormalTok{(}\StringTok{"PC 3 ("}\NormalTok{, }\FunctionTok{round}\NormalTok{(axis\_variances[}\DecValTok{3}\NormalTok{], }\DecValTok{2}\NormalTok{), }\StringTok{")"}\NormalTok{),}
    \AttributeTok{ylab =} \FunctionTok{paste0}\NormalTok{(}\StringTok{"PC 4 ("}\NormalTok{, }\FunctionTok{round}\NormalTok{(axis\_variances[}\DecValTok{4}\NormalTok{], }\DecValTok{2}\NormalTok{), }\StringTok{")"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-225-1.pdf}

Additionally, these two represented dimensions do not represent a biological reality \emph{per se}; i.e.~the values on the first dimension do not represent a continuous trait (e.g.~petal length), instead they just represent the ordinations of correlations between the data and some factors.

Therefore, we might want to approach this problem without getting stuck in only two dimensions and consider the whole dataset as a \emph{n}-dimensional object.

\hypertarget{a-multidimensional-approach-with-disprity}{%
\section{\texorpdfstring{A multidimensional approach with \texttt{dispRity}}{A multidimensional approach with dispRity}}\label{a-multidimensional-approach-with-disprity}}

The first step is to create different subsets that represent subsets of the ordinated space (i.e.~sub-regions within the \emph{n}-dimensional object).
Each of these subsets will contain only the individuals of a specific species.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating the table that contain the elements and their attributes}
\NormalTok{petal\_subsets }\OtherTok{\textless{}{-}} \FunctionTok{custom.subsets}\NormalTok{(petal\_space, }\AttributeTok{group =} \FunctionTok{list}\NormalTok{(}
                                \StringTok{"setosa"} \OtherTok{=} \FunctionTok{which}\NormalTok{(species }\SpecialCharTok{==} \StringTok{"setosa"}\NormalTok{),}
                                \StringTok{"versicolor"} \OtherTok{=} \FunctionTok{which}\NormalTok{(species }\SpecialCharTok{==} \StringTok{"versicolor"}\NormalTok{),}
                                \StringTok{"virginica"} \OtherTok{=} \FunctionTok{which}\NormalTok{(species }\SpecialCharTok{==} \StringTok{"virginica"}\NormalTok{)))}

\DocumentationTok{\#\# Visualising the dispRity object content}
\NormalTok{petal\_subsets}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 3 customised subsets for 150 elements in one matrix:
##     setosa, versicolor, virginica.
\end{verbatim}

This created a \texttt{dispRity} object (more about that \protect\hyperlink{guts}{here}) with three subsets corresponding to each subspecies.

\hypertarget{bootstrapping-the-data}{%
\subsection{Bootstrapping the data}\label{bootstrapping-the-data}}

We can the bootstrap the subsets to be able test the robustness of the measured disparity to outliers.
We can do that using the default options of \texttt{boot.matrix} (more about that \protect\hyperlink{bootstraps-and-rarefactions}{here}):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Bootstrapping the data}
\NormalTok{(petal\_bootstrapped }\OtherTok{\textless{}{-}} \FunctionTok{boot.matrix}\NormalTok{(petal\_subsets))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 3 customised subsets for 150 elements in one matrix with 4 dimensions:
##     setosa, versicolor, virginica.
## Rows were bootstrapped 100 times (method:"full").
\end{verbatim}

\hypertarget{calculating-disparity}{%
\subsection{Calculating disparity}\label{calculating-disparity}}

Disparity can be calculated in many ways, therefore the \texttt{dispRity} function allows users to define their own measure of disparity.
For more details on measuring disparity, see the \protect\hyperlink{disparity-metrics}{dispRity metrics section}.

In this example, we are going to define disparity as the median distance between the different individuals and the centroid of the ordinated space.
High values of disparity will indicate a generally high spread of points from this centroid (i.e.~on average, the individuals are far apart in the ordinated space).
We can define the metrics easily in the \texttt{dispRity} function by feeding them to the \texttt{metric} argument.
Here we are going to feed the functions \texttt{stats::median} and \texttt{dispRity::centroids} which calculates distances between elements and their centroid.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating disparity as the median distance between each elements and}
\DocumentationTok{\#\# the centroid of the petal{-}space}
\NormalTok{(petal\_disparity }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(petal\_bootstrapped, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(median, centroids)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 3 customised subsets for 150 elements in one matrix with 4 dimensions:
##     setosa, versicolor, virginica.
## Rows were bootstrapped 100 times (method:"full").
## Disparity was calculated as: c(median, centroids).
\end{verbatim}

\hypertarget{summarising-the-results-plot}{%
\subsection{Summarising the results (plot)}\label{summarising-the-results-plot}}

Similarly to the \texttt{custom.subsets} and \texttt{boot.matrix} function, \texttt{dispRity} displays a \texttt{dispRity} object.
But we are definitely more interested in actually look at the calculated values.

First we can summarise the data in a table by simply using \texttt{summary}:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Displaying the summary of the calculated disparity}
\FunctionTok{summary}\NormalTok{(petal\_disparity)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      subsets  n   obs bs.median  2.5%   25%   75% 97.5%
## 1     setosa 50 0.421     0.432 0.363 0.409 0.456 0.502
## 2 versicolor 50 0.693     0.662 0.563 0.618 0.702 0.781
## 3  virginica 50 0.785     0.719 0.548 0.652 0.786 0.902
\end{verbatim}

We can also plot the results in a similar way:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Graphical options}
\FunctionTok{par}\NormalTok{(}\AttributeTok{bty =} \StringTok{"n"}\NormalTok{)}

\DocumentationTok{\#\# Plotting the disparity in the petal\_space}
\FunctionTok{plot}\NormalTok{(petal\_disparity)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-230-1.pdf}

Now contrary to simply plotting the two first axis of the PCA where we saw that the species have a different position in the two first petal-space, we can now also see that they occupy this space clearly differently!

\hypertarget{testing-hypothesis}{%
\subsection{Testing hypothesis}\label{testing-hypothesis}}

Finally we can test our hypothesis that we guessed from the disparity plot (that some groups occupy different volume of the petal-space) by using the \texttt{test.dispRity} option.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Running a PERMANOVA}
\FunctionTok{test.dispRity}\NormalTok{(petal\_disparity, }\AttributeTok{test =}\NormalTok{ adonis.dispRity)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in test.dispRity(petal_disparity, test = adonis.dispRity): adonis.dispRity test will be applied to the data matrix, not to the calculated disparity.
## See ?adonis.dispRity for more details.
\end{verbatim}

\begin{verbatim}
## Warning in adonis.dispRity(data, ...): The input data for adonis.dispRity was not a distance matrix.
## The results are thus based on the distance matrix for the input data (i.e. dist(data$matrix[[1]])).
## Make sure that this is the desired methodological approach!
\end{verbatim}

\begin{verbatim}
## Permutation test for adonis under reduced model
## Permutation: free
## Number of permutations: 999
## 
## vegan::adonis2(formula = dist(matrix) ~ group, method = "euclidean")
##           Df SumOfSqs      R2      F Pr(>F)    
## Model      2   592.07 0.86894 487.33  0.001 ***
## Residual 147    89.30 0.13106                  
## Total    149   681.37 1.00000                  
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Post{-}hoc testing of the differences between species (corrected for multiple tests)}
\FunctionTok{test.dispRity}\NormalTok{(petal\_disparity, }\AttributeTok{test =}\NormalTok{ t.test, }\AttributeTok{correction =} \StringTok{"bonferroni"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
##                        statistic: t
## setosa : versicolor       -33.37334
## setosa : virginica        -28.36656
## versicolor : virginica     -5.24564
## 
## [[2]]
##                        parameter: df
## setosa : versicolor         166.2319
## setosa : virginica          127.7601
## versicolor : virginica      164.6248
## 
## [[3]]
##                             p.value
## setosa : versicolor    4.126944e-75
## setosa : virginica     1.637347e-56
## versicolor : virginica 1.420552e-06
## 
## [[4]]
##                             stderr
## setosa : versicolor    0.006875869
## setosa : virginica     0.010145340
## versicolor : virginica 0.011117360
\end{verbatim}

We can now see that there is a significant difference in petal-space occupancy between all species of iris.

\hypertarget{setting-up-a-multidimensional-null-hypothesis}{%
\subsubsection{Setting up a multidimensional null-hypothesis}\label{setting-up-a-multidimensional-null-hypothesis}}

One other series of test can be done on the shape of the petal-space.
Using a MCMC permutation test we can simulate a petal-space with specific properties and see if our observed petal-space matches these properties (similarly to \citet{diaz2016global}):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Testing against a uniform distribution}
\NormalTok{disparity\_uniform }\OtherTok{\textless{}{-}} \FunctionTok{null.test}\NormalTok{(petal\_disparity, }\AttributeTok{replicates =} \DecValTok{200}\NormalTok{,}
    \AttributeTok{null.distrib =}\NormalTok{ runif, }\AttributeTok{scale =} \ConstantTok{FALSE}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(disparity\_uniform)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-232-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Testing against a normal distribution}
\NormalTok{disparity\_normal }\OtherTok{\textless{}{-}} \FunctionTok{null.test}\NormalTok{(petal\_disparity, }\AttributeTok{replicates =} \DecValTok{200}\NormalTok{,}
    \AttributeTok{null.distrib =}\NormalTok{ rnorm, }\AttributeTok{scale =} \ConstantTok{TRUE}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(disparity\_normal)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-233-1.pdf}

In both cases we can see that our petal-space is not entirely normal or uniform.
This is expected because of the simplicity of these parameters.

\hypertarget{palaeobiology-demo-disparity-through-time-and-within-groups}{%
\chapter{Palaeobiology demo: disparity-through-time and within groups}\label{palaeobiology-demo-disparity-through-time-and-within-groups}}

This demo aims to give quick overview of the \texttt{dispRity} package (v.1.7) for palaeobiology analyses of disparity, including disparity through time analyses.

This demo showcases a typical disparity-through-time analysis: we are going to test whether the disparity changed through time in a subset of eutherian mammals from the last 100 million years using a dataset from \citet{beckancient2014}.

\hypertarget{before-starting}{%
\section{Before starting}\label{before-starting}}

\hypertarget{the-morphospace}{%
\subsection{The morphospace}\label{the-morphospace}}

In this example, we are going to use a subset of the data from \citet{beckancient2014}.
See the \protect\hyperlink{example-data}{example data} description for more details.
Briefly, this dataset contains an ordinated matrix of the Gower distance between 50 mammals based (\texttt{BeckLee\_mat50}), another matrix of the same 50 mammals and the estimated discrete data characters of their descendants (thus 50 + 49 rows, \texttt{BeckLee\_mat99}), a dataframe containing the ages of each taxon in the dataset (\texttt{BeckLee\_ages}) and finally a phylogenetic tree with the relationships among the 50 mammals (\texttt{BeckLee\_tree}).
The ordinated matrix will represent our full morphospace, i.e.~all the mammalian morphologies that ever existed through time (for this dataset).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading demo and the package data}
\FunctionTok{library}\NormalTok{(dispRity)}

\DocumentationTok{\#\# Setting the random seed for repeatability}
\FunctionTok{set.seed}\NormalTok{(}\DecValTok{123}\NormalTok{)}

\DocumentationTok{\#\# Loading the ordinated matrix/morphospace:}
\FunctionTok{data}\NormalTok{(BeckLee\_mat50)}
\FunctionTok{data}\NormalTok{(BeckLee\_mat99)}
\FunctionTok{head}\NormalTok{(BeckLee\_mat50[,}\DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                    [,1]        [,2]        [,3]       [,4]       [,5]
## Cimolestes   -0.5613001  0.06006259  0.08414761 -0.2313084 0.18825039
## Maelestes    -0.4186019 -0.12186005  0.25556379  0.2737995 0.28510479
## Batodon      -0.8337640  0.28718501 -0.10594610 -0.2381511 0.07132646
## Bulaklestes  -0.7708261 -0.07629583  0.04549285 -0.4951160 0.39962626
## Daulestes    -0.8320466 -0.09559563  0.04336661 -0.5792351 0.37385914
## Uchkudukodon -0.5074468 -0.34273248  0.40410310 -0.1223782 0.34857351
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(BeckLee\_mat50)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 50 48
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The morphospace contains 50 taxa and has 48 dimensions (or axes)}

\DocumentationTok{\#\# Showing a list of first and last occurrences data for some fossils}
\FunctionTok{data}\NormalTok{(BeckLee\_ages)}
\FunctionTok{head}\NormalTok{(BeckLee\_ages)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             FAD  LAD
## Adapis     37.2 36.8
## Asioryctes 83.6 72.1
## Leptictis  33.9 33.3
## Miacis     49.0 46.7
## Mimotona   61.6 59.2
## Notharctus 50.2 47.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Plotting a phylogeny}
\FunctionTok{data}\NormalTok{(BeckLee\_tree)}
\FunctionTok{plot}\NormalTok{(BeckLee\_tree, }\AttributeTok{cex =} \FloatTok{0.7}\NormalTok{)}
\FunctionTok{axisPhylo}\NormalTok{(}\AttributeTok{root =} \DecValTok{140}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-234-1.pdf}

\begin{quote}
You can have an even nicer looking tree if you use the \texttt{strap} package!
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{require}\NormalTok{(strap)) }\FunctionTok{install.packages}\NormalTok{(}\StringTok{"strap"}\NormalTok{)}
\NormalTok{strap}\SpecialCharTok{::}\FunctionTok{geoscalePhylo}\NormalTok{(BeckLee\_tree, }\AttributeTok{cex.tip =} \FloatTok{0.7}\NormalTok{, }\AttributeTok{cex.ts =} \FloatTok{0.6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-235-1.pdf}

\hypertarget{setting-up-your-own-data}{%
\subsection{Setting up your own data}\label{setting-up-your-own-data}}

I greatly encourage you to follow along this tutorial with your very own data: it is more exciting and, ultimately, that's probably your objective.

\begin{quote}
What data can I use?
\end{quote}

You can use any type of morphospace in any dataset form (\texttt{"matrix"}, \texttt{"data.frame"}). Throughout this tutorial, you we assume you are using the (loose) morphospace definition from \citet{Guillerme2020}: any matrix were columns are traits and rows are observations (in a distance matrix, columns are still trait, i.e.~``distance to species A'', etc.).
We won't cover it here but you can also use lists of matrices and list of trees.

\begin{quote}
How should I format my data for this tutorial?
\end{quote}

To go through this tutorial you will need:

\begin{itemize}
\tightlist
\item
  A matrix with tip data
\item
  A phylogenetic tree
\item
  A matrix with tip and node data
\item
  A table of first and last occurrences data (FADLAD)
\end{itemize}

If you are missing any of these, fear not, here are a couple of functions to simulate the missing data, it will surely make your results look funky but it'll let you go through the tutorial.

\begin{quote}
\textbf{WARNING:} the data generated by the functions \texttt{i.need.a.matrix}, \texttt{i.need.a.tree}, \texttt{i.need.node.data} and \texttt{i.need.FADLAD} are used to \textbf{SIMULATE} data for this tutorial. This is \emph{not} to be used for publications or analysing real data!
If you need a data matrix, a phylogenetic tree or FADLAD data, (\texttt{i.need.a.matrix}, \texttt{i.need.a.tree} and \texttt{i.need.FADLAD}), you will actually need to collect data from the literature or the field! If you need node data, you will need to use ancestral states estimations (e.g.~using \texttt{estimate\_ancestral\_states} from the \href{https://cran.r-project.org/web/packages/Claddis/index.html}{\texttt{Claddis} package}).
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Functions to get simulate a PCO looking like matrix from a tree}
\NormalTok{i.need.a.matrix }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(tree) \{}
\NormalTok{    matrix }\OtherTok{\textless{}{-}} \FunctionTok{space.maker}\NormalTok{(}\AttributeTok{elements =} \FunctionTok{Ntip}\NormalTok{(tree), }\AttributeTok{dimensions =} \FunctionTok{Ntip}\NormalTok{(tree), }\AttributeTok{distribution =}\NormalTok{ rnorm,}
                          \AttributeTok{scree =} \FunctionTok{rev}\NormalTok{(}\FunctionTok{cumsum}\NormalTok{(}\FunctionTok{rep}\NormalTok{(}\DecValTok{1}\SpecialCharTok{/}\FunctionTok{Ntip}\NormalTok{(tree), }\FunctionTok{Ntip}\NormalTok{(tree)))))}
    \FunctionTok{rownames}\NormalTok{(matrix) }\OtherTok{\textless{}{-}}\NormalTok{ tree}\SpecialCharTok{$}\NormalTok{tip.label}
    \FunctionTok{return}\NormalTok{(matrix)}
\NormalTok{\}}

\DocumentationTok{\#\# Function to simulate a tree}
\NormalTok{i.need.a.tree }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(matrix) \{}
\NormalTok{    tree }\OtherTok{\textless{}{-}} \FunctionTok{rtree}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(matrix))}
\NormalTok{    tree}\SpecialCharTok{$}\NormalTok{root.time }\OtherTok{\textless{}{-}} \FunctionTok{max}\NormalTok{(}\FunctionTok{tree.age}\NormalTok{(tree)}\SpecialCharTok{$}\NormalTok{age)}
\NormalTok{    tree}\SpecialCharTok{$}\NormalTok{tip.label }\OtherTok{\textless{}{-}} \FunctionTok{rownames}\NormalTok{(matrix)}
\NormalTok{    tree}\SpecialCharTok{$}\NormalTok{node.label }\OtherTok{\textless{}{-}} \FunctionTok{paste0}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(matrix)}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{))}
    \FunctionTok{return}\NormalTok{(tree)}
\NormalTok{\}}

\DocumentationTok{\#\# Function to simulate some "node" data}
\NormalTok{i.need.node.data }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(matrix, tree) \{}
\NormalTok{    matrix\_node }\OtherTok{\textless{}{-}} \FunctionTok{space.maker}\NormalTok{(}\AttributeTok{elements =} \FunctionTok{Nnode}\NormalTok{(tree), }\AttributeTok{dimensions =} \FunctionTok{ncol}\NormalTok{(matrix),}
                               \AttributeTok{distribution =}\NormalTok{ rnorm, }\AttributeTok{scree =} \FunctionTok{apply}\NormalTok{(matrix, }\DecValTok{2}\NormalTok{, var))}
    \ControlFlowTok{if}\NormalTok{(}\SpecialCharTok{!}\FunctionTok{is.null}\NormalTok{(tree}\SpecialCharTok{$}\NormalTok{node.label)) \{}
        \FunctionTok{rownames}\NormalTok{(matrix\_node) }\OtherTok{\textless{}{-}}\NormalTok{ tree}\SpecialCharTok{$}\NormalTok{node.label}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \FunctionTok{rownames}\NormalTok{(matrix\_node) }\OtherTok{\textless{}{-}} \FunctionTok{paste0}\NormalTok{(}\StringTok{"n"}\NormalTok{, }\DecValTok{1}\SpecialCharTok{:}\NormalTok{(}\FunctionTok{nrow}\NormalTok{(matrix)}\SpecialCharTok{{-}}\DecValTok{1}\NormalTok{))}
\NormalTok{    \}}
    \FunctionTok{return}\NormalTok{(}\FunctionTok{rbind}\NormalTok{(matrix, matrix\_node))}
\NormalTok{\}}

\DocumentationTok{\#\# Function to simulate some "FADLAD" data}
\NormalTok{i.need.FADLAD }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(tree) \{}
\NormalTok{    tree\_ages }\OtherTok{\textless{}{-}} \FunctionTok{tree.age}\NormalTok{(tree)[}\DecValTok{1}\SpecialCharTok{:}\FunctionTok{Ntip}\NormalTok{(tree),]}
    \FunctionTok{return}\NormalTok{(}\FunctionTok{data.frame}\NormalTok{(}\AttributeTok{FAD =}\NormalTok{ tree\_ages[,}\DecValTok{1}\NormalTok{], }\AttributeTok{LAD =}\NormalTok{ tree\_ages[,}\DecValTok{1}\NormalTok{], }\AttributeTok{row.names =}\NormalTok{ tree\_ages[,}\DecValTok{2}\NormalTok{]))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

You can use these functions for the generating the data you need. For example

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Aaaaah I don\textquotesingle{}t have FADLAD data!}
\NormalTok{my\_FADLAD }\OtherTok{\textless{}{-}} \FunctionTok{i.need.FADLAD}\NormalTok{(tree)}
\DocumentationTok{\#\# Sorted.}
\end{Highlighting}
\end{Shaded}

In the end this is what your data should be named to facilitate the rest of this tutorial (fill in yours here):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# A matrix with tip data}
\NormalTok{my\_matrix }\OtherTok{\textless{}{-}}\NormalTok{ BeckLee\_mat50}

\DocumentationTok{\#\# A phylogenetic tree }
\NormalTok{my\_tree }\OtherTok{\textless{}{-}}\NormalTok{ BeckLee\_tree}

\DocumentationTok{\#\# A matrix with tip and node data}
\NormalTok{my\_tip\_node\_matrix }\OtherTok{\textless{}{-}}\NormalTok{ BeckLee\_mat99}

\DocumentationTok{\#\# A table of first and last occurrences data (FADLAD)}
\NormalTok{my\_fadlad }\OtherTok{\textless{}{-}}\NormalTok{ BeckLee\_ages}
\end{Highlighting}
\end{Shaded}

\hypertarget{a-disparity-through-time-analysis}{%
\section{A disparity-through-time analysis}\label{a-disparity-through-time-analysis}}

\hypertarget{splitting-the-morphospace-through-time}{%
\subsection{Splitting the morphospace through time}\label{splitting-the-morphospace-through-time}}

One of the crucial steps in disparity-through-time analysis is to split the full morphospace into smaller time subsets that contain the total number of morphologies at certain points in time (time-slicing) or during certain periods in time (time-binning).
Basically, the full morphospace represents the total number of morphologies across all time and will be greater than any of the time subsets of the morphospace.

The \texttt{dispRity} package provides a \texttt{chrono.subsets} function that allows users to split the morphospace into time slices (using \texttt{method\ =\ continuous}) or into time bins (using \texttt{method\ =\ discrete}).
In this example, we are going to split the morphospace into five equal time bins of 20 million years long from 100 million years ago to the present.
We will also provide to the function a table containing the first and last occurrences dates for some fossils to take into account that some fossils might occur in several of our different time bins.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Creating the vector of time bins ages}
\NormalTok{time\_bins }\OtherTok{\textless{}{-}} \FunctionTok{rev}\NormalTok{(}\FunctionTok{seq}\NormalTok{(}\AttributeTok{from =} \DecValTok{0}\NormalTok{, }\AttributeTok{to =} \DecValTok{100}\NormalTok{, }\AttributeTok{by =} \DecValTok{20}\NormalTok{))}

\DocumentationTok{\#\# Splitting the morphospace using the chrono.subsets function}
\NormalTok{binned\_morphospace }\OtherTok{\textless{}{-}} \FunctionTok{chrono.subsets}\NormalTok{(}\AttributeTok{data =}\NormalTok{ my\_matrix, }\AttributeTok{tree =}\NormalTok{ my\_tree,}
    \AttributeTok{method =} \StringTok{"discrete"}\NormalTok{, }\AttributeTok{time =}\NormalTok{ time\_bins, }\AttributeTok{inc.nodes =} \ConstantTok{FALSE}\NormalTok{,}
    \AttributeTok{FADLAD =}\NormalTok{ my\_fadlad)}
\end{Highlighting}
\end{Shaded}

The output object is a \texttt{dispRity} object (see more about that \protect\hyperlink{The-guts-of-the-dispRity-package}{here}.
In brief, \texttt{dispRity} objects are lists of different elements (i.e.~disparity results, morphospace time subsets, morphospace attributes, etc.) that display only a summary of the object when calling the object to avoiding filling the \texttt{R} console with superfluous output.
It also allows easy plotting/summarising/analysing for repeatability down the line but we will not go into this right now.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Printing the class of the object}
\FunctionTok{class}\NormalTok{(binned\_morphospace)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "dispRity"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Printing the content of the object}
\FunctionTok{str}\NormalTok{(binned\_morphospace)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 4
##  $ matrix :List of 1
##   ..$ : num [1:50, 1:48] -0.561 -0.419 -0.834 -0.771 -0.832 ...
##   .. ..- attr(*, "dimnames")=List of 2
##   .. .. ..$ : chr [1:50] "Cimolestes" "Maelestes" "Batodon" "Bulaklestes" ...
##   .. .. ..$ : NULL
##  $ tree   :Class "multiPhylo"
## List of 1
##   ..$ :List of 6
##   .. ..$ edge       : int [1:98, 1:2] 51 52 52 53 53 51 54 55 56 56 ...
##   .. ..$ edge.length: num [1:98] 24.5 24.6 12.7 11.8 11.8 ...
##   .. ..$ Nnode      : int 49
##   .. ..$ tip.label  : chr [1:50] "Daulestes" "Bulaklestes" "Uchkudukodon" "Kennalestes" ...
##   .. ..$ node.labels: chr [1:49] "n1" "n2" "n3" "n4" ...
##   .. ..$ root.time  : num 139
##   .. ..- attr(*, "class")= chr "phylo"
##   .. ..- attr(*, "order")= chr "cladewise"
##  $ call   :List of 1
##   ..$ subsets: Named chr [1:4] "discrete" "1" "1" "FALSE"
##   .. ..- attr(*, "names")= chr [1:4] "" "trees" "matrices" "bind"
##  $ subsets:List of 5
##   ..$ 100 - 80:List of 1
##   .. ..$ elements: int [1:8, 1] 5 4 6 8 43 10 11 42
##   ..$ 80 - 60 :List of 1
##   .. ..$ elements: int [1:15, 1] 7 8 9 1 2 3 12 13 14 44 ...
##   ..$ 60 - 40 :List of 1
##   .. ..$ elements: int [1:13, 1] 41 49 24 25 26 27 28 21 22 19 ...
##   ..$ 40 - 20 :List of 1
##   .. ..$ elements: int [1:6, 1] 15 39 40 35 23 47
##   ..$ 20 - 0  :List of 1
##   .. ..$ elements: int [1:10, 1] 36 37 38 32 33 34 50 48 29 30
##  - attr(*, "class")= chr "dispRity"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{names}\NormalTok{(binned\_morphospace)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "matrix"  "tree"    "call"    "subsets"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Printing the object as a dispRity class}
\NormalTok{binned\_morphospace}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 5 discrete time subsets for 50 elements in one matrix with 1 phylogenetic tree
##     100 - 80, 80 - 60, 60 - 40, 40 - 20, 20 - 0.
\end{verbatim}

\begin{quote}
These objects will gradually contain more information when completing the following steps in the disparity-through-time analysis.
\end{quote}

\hypertarget{bootstrapping-the-data-1}{%
\subsection{Bootstrapping the data}\label{bootstrapping-the-data-1}}

Once we obtain our different time subsets, we can bootstrap and rarefy them (i.e.~pseudo-replicating the data).
The bootstrapping allows us to make each subset more robust to outliers and the rarefaction allows us to compare subsets with the same number of taxa to remove sampling biases (i.e.~more taxa in one subset than the others).
The \texttt{boot.matrix} function bootstraps the \texttt{dispRity} object and the \texttt{rarefaction} option within performs rarefaction.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Getting the minimum number of rows (i.e. taxa) in the time subsets}
\NormalTok{minimum\_size }\OtherTok{\textless{}{-}} \FunctionTok{min}\NormalTok{(}\FunctionTok{size.subsets}\NormalTok{(binned\_morphospace))}

\DocumentationTok{\#\# Bootstrapping each time subset 100 times and rarefying them }
\NormalTok{rare\_bin\_morphospace }\OtherTok{\textless{}{-}} \FunctionTok{boot.matrix}\NormalTok{(binned\_morphospace, }\AttributeTok{bootstraps =} \DecValTok{100}\NormalTok{,}
    \AttributeTok{rarefaction =}\NormalTok{ minimum\_size)}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Note how information is adding up to the \texttt{dispRity} object.
\end{quote}

\hypertarget{calculating-disparity-1}{%
\subsection{Calculating disparity}\label{calculating-disparity-1}}

We can now calculate the disparity within each time subsets along with some confidence intervals generated by the pseudoreplication step above (bootstraps/rarefaction).
Disparity can be calculated in many ways and this package allows users to come up with their own disparity metrics.
For more details, please refer to the \protect\hyperlink{disparity-metrics}{\texttt{dispRity} metric section} (or directly use \href{https://tguillerme.shinyapps.io/moms/}{\texttt{moms}}).

In this example, we are going to look at how the spread of the data in the morphospace through time.
For that we are going to use the sum of the variance from each dimension of the morphospace in the morphospace.
We highly recommend using a metric that makes sense for your specific analysis and for your specific dataset and not just because everyone uses it \citep[\citet{Guillerme2020}]{moms}!

\begin{quote}
How can I be sure that the metric is the most appropriate for my morphospace and question?
\end{quote}

This is not a straightforward question but you can use the \texttt{test.metric} function to check your assumptions (more details \protect\hyperlink{disparity-metrics}{here}): basically what \texttt{test.metric} does is modifying your morphospace using a null process of interest (e.g.~changes in size) and checks whether your metric does indeed pick up that change.
For example here, let see if the sum of variances picks up changes in size but not random changes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_test }\OtherTok{\textless{}{-}} \FunctionTok{test.metric}\NormalTok{(my\_matrix, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, dispRity}\SpecialCharTok{::}\NormalTok{variances), }\AttributeTok{shifts =} \FunctionTok{c}\NormalTok{(}\StringTok{"random"}\NormalTok{, }\StringTok{"size"}\NormalTok{))}
\FunctionTok{summary}\NormalTok{(my\_test)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                  10%  20%  30%  40%  50%  60%  70%  80%  90% 100%        slope
## random          2.53 2.50 2.56 2.50 2.54 2.51 2.52 2.53 2.53 2.52 0.0003234646
## size.increase   2.23 2.17 2.25 2.26 2.31 2.35 2.39 2.47 2.50 2.52 0.0037712409
## size.hollowness 2.40 2.50 2.59 2.65 2.63 2.62 2.60 2.57 2.55 2.52 0.0008954035
##                      p_value   R^2(adj)
## random          9.689431e-02 0.06301936
## size.increase   1.016309e-17 0.93443767
## size.hollowness 6.630162e-02 0.08377594
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{plot}\NormalTok{(my\_test)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-242-1.pdf}

We see that changes in the inner size (see \citet{moms} for more details) is actually picked up by the sum of variances but not random changes or outer changes. Which is a good thing!

As you've noted, the sum of variances is defined in \texttt{test.metric} as \texttt{c(sum,\ variances)}. This is a core bit of the \texttt{dispRity} package were you can define your own metric as a function or a set of functions.
You can find more info about this in the \protect\hyperlink{disparity-metrics}{\texttt{dispRity} metric section} but in brief, the \texttt{dispRity} package considers metrics by their ``dimensions'' level which corresponds to what they output. For example, the function \texttt{sum} is a dimension level 1 function because no matter the input it outputs a single value (the sum), \texttt{variances} on the other hand is a dimension level 2 function because it will output the variance of each column in a matrix (an example of a dimensions level 3 would be the function \texttt{var} that outputs a matrix).
The \texttt{dispRity} package always automatically sorts the dimensions levels: it will always run dimensions level 3 \textgreater{} dimensions level 2 \textgreater{} and dimensions level 1. In this case both \texttt{c(sum,\ variances)} and \texttt{c(variances,\ sum)} will result in actually running \texttt{sum(variances(matrix))}.

Anyways, let's calculate the sum of variances on our bootstrapped and rarefied morphospaces:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Calculating disparity for the bootstrapped and rarefied data}
\NormalTok{disparity }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(rare\_bin\_morphospace , }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(sum, dispRity}\SpecialCharTok{::}\NormalTok{variances))}
\end{Highlighting}
\end{Shaded}

To display the actual calculated scores, we need to summarise the disparity object using the S3 method \texttt{summary} that is applied to a \texttt{dispRity} object (see \texttt{?summary.dispRity} for more details).
By the way, as for any \texttt{R} package, you can refer to the help files for each individual function for more details.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Summarising the disparity results}
\FunctionTok{summary}\NormalTok{(disparity)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    subsets  n   obs bs.median  2.5%   25%   75% 97.5%
## 1 100 - 80  8 2.207     1.962 1.615 1.876 2.017 2.172
## 2 100 - 80  6    NA     1.923 1.477 1.768 2.065 2.222
## 3  80 - 60 15 2.315     2.167 1.979 2.111 2.227 2.308
## 4  80 - 60  6    NA     2.167 1.831 2.055 2.300 2.460
## 5  60 - 40 13 2.435     2.244 2.006 2.183 2.304 2.384
## 6  60 - 40  6    NA     2.284 1.683 2.140 2.383 2.532
## 7  40 - 20  6 2.604     2.206 1.628 2.026 2.388 2.604
## 8   20 - 0 10 2.491     2.257 1.958 2.170 2.326 2.421
## 9   20 - 0  6    NA     2.302 1.766 2.143 2.366 2.528
\end{verbatim}

\begin{quote}
The \texttt{summary.dispRity} function comes with many options on which values to calculate (central tendency and quantiles) and on how many digits to display. Refer to the function's manual for more details.
\end{quote}

\hypertarget{plotting-the-results}{%
\subsection{Plotting the results}\label{plotting-the-results}}

It is sometimes easier to visualise the results in a plot than in a table.
For that we can use the \texttt{plot} S3 function to plot the \texttt{dispRity} objects (see \texttt{?plot.dispRity} for more details).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Graphical options}
\FunctionTok{quartz}\NormalTok{(}\AttributeTok{width =} \DecValTok{10}\NormalTok{, }\AttributeTok{height =} \DecValTok{5}\NormalTok{) ; }\FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =}\NormalTok{ (}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{)), }\AttributeTok{bty =} \StringTok{"n"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in quartz(width = 10, height = 5): Quartz device is not available on
## this platform
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Plotting the bootstrapped and rarefied results}
\FunctionTok{plot}\NormalTok{(disparity, }\AttributeTok{type =} \StringTok{"continuous"}\NormalTok{, }\AttributeTok{main =} \StringTok{"bootstrapped results"}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(disparity, }\AttributeTok{type =} \StringTok{"continuous"}\NormalTok{, }\AttributeTok{main =} \StringTok{"rarefied results"}\NormalTok{,}
     \AttributeTok{rarefaction =}\NormalTok{ minimum\_size)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-245-1.pdf}

Nice. The curves look pretty similar.

\begin{quote}
Same as for the \texttt{summary.dispRity} function, check out the \texttt{plot.dispRity} manual for the many, many options available.
\end{quote}

\hypertarget{testing-differences}{%
\subsection{Testing differences}\label{testing-differences}}

Finally, to draw some valid conclusions from these results, we can apply some statistical tests.
We can test, for example, if mammalian disparity changed significantly through time over the last 100 million years.
To do so, we can compare the means of each time-bin in a sequential manner to see whether the disparity in bin \emph{n} is equal to the disparity in bin \emph{n+1}, and whether this is in turn equal to the disparity in bin \emph{n+2}, etc.
Because our data is temporally autocorrelated (i.e.~what happens in bin \emph{n+1} depends on what happened in bin \emph{n}) and pseudoreplicated (i.e.~each bootstrap draw creates non-independent time subsets because they are all based on the same time subsets), we apply a non-parametric mean comparison: the \texttt{wilcox.test}.
Also, we need to apply a p-value correction (e.g.~Bonferroni correction) to correct for multiple testing (see \texttt{?p.adjust} for more details).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Testing the differences between bins in the bootstrapped dataset.}
\FunctionTok{test.dispRity}\NormalTok{(disparity, }\AttributeTok{test =}\NormalTok{ wilcox.test, }\AttributeTok{comparison =} \StringTok{"sequential"}\NormalTok{,}
    \AttributeTok{correction =} \StringTok{"bonferroni"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
##                    statistic: W
## 100 - 80 : 80 - 60          730
## 80 - 60 : 60 - 40          2752
## 60 - 40 : 40 - 20          5461
## 40 - 20 : 20 - 0           4506
## 
## [[2]]
##                         p.value
## 100 - 80 : 80 - 60 7.081171e-25
## 80 - 60 : 60 - 40  1.593988e-07
## 60 - 40 : 40 - 20  1.000000e+00
## 40 - 20 : 20 - 0   9.115419e-01
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Testing the differences between bins in the rarefied dataset.}
\FunctionTok{test.dispRity}\NormalTok{(disparity, }\AttributeTok{test =}\NormalTok{ wilcox.test, }\AttributeTok{comparison =} \StringTok{"sequential"}\NormalTok{,}
    \AttributeTok{correction =} \StringTok{"bonferroni"}\NormalTok{, }\AttributeTok{rarefaction  =}\NormalTok{ minimum\_size)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
##                    statistic: W
## 100 - 80 : 80 - 60         1518
## 80 - 60 : 60 - 40          3722
## 60 - 40 : 40 - 20          5676
## 40 - 20 : 20 - 0           4160
## 
## [[2]]
##                         p.value
## 100 - 80 : 80 - 60 7.158946e-17
## 80 - 60 : 60 - 40  7.199018e-03
## 60 - 40 : 40 - 20  3.953427e-01
## 40 - 20 : 20 - 0   1.609715e-01
\end{verbatim}

Here our results show significant changes in disparity through time between all time bins (all p-values \textless{} 0.05).
However, when looking at the rarefied results, there is no significant difference between the time bins in the Palaeogene (60-40 to 40-20 Mya), suggesting that the differences detected in the first test might just be due to the differences in number of taxa sampled (13 or 6 taxa) in each time bin.

\hypertarget{some-more-advanced-stuff}{%
\section{Some more advanced stuff}\label{some-more-advanced-stuff}}

The previous section detailed some of the basic functionalities in the \texttt{dispRity} package but of course, you can do some much more advanced analysis, here is just a list of some specific tutorials from this manual that you might be interested in:

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{time-slicing}{Time slicing}: an alternative method to look at disparity through time that allows you to specify evolutionary models \citep{time-slice}.
\item
  \protect\hyperlink{disparity-metrics}{Many more disparity metrics}: there are many, many different things you might be interested to measure in your morphospace! This manual has some extended documentation on what to use (or check \citet{moms}).
\item
  Many more ways to look at disparity: you can for example, \protect\hyperlink{disparity-distribution}{use distributions rather than point estimates} for your disparity metric (e.g.~the variances rather than the sum of variances); or calculate \protect\hyperlink{other-matrices}{disparity from non ordinated matrices} or even \protect\hyperlink{multi.input}{from multiple matrices and trees}.
\item
  And finally there are much more advanced statistical tests you might be interested in using, such as the \protect\hyperlink{adonis}{NPMANOVA}, the \protect\hyperlink{dtt}{``disparity-through-time test''}, using a \protect\hyperlink{null-test}{null model approach} or some \protect\hyperlink{model-fitting}{model fitting}\ldots{}
\end{itemize}

You can even come up with your own ideas, implementations and modifications of the package: the \texttt{dispRity} package is a modular and collaborative package and I encourage you to contact me (\href{mailto:guillert@tcd.e}{\nolinkurl{guillert@tcd.e}}) for any ideas you have about adding new features to the package (whether you have them already implemented or not)!

\hypertarget{morphometric-geometric-demo-a-between-group-analysis}{%
\chapter{Morphometric geometric demo: a between group analysis}\label{morphometric-geometric-demo-a-between-group-analysis}}

This demo aims to give quick overview of the \texttt{dispRity} package (v.1.7) for palaeobiology analyses of disparity, including disparity through time analyses.

This demo showcases a typical between groups geometric morphometric analysis: we are going to test whether the disparity in two species of salamander (plethodons!) are different and in which ways they are different.

\hypertarget{before-starting-1}{%
\section{Before starting}\label{before-starting-1}}

Here we are going to use the \texttt{geomorph} \texttt{plethodon} dataset that is a set of 12 2D landmark coordinates for 40 specimens from two species of salamanders.
This section will really quickly cover how to make a Procrustes sumperimposition analysis and create a \texttt{geomorph} data.frame to have data ready for the \texttt{dispRity} package.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Loading geomorph}
\FunctionTok{library}\NormalTok{(geomorph)}

\DocumentationTok{\#\# Loading the plethodon dataset}
\FunctionTok{data}\NormalTok{(plethodon)}

\DocumentationTok{\#\# Running a simple Procrustes superimposition}
\NormalTok{gpa\_plethodon }\OtherTok{\textless{}{-}} \FunctionTok{gpagen}\NormalTok{(plethodon}\SpecialCharTok{$}\NormalTok{land)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Performing GPA
##   |                                                                              |                                                                      |   0%  |                                                                              |==================                                                    |  25%  |                                                                              |===================================                                   |  50%  |                                                                              |======================================================================| 100%
## 
## Making projections... Finished!
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Making a geomorph data frame object with the species and sites attributes}
\NormalTok{gdf\_plethodon }\OtherTok{\textless{}{-}} \FunctionTok{geomorph.data.frame}\NormalTok{(gpa\_plethodon,}
                                     \AttributeTok{species =}\NormalTok{ plethodon}\SpecialCharTok{$}\NormalTok{species,}
                                     \AttributeTok{site =}\NormalTok{ plethodon}\SpecialCharTok{$}\NormalTok{site)}
\end{Highlighting}
\end{Shaded}

You can of course use your very own landmark coordinates dataset (though you will have to do some modifications in the scripts that will come below - they will be easy though!).

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# You can replace the gdf\_plethodon by your own geomorph data frame!}
\NormalTok{my\_geomorph\_data }\OtherTok{\textless{}{-}}\NormalTok{ gdf\_plethodon}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-morphospace-1}{%
\subsection{The morphospace}\label{the-morphospace-1}}

The first step of every disparity analysis is to define your morphospace.

\begin{quote}
Note that this is actually not true at all and kept as a erroneous sentence: the first step of your disparity analysis should be to define your question!
\end{quote}

Our question here will be: is there a difference in disparity between the different species of salamanders and between the different sites (allopatric and sympatric)?

OK, now we can go to the \emph{second} step of every disparity analysis: defining the morphospace.
Here we will define it with the ordination of all possible Procrustes superimposed plethodon landmark coordinates.
You can do this directly in \texttt{dispRity} using the \texttt{geomorph.ordination} function that can input a geomorph data frame:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The morphospace}
\NormalTok{morphospace }\OtherTok{\textless{}{-}} \FunctionTok{geomorph.ordination}\NormalTok{(gdf\_plethodon)}
\end{Highlighting}
\end{Shaded}

This automatically generates a \texttt{dispRity} object with the information of each groups. You can find more information about \texttt{dispRity} objects \protect\hyperlink{disprity-object}{here} but basically it summarises the content of your object without spamming your R console and is associated with many utility functions like \texttt{summary} or \texttt{plot}. For example here you can quickly visualise the two first dimensions of your space using the \texttt{plot} function:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The dispRity object}
\NormalTok{morphospace}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  ---- dispRity object ---- 
## 4 customised subsets for 40 elements in one matrix:
##     species.Jord, species.Teyah, site.Allo, site.Symp.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Plotting the morphospace}
\FunctionTok{plot}\NormalTok{(morphospace)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-250-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Note that this only displays the two last groups (site.Allo and site.Symp) since they overlap!}
\end{Highlighting}
\end{Shaded}

The \texttt{dispRity} package function comes with a lot of documentation of examples so don't hesitate to type \texttt{plot.dispRity} to check more plotting options.

\hypertarget{calculating-disparity-2}{%
\section{Calculating disparity}\label{calculating-disparity-2}}

Now that we have our morphospace, we can think about what we want to measure.
Two aspects of disparity that would be interesting for our question (is there a difference in disparity between the different species of salamanders and between the different sites?) would be the differences in size in the morphospace (do both groups occupy the same amount of morphospace) and position in the morphospace (do the do groups occupy the same position in the morphospace?).

To choose which metric would cover best these two aspects, please check the \citet{moms} paper and associated \href{https://tguillerme.shinyapps.io/moms/}{app}. Here we are going to use the procrustes variance (\texttt{geomorph::morphol.disparity}) for measuring the size of the trait space and the average displacements \citep{moms} for the position in the trait space.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Defining a the procrustes variance metric}
\DocumentationTok{\#\# (as in geomorph::morphol.disparity)}
\NormalTok{proc.var }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(matrix) \{}\FunctionTok{sum}\NormalTok{(matrix}\SpecialCharTok{\^{}}\DecValTok{2}\NormalTok{)}\SpecialCharTok{/}\FunctionTok{nrow}\NormalTok{(matrix)\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# The size metric}
\NormalTok{test\_size }\OtherTok{\textless{}{-}} \FunctionTok{test.metric}\NormalTok{(morphospace, }\AttributeTok{metric =}\NormalTok{ proc.var,}
                         \AttributeTok{shifts =} \FunctionTok{c}\NormalTok{(}\StringTok{"random"}\NormalTok{, }\StringTok{"size"}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(test\_size)}
\FunctionTok{summary}\NormalTok{(test\_size)}

\DocumentationTok{\#\# The position metric}
\NormalTok{test\_position }\OtherTok{\textless{}{-}} \FunctionTok{test.metric}\NormalTok{(morphospace, }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(mean, displacements),}
                         \AttributeTok{shifts =} \FunctionTok{c}\NormalTok{(}\StringTok{"random"}\NormalTok{, }\StringTok{"position"}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(test\_position)}
\FunctionTok{summary}\NormalTok{(test\_position)}
\end{Highlighting}
\end{Shaded}

You can see \protect\hyperlink{test-metric}{here} for more details on the \texttt{test.metric} function but basically these graphs are showing that there is a relation between changes in size and in position for each metric.
Note that there are some caveats here but the selection of the metric is just for the sake of the example!

Note also the format of defining the disparity metrics here using \texttt{metric\ =\ c(mean,\ displacements)} or \texttt{metric\ =\ proc.var}. This is a core bit of the \texttt{dispRity} package were you can define your own metric as a function or a set of functions. You can find more info about this in the \protect\hyperlink{disparity-metrics}{\texttt{dispRity} metric section} but in brief, the \texttt{dispRity} package considers metrics by their ``dimensions'' level which corresponds to what they output. For example, the function \texttt{mean} is a dimension level 1 function because no matter the input it outputs a single value (the mean), \texttt{displacements} on the other hand is a dimension level 2 function because it will output the ratio between the distance from the centroid and from the centre of the trait space for each row in a matrix (an example of a dimensions level 3 would be the function \texttt{var} that outputs a matrix).
The \texttt{dispRity} package always automatically sorts the dimensions levels: it will always run dimensions level 3 \textgreater{} dimensions level 2 \textgreater{} and dimensions level 1. In this case both \texttt{c(mean,\ displacements)} and \texttt{c(mean,\ displacements)} will result in actually running \texttt{mean(displacements(matrix))}.
Alternatively you can define your metric prior to the disparity analysis like we did for the \texttt{proc.var} function.

Anyways, we can measure disparity using these two metrics on all the groups as follows:

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Bootstrapped disparity}
\NormalTok{disparity\_size }\OtherTok{\textless{}{-}}  \FunctionTok{dispRity}\NormalTok{(}\FunctionTok{boot.matrix}\NormalTok{(morphospace), }\AttributeTok{metric =}\NormalTok{ proc.var)}
\NormalTok{disparity\_position }\OtherTok{\textless{}{-}} \FunctionTok{dispRity}\NormalTok{(}\FunctionTok{boot.matrix}\NormalTok{(morphospace), }\AttributeTok{metric =} \FunctionTok{c}\NormalTok{(mean, displacements))}
\end{Highlighting}
\end{Shaded}

Note that here we use the \texttt{boot.matrix} function for quickly bootstrapping the matrix.
This is not an essential step in this kind of analysis but it allows to ``reduce'' the effect of outliers and create a distribution of disparity measures (rather than single point estimates).

\hypertarget{analyse-the-results}{%
\section{Analyse the results}\label{analyse-the-results}}

We can visualise the results using the \texttt{plot} function on the resulting disparity objects (or summarising them using \texttt{summary}):

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Plotting the results}
\FunctionTok{par}\NormalTok{(}\AttributeTok{mfrow =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{))}
\FunctionTok{plot}\NormalTok{(disparity\_size, }\AttributeTok{main =} \StringTok{"group sizes"}\NormalTok{, }\AttributeTok{las =} \DecValTok{2}\NormalTok{, }\AttributeTok{xlab =} \StringTok{""}\NormalTok{)}
\FunctionTok{plot}\NormalTok{(disparity\_position, }\AttributeTok{main =} \StringTok{"group positions"}\NormalTok{, }\AttributeTok{las =} \DecValTok{2}\NormalTok{, }\AttributeTok{xlab =} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{dispRity_manual_files/figure-latex/unnamed-chunk-254-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Summarising the results}
\FunctionTok{summary}\NormalTok{(disparity\_size)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         subsets  n   obs bs.median  2.5%   25%   75% 97.5%
## 1  species.Jord 20 0.005     0.005 0.004 0.005 0.005 0.005
## 2 species.Teyah 20 0.005     0.005 0.004 0.005 0.005 0.006
## 3     site.Allo 20 0.004     0.004 0.003 0.003 0.004 0.004
## 4     site.Symp 20 0.006     0.006 0.006 0.006 0.006 0.007
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{summary}\NormalTok{(disparity\_position)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         subsets  n   obs bs.median  2.5%   25%   75% 97.5%
## 1  species.Jord 20 1.096     1.122 1.069 1.104 1.168 1.404
## 2 species.Teyah 20 1.070     1.095 1.029 1.070 1.146 1.320
## 3     site.Allo 20 1.377     1.415 1.311 1.369 1.464 1.526
## 4     site.Symp 20 1.168     1.220 1.158 1.190 1.270 1.498
\end{verbatim}

Just from looking at the data, we can guess that there is not much difference in terms of morphospace occupancy and position for the species but there is on for the sites (allopatric or sympatric).
We can test it using a simple non-parametric mean difference test (e.g.~\texttt{wilcox.test}) using the \texttt{dispRity} package.

\begin{Shaded}
\begin{Highlighting}[]
\DocumentationTok{\#\# Testing the differences}
\FunctionTok{test.dispRity}\NormalTok{(disparity\_size, }\AttributeTok{test =}\NormalTok{ wilcox.test, }\AttributeTok{correction =} \StringTok{"bonferroni"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
##                              statistic: W
## species.Jord : species.Teyah         3842
## species.Jord : site.Allo             9919
## species.Jord : site.Symp                7
## species.Teyah : site.Allo            9939
## species.Teyah : site.Symp             155
## site.Allo : site.Symp                   0
## 
## [[2]]
##                                   p.value
## species.Jord : species.Teyah 2.808435e-02
## species.Jord : site.Allo     1.718817e-32
## species.Jord : site.Symp     1.896841e-33
## species.Teyah : site.Allo    9.504256e-33
## species.Teyah : site.Symp    1.507734e-31
## site.Allo : site.Symp        1.537286e-33
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{test.dispRity}\NormalTok{(disparity\_position, }\AttributeTok{test =}\NormalTok{ wilcox.test, }\AttributeTok{correction =} \StringTok{"bonferroni"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
##                              statistic: W
## species.Jord : species.Teyah         6639
## species.Jord : site.Allo              262
## species.Jord : site.Symp             1386
## species.Teyah : site.Allo              91
## species.Teyah : site.Symp             981
## site.Allo : site.Symp                9373
## 
## [[2]]
##                                   p.value
## species.Jord : species.Teyah 3.744848e-04
## species.Jord : site.Allo     3.288928e-30
## species.Jord : site.Symp     6.326430e-18
## species.Teyah : site.Allo    2.309399e-32
## species.Teyah : site.Symp    5.609280e-22
## site.Allo : site.Symp        7.278818e-26
\end{verbatim}

So by applying the tests we see a difference in terms of position between each groups and differences in size between groups but between the species.

\hypertarget{disprity-r-package-manual}{%
\chapter{dispRity R package manual}\label{disprity-r-package-manual}}

\hypertarget{references}{%
\chapter{References}\label{references}}

  \bibliography{../References.bib,../packages.bib}

\end{document}
